---
id: toplevel-reference
title: toplevel
hide_table_of_contents: true
---
import Syntax from '@theme/Syntax';
import SyntaxTitle from '@theme/SyntaxTitle';



<SyntaxTitle syntax="cameligo">
type string
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type string
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type bytes
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type bytes
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type int
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type int
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type nat
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type nat
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type unit
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type operation
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type operation
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type tez
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type tez
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type address
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type address
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type signature
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type signature
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type key
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type key
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type key&#95;hash
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type key&#95;hash
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type timestamp
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type timestamp
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type list
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type list
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type big&#95;map
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type big&#95;map
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type map
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type map
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type set
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type set
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type contract
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type contract
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type michelson&#95;or
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type michelson&#95;or
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type michelson&#95;pair
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type michelson&#95;pair
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type chain&#95;id
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type chain&#95;id
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type baker&#95;hash
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type baker&#95;hash
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type pvss&#95;key
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type pvss&#95;key
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type sapling&#95;state
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type sapling&#95;state
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type sapling&#95;transaction
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type sapling&#95;transaction
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type baker&#95;operation
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type baker&#95;operation
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type bls12&#95;381&#95;g1
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type bls12&#95;381&#95;g1
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type bls12&#95;381&#95;g2
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type bls12&#95;381&#95;g2
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type bls12&#95;381&#95;fr
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type bls12&#95;381&#95;fr
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type never
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type never
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type ticket
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type ticket
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type chest
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type chest
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type chest&#95;key
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type chest&#95;key
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type external&#95;ediv
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type external&#95;ediv
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type external&#95;and
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type external&#95;and
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type external&#95;or
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type external&#95;or
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type external&#95;xor
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type external&#95;xor
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type external&#95;lsl
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type external&#95;lsl
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type external&#95;lsr
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type external&#95;lsr
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type external&#95;bytes
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type external&#95;bytes
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type (&#39;param, &#39;storage) entrypoint = &#39;param -&gt; &#39;storage -&gt; (operation list * &#39;storage)
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type entrypoint&lt;param, storage&gt; = (&#95;: param) =&gt; (&#95;: storage) =&gt; [list&lt;operation&gt;, storage]
</SyntaxTitle>
Type of entrypoints


<SyntaxTitle syntax="cameligo">
type bool = bool
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type bool = bool
</SyntaxTitle>
<Syntax syntax="cameligo">

Type of the booleans. Note: Values `true` and `false` are
  predefined constants such that `true` equals `True` and `false`
  equals `False`.

</Syntax>

<Syntax syntax="jsligo">

Type of the booleans. Note: Values `true` and `false` are
  predefined constants.

</Syntax>


<SyntaxTitle syntax="cameligo">
type &#39;a option = &#39;a option
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type option&lt;a&gt; = option&lt;a&gt;
</SyntaxTitle>
<Syntax syntax="cameligo">

Type of optional values. They are useful, for example, when a
  function can fail, but the caller wants to be able to handle the
  failure, which is then denoted by the result `None`. Note:
  Assertions and `failwith` do not allow handling.

</Syntax>

<Syntax syntax="jsligo">

Type of optional values. They are useful, for example, when a
  function can fail, but the caller wants to be able to handle the
  failure, which is then denoted by the result `None()`. Note:
  Assertions and `failwith` do not allow handling.

</Syntax>


<SyntaxTitle syntax="cameligo">
val unit : unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let unit: unit
</SyntaxTitle>
Unit type. It is useful for typing side-effects, for example
  failures, some iterators and implicit accounts.


<SyntaxTitle syntax="cameligo">
val ignore : &#39;a.&#39;a -&gt; unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let ignore: &lt;a&gt;(&#95;: a) =&gt; unit
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `ignore v` evaluates `v` and ignores its value, returning
  instead the unit value. This is useful when the argument of `ignore`
  performs side-effects.

</Syntax>

<Syntax syntax="jsligo">

The call `ignore(v)` evaluates `v` and ignores its value, returning
  instead the unit value. This is useful when the argument of `ignore`
  performs side-effects.

</Syntax>


<SyntaxTitle syntax="cameligo">
val curry : &#39;a &#39;b &#39;c.((&#39;a * &#39;b) -&gt; &#39;c) -&gt; &#39;a -&gt; &#39;b -&gt; &#39;c
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let curry: &lt;a, b, c&gt;(&#95;: (&#95;: [a, b]) =&gt; c) =&gt; (&#95;: a) =&gt; (&#95;: b) =&gt; c
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `curry f x y` has the same value as `f (x,y)`.

</Syntax>

<Syntax syntax="jsligo">

The call `curry(f,x,y)` has the same value as `f(x,y)`.

</Syntax>


<SyntaxTitle syntax="cameligo">
val uncurry : &#39;a &#39;b &#39;c.(&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; (&#39;a * &#39;b) -&gt; &#39;c
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let uncurry: &lt;a, b, c&gt;(&#95;: (&#95;: a) =&gt; (&#95;: b) =&gt; c) =&gt; (&#95;: [a, b]) =&gt; c
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `uncurry f (x,y)` has the same value as `f x y`.

</Syntax>

<Syntax syntax="jsligo">

The call `uncurry(f,[x,y])` has the same value as `f(x)(y)`.

</Syntax>


<SyntaxTitle syntax="cameligo">
val fst : &#39;a &#39;b.(&#39;a * &#39;b) -&gt; &#39;a
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let fst: &lt;a, b&gt;(&#95;: [a, b]) =&gt; a
</SyntaxTitle>
Projecting the first component of a pair


<SyntaxTitle syntax="cameligo">
val snd : &#39;a &#39;b.(&#39;a * &#39;b) -&gt; &#39;b
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let snd: &lt;a, b&gt;(&#95;: [a, b]) =&gt; b
</SyntaxTitle>
Projecting the second component of a pair.


<SyntaxTitle syntax="cameligo">
val failwith : &#39;err &#39;a.&#39;err -&gt; &#39;a
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let failwith: &lt;err, a&gt;(&#95;: err) =&gt; a
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `failwith e` terminates the execution with the value `e`,
  standing for an error. Note: Using a string for an error message can
  be costly in terms of size.

</Syntax>

<Syntax syntax="jsligo">

The call `failwith(e)` terminates the execution with the value `e`,
  standing for an error. Note: Using a string for an error message can
  be costly in terms of size.

</Syntax>


<SyntaxTitle syntax="cameligo">
val bytes : &#39;a.&#39;a -&gt; &#39;a external&#95;bytes
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let bytes: &lt;a&gt;(&#95;: a) =&gt; external&#95;bytes&lt;a&gt;
</SyntaxTitle>
The function `bytes` encodes an integer or a natural number to
  bytes using the big-endian encoding. For integers, negative numbers
  are considered in two's complement representation.


<SyntaxTitle syntax="cameligo">
val assert&#95;with&#95;error : bool -&gt; string -&gt; unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let assert&#95;with&#95;error: (&#95;: bool) =&gt; (&#95;: string) =&gt; unit
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `assert_with_error cond error` terminates the execution
  with the string `error` (that is, an error message) if, and only if,
  the boolean condition `cond` is false.

</Syntax>

<Syntax syntax="jsligo">

The call `assert_with_error(cond, error)` terminates the execution
  with the string `error` (that is, an error message) if, and only if,
  the boolean condition `cond` is false.

</Syntax>


<SyntaxTitle syntax="cameligo">
val assert : bool -&gt; unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let assert: (&#95;: bool) =&gt; unit
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `assert cond` terminates the execution with the string
  `"failed assertion"` if, and only if, the boolean condition `cond`
  is false.

</Syntax>

<Syntax syntax="jsligo">

The call `assert(cond)` terminates the execution with the string
  `"failed assertion"` if, and only if, the boolean condition `cond`
  is false.

</Syntax>


<SyntaxTitle syntax="cameligo">
val assert&#95;some&#95;with&#95;error : &#39;a.&#39;a option -&gt; string -&gt; unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let assert&#95;some&#95;with&#95;error: &lt;a&gt;(&#95;: option&lt;a&gt;) =&gt; (&#95;: string) =&gt; unit
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `assert_some_with_error opt err` terminates the execution
  with the string `err` (that is, an error message) if, and only if,
  `opt` is `None`.

</Syntax>

<Syntax syntax="jsligo">

The call `assert_some_with_error(opt, err)` terminates the execution
  with the string `err` (that is, an error message) if, and only if,
  `opt` is `None()`.

</Syntax>


<SyntaxTitle syntax="cameligo">
val assert&#95;some : &#39;a.&#39;a option -&gt; unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let assert&#95;some: &lt;a&gt;(&#95;: option&lt;a&gt;) =&gt; unit
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `assert_some opt` terminates the execution with the
  string `"failed assert some"` if, and only if, `opt` is `None`.

</Syntax>

<Syntax syntax="jsligo">

The call `assert_some(opt)` terminates the execution with the
  string `"failed assert some"` if, and only if, `opt` is `None()`.

</Syntax>


<SyntaxTitle syntax="cameligo">
val assert&#95;none&#95;with&#95;error : &#39;a.&#39;a option -&gt; string -&gt; unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let assert&#95;none&#95;with&#95;error: &lt;a&gt;(&#95;: option&lt;a&gt;) =&gt; (&#95;: string) =&gt; unit
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `assert_none_with_error opt err` terminates the execution
  with the string `err` (that is, an error message) if, and only if,
  `opt` is an optional value different from `None`.

</Syntax>

<Syntax syntax="jsligo">

The call `assert_none_with_error(opt, err)` terminates the execution
  with the string `err` (that is, an error message) if, and only if,
  `opt` is an optional value different from `None()`.

</Syntax>


<SyntaxTitle syntax="cameligo">
val assert&#95;none : &#39;a.&#39;a option -&gt; unit
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let assert&#95;none: &lt;a&gt;(&#95;: option&lt;a&gt;) =&gt; unit
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `assert_none opt` terminates the execution with the string
  `"failed assert none"` if, and only if, `opt` is not `None`.

</Syntax>

<Syntax syntax="jsligo">

The call `assert_none(opt)` terminates the execution with the string
  `"failed assert none"` if, and only if, `opt` is not `None()`.

</Syntax>


<SyntaxTitle syntax="cameligo">
val abs : int -&gt; nat
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let abs: (&#95;: int) =&gt; nat
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `abs i` is the absolute value of `i`.

</Syntax>

<Syntax syntax="jsligo">

The call `abs(i)` is the absolute value of `i`.

</Syntax>


<SyntaxTitle syntax="cameligo">
val is&#95;nat : int -&gt; nat option
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let is&#95;nat: (&#95;: int) =&gt; option&lt;nat&gt;
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `is_nat i` is `Some n`, where `n` is the absolute
  value of `i`, if, and only if, `i` is positive or zero.

</Syntax>

<Syntax syntax="jsligo">

The call `is_nat(i)` is `Some(n)`, where `n` is the absolute
  value of `i`, if, and only if, `i` is positive or zero.

</Syntax>


<SyntaxTitle syntax="cameligo">
val int : &#39;a.&#39;a -&gt; int
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let int: &lt;a&gt;(&#95;: a) =&gt; int
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `int v` casts the value `v` to an integer.

  For natural numbers, the function `int` is the identity cast from
  `nat` to `int`. For BLS12-381 field elements, the returned value is
  always between 0 (inclusive) and the order of the BLS12-381 field
  (exclusive). For bytes, the function `int` decodes the bytes using
  the big-endian encoding, where negative numbers are considered in
  two's complement representation.

</Syntax>

<Syntax syntax="jsligo">

The call `int(v)` casts the value `v` to an integer.

  For natural numbers, the function `int` is the identity cast from
  `nat` to `int`. For BLS12-381 field elements, the returned value is
  always between 0 (inclusive) and the order of the BLS12-381 field
  (exclusive). For bytes, the function `int` decodes the bytes using
  the big-endian encoding, where negative numbers are considered in
  two's complement representation.

</Syntax>


<SyntaxTitle syntax="cameligo">
val nat : bytes -&gt; nat
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let nat: (&#95;: bytes) =&gt; nat
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `nat b` casts the bytes `b` into a natural number.

</Syntax>

<Syntax syntax="jsligo">

The call `nat(b)` casts the bytes `b` into a natural number.

</Syntax>


<SyntaxTitle syntax="cameligo">
val ediv : &#39;a &#39;b.&#39;a -&gt; &#39;b -&gt; (&#39;a, &#39;b) external&#95;ediv
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
let ediv: &lt;a, b&gt;(&#95;: a) =&gt; (&#95;: b) =&gt; external&#95;ediv&lt;a, b&gt;
</SyntaxTitle>
<Syntax syntax="cameligo">

The call `ediv z1 z2`, where `z1` and `z2` are either of type
  `int` or `nat`, returns `None` if `z2` is zero; otherwise, it
  returns the pair `(q,r)`, where `q` is the quotient and `r` the
  positive remainder, as is the convention of the mathematical
  Euclidian division.

</Syntax>

<Syntax syntax="jsligo">

The call `ediv(z1, z2)`, where `z1` and `z2` are either of type
  `int` or `nat`, returns `None()` if `z2` is zero; otherwise, it
  returns the pair `[q,r]`, where `q` is the quotient and `r` the
  positive remainder, as is the convention of the mathematical
  Euclidian division.

</Syntax>


<SyntaxTitle syntax="cameligo">
type dynamic&#95;entrypoints = (nat, bytes) big&#95;map
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type dynamic&#95;entrypoints = big&#95;map&lt;nat, bytes&gt;
</SyntaxTitle>
Dynamic entrypoints

   Dynamic entrypoints are lazy entrypoints stored in the contract within
   a big_map. They can then be updated or removed without deploying a new
   contract.

   A contract with dynamic entrypoints must have at least one `@entry`
   declaration (as any other contract); it also must obey some
   convention on storage type definition and have at least one
   `@dyn_entry` declaration.

   LIGO will then include the defined dynamic entries into the
   contract initial storage.


<SyntaxTitle syntax="cameligo">
type dynamic&#95;entrypoint
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type dynamic&#95;entrypoint
</SyntaxTitle>
A value of type `dynamic_entrypoint` denotes a typed key in an
  dynamic entrypoint


<SyntaxTitle syntax="cameligo">
type michelson&#95;program
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type michelson&#95;program
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type typed&#95;address
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type typed&#95;address
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type mutation
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type mutation
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type michelson&#95;contract
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type michelson&#95;contract
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type pbt&#95;gen
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type pbt&#95;gen
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type int64
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type int64
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type views
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type views
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type test&#95;exec&#95;error&#95;balance&#95;too&#95;low = &#123;
 contract&#95;balance : tez;
 contract&#95;too&#95;low : address;
 spend&#95;request : tez
&#125;
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type test&#95;exec&#95;error&#95;balance&#95;too&#95;low = &#123; contract&#95;balance: tez; contract&#95;too&#95;low: address; spend&#95;request: tez &#125;
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type test&#95;exec&#95;error = | Balance&#95;too&#95;low of test&#95;exec&#95;error&#95;balance&#95;too&#95;low
| Other of string
| Rejected of (michelson&#95;program * address)
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type test&#95;exec&#95;error = [&quot;Balance&#95;too&#95;low&quot;, test&#95;exec&#95;error&#95;balance&#95;too&#95;low] | [&quot;Other&quot;, string] | [&quot;Rejected&quot;, michelson&#95;program, address]
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type test&#95;exec&#95;result = | Fail of test&#95;exec&#95;error
| Success of nat
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type test&#95;exec&#95;result = [&quot;Fail&quot;, test&#95;exec&#95;error] | [&quot;Success&quot;, nat]
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type test&#95;baker&#95;policy = | By&#95;account of address
| By&#95;round of int
| Excluding of address list
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type test&#95;baker&#95;policy = [&quot;By&#95;account&quot;, address] | [&quot;By&#95;round&quot;, int] | [&quot;Excluding&quot;, list&lt;address&gt;]
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type &#39;a pbt&#95;test = &#39;a pbt&#95;gen * &#39;a -&gt; bool
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type pbt&#95;test&lt;a&gt; = [pbt&#95;gen&lt;a&gt;, (&#95;: a) =&gt; bool]
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type &#39;a pbt&#95;result = | Fail of &#39;a
| Success
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type pbt&#95;result&lt;a&gt; = [&quot;Fail&quot;, a] | [&quot;Success&quot;]
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type &#39;s unforged&#95;ticket = &#123;
 amount : nat;
 ticketer : address;
 value : &#39;s
&#125;
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type unforged&#95;ticket&lt;s&gt; = &#123; amount: nat; ticketer: address; value: s &#125;
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type (&#39;param, &#39;storage) module&#95;contract = (&#39;param * &#39;storage) -&gt; (operation list * &#39;storage) * &#39;storage views * dynamic&#95;entrypoints option
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type module&#95;contract&lt;param, storage&gt; = [(&#95;: [param, storage]) =&gt; [list&lt;operation&gt;, storage], views&lt;storage&gt;, option&lt;dynamic&#95;entrypoints&gt;]
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type (&#39;param, &#39;storage) origination&#95;result = &#123;
 addr : (&#39;param, &#39;storage) typed&#95;address;
 code : (&#39;param, &#39;storage) michelson&#95;contract;
 size : int
&#125;
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type origination&#95;result&lt;param, storage&gt; = &#123; addr: typed&#95;address&lt;param, storage&gt;; code: michelson&#95;contract&lt;param, storage&gt;; size: int &#125;
</SyntaxTitle>

<SyntaxTitle syntax="cameligo">
type implicit&#95;address = (unit, unit) typed&#95;address
</SyntaxTitle>
<SyntaxTitle syntax="jsligo">
type implicit&#95;address = typed&#95;address&lt;unit, unit&gt;
</SyntaxTitle>
