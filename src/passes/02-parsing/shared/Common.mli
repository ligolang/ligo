(* Parser and pretty-printer factory *)

(* Vendors dependencies *)

module Region      = Simple_utils.Region
module Trace       = Simple_utils.Trace
module Lexbuf      = Simple_utils.Lexbuf
module Unit        = LexerLib.Unit
module Config      = Preprocessor.Config
module type PARSER = ParserLib.LowAPI.PARSER

(* Internal dependencies *)

module Token    = Lexing_shared.Token
module Pipeline = Lexing_shared.Pipeline

(* PRETTY-PRINTING *)

(* The [cols] parameters of [print_pattern] is the witdh measured in
   columns. If none, the width of the terminal is selected. If none,
   it is set to 60-character wide. *)

module type PRETTY =
  sig
    type state
    val default_state : state

    type cst
    type expr
    type type_expr
    type pattern
    type signature_expr

    val print           : state -> cst       -> PPrint.document
    val print_expr      : state -> expr      -> PPrint.document
    val print_type_expr : state -> type_expr -> PPrint.document
    val print_pattern   : state -> pattern   -> PPrint.document
    val print_signature_expr : state -> signature_expr -> PPrint.document
  end

(* PARSING *)

module type CST =
  sig
    type t
    type expr
    type type_expr
    type pattern
    type signature_expr
  end

module type PAR_ERR =
  sig
    val message : int -> string
  end

module MakeParser
         (Config      : Config.S)
         (Token       : Token.S)
         (ParErr      : PAR_ERR)
         (UnitPasses  : Pipeline.PASSES with type item = Token.t Unit.t)
         (TokenPasses : Pipeline.PASSES with type item = Token.t)
         (CST         : sig type tree end)
         (Parser      : PARSER with type token = Token.t
                                and type tree = CST.tree) :
  sig
    type file_path = string

    type raise = (Errors.t, Main_warnings.all) Trace.raise

    type 'a parser =
      ?jsligo:string option option ->
      ?preprocess:bool ->
      ?project_root:file_path ->
      raise:raise ->
      Buffer.t ->
      'a
    module type ParserLexer = sig
      module Parser : ParserLib.LowAPI.S
        with type token = Token.t and type tree = CST.tree
      module Lexer : Lexing_shared.TopAPI.S
      module DefaultPreprocParams : Preprocessor.CLI.PARAMETERS
    end

    module type ParserLexerOptions = sig
      val jsligo : file_path option option
      val preprocess : bool
      val project_root : file_path option
      val raise : raise
      val file_path : file_path option
    end

    module ParserLexerGenerator (Options : ParserLexerOptions) : ParserLexer

    val parse_file   : (file_path -> CST.tree) parser
    val parse_string : CST.tree parser
  end

(* Signature of parsers generated by Menhir, plus module [CST]. *)

module type LIGO_PARSER =
  sig
    (* Results *)

    module CST :
      sig
        type t
        type expr
      end

    (* The type of tokens. *)

    type token

    (* This exception is raised by the monolithic API functions. *)

    exception Error

    val interactive_expr :
      (Lexing.lexbuf -> token) -> Lexing.lexbuf -> CST.expr

    val contract :
      (Lexing.lexbuf -> token) -> Lexing.lexbuf -> CST.t

    (* The monolithic API. *)

    module MenhirInterpreter : MenhirLib.IncrementalEngine.EVERYTHING
           with type token = token

    (* The entry point(s) to the incremental API. *)

    module Incremental :
      sig
        val interactive_expr :
          Lexing.position -> CST.expr MenhirInterpreter.checkpoint

        val contract :
          Lexing.position -> CST.t MenhirInterpreter.checkpoint
      end

    (* The recovery API. *)

    module Recovery :
      sig
        include Merlin_recovery.RECOVERY_GENERATED
                with module I := MenhirInterpreter

        val default_value : Region.t -> 'a MenhirInterpreter.symbol -> 'a
      end
  end

(* Making parsers for CSTs and expressions *)

module MakeTwoParsers
         (Config      : Config.S)
         (Token       : Token.S)
         (ParErr      : PAR_ERR)
         (UnitPasses  : Pipeline.PASSES with type item = Token.t Unit.t)
         (TokenPasses : Pipeline.PASSES with type item = Token.t)
         (CST         : sig type t type expr end)
         (Parser      : LIGO_PARSER with type token = Token.t
                                     and module CST = CST) :
  sig
    (* Parsing contracts *)

    type file_path = string

    module Errors = Errors

    type raise = (Errors.t, Main_warnings.all) Trace.raise

    type 'a parser =
      ?jsligo:string option option ->
      ?preprocess:bool ->
      ?project_root:file_path ->
      raise:raise ->
      Buffer.t ->
      'a

    val parse_file   : (file_path -> CST.t) parser
    val parse_string : CST.t parser

    (* Parsing expressions *)

    val parse_expression : CST.expr parser

    (* Aliases *)

    val from_file   : (file_path -> CST.t) parser
    val from_string : CST.t parser
    val expression  : CST.expr parser
  end

(* PRETTY-PRINTING *)

module MakePretty (CST    : CST)
                  (Pretty : PRETTY
                            with type cst       = CST.t
                            and  type expr      = CST.expr
                            and  type type_expr = CST.type_expr
                            and  type signature_expr = CST.signature_expr
                            and  type pattern   = CST.pattern) :
  sig
    (* Pretty-print a contract from its CST *)

    val pretty_print : Pretty.state -> CST.t -> Buffer.t

    (* Pretty-print an expression from its CST *)

    val pretty_print_expression : Pretty.state -> CST.expr -> Buffer.t

    (* Pretty-print a pattern from its CST. The [cols] parameters is
       the witdh measured in columns. If none, the width of the
       terminal is selected. If none, it is set to 60-character
       wide. *)

    val pretty_print_pattern :
      ?cols:int -> Pretty.state -> CST.pattern -> Buffer.t

    (* Pretty-print a type expression from its CST *)

    val pretty_print_type_expr : Pretty.state -> CST.type_expr -> Buffer.t
    val pretty_print_signature_expr : Pretty.state -> CST.signature_expr -> Buffer.t
  end
