interactive_expr: LBRACE ELLIPSIS ZWSP
##
## Ends in an error in state: 28.
##
## property -> ELLIPSIS . expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed record expression.
At this point, a record is expected as an expression.

interactive_expr: LBRACE Ident ZWSP
##
## Ends in an error in state: 27.
##
## property -> Ident . [ SEMI RBRACE COMMA ]
## property_name -> Ident . [ COLON ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record expression.
At this point, one of the following is expected:
  * a colon ':' followed by the expression assigned to the field;
  * a comma ',' or semicolon ';' followed by another field assignment,
    if the field is punned (that is, the name of the field is also the
    variable assigned to it);
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE UIdent ZWSP
##
## Ends in an error in state: 705.
##
## property -> property_name . COLON expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_name
##
interactive_expr: LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 713.
##
## property -> nseq(Attr) property_name . COLON expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) property_name
##

Ill-formed record expression.
At this point, a colon ':' is expected, followed by the expression
assigned to the field.

interactive_expr: LBRACE UIdent COLON ZWSP
##
## Ends in an error in state: 706.
##
## property -> property_name COLON . expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_name COLON
##
contract: LBRACE Attr Ident COLON ZWSP
##
## Ends in an error in state: 714.
##
## property -> nseq(Attr) property_name COLON . expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) property_name COLON
##

Ill-formed record (object) expression.
At this point, an expression is expected to be assigned to the field
(property).

interactive_expr: LBRACE ZWSP
##
## Ends in an error in state: 23.
##
## braces(__anonymous_3) -> LBRACE . sep_or_term_list(property,object_sep) RBRACE [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record expression.
At this point, field declarations are expected, separated by commas
',' or semicolons ';'.

interactive_expr: Bytes SEMI
##
## Ends in an error in state: 797.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##

Ill-formed expression.
At this point, if the expression is complete, the end of the input is
expected.

contract: Const ZWSP
##
## Ends in an error in state: 411.
##
## const_decl -> Const . binding_list [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Const
##
contract: Let ZWSP
##
## Ends in an error in state: 324.
##
## let_decl -> Let . binding_list [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Let
##
contract: Let WILD EQ Bytes COMMA ZWSP
##
## Ends in an error in state: 374.
##
## nsepseq(binding_initializer,COMMA) -> binding_initializer COMMA . nsepseq(binding_initializer,COMMA) [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## binding_initializer COMMA
##

Ill-formed value declaration.
At this point, a pattern is expected, e.g. a variable.

contract: Export ZWSP
##
## Ends in an error in state: 767.
##
## export_decl -> Export . declaration [ SEMI RBRACE EOF ]
## export_decl -> Export . nseq(Attr) declaration [ SEMI RBRACE EOF ]
## namespace_stmt -> Export . namespace [ SEMI RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## Export
##
contract: Attr Export ZWSP
##
## Ends in an error in state: 776.
##
## export_decl -> nseq(Attr) Export . declaration [ SEMI RBRACE EOF ]
## export_decl -> nseq(Attr) Export . nseq(Attr) declaration [ SEMI RBRACE EOF ]
## namespace_stmt -> nseq(Attr) Export . namespace [ SEMI RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Export
##
contract: LBRACE Attr Export ZWSP
##
## Ends in an error in state: 529.
##
## export_decl -> nseq(Attr) Export . declaration [ SEMI RBRACE Else EOF Default Case ]
## export_decl -> nseq(Attr) Export . nseq(Attr) declaration [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Export
##

Ill-formed export declaration.
At this point, one of the following is expected:
  * a value or type declaration, if exporting a declaration;
  * the keyword 'namespace', if exporting a namespace.

contract: LBRACE Export ZWSP
##
## Ends in an error in state: 410.
##
## export_decl -> Export . declaration [ SEMI RBRACE Else EOF Default Case ]
## export_decl -> Export . nseq(Attr) declaration [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Export
##

Ill-formed export declaration.
At this point, one of the following is expected:
  * attributes for a declaration;
  * a value or type declaration.

contract: Export Attr ZWSP
##
## Ends in an error in state: 414.
##
## export_decl -> Export nseq(Attr) . declaration [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Export nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##
contract: Attr Export Attr ZWSP
##
## Ends in an error in state: 530.
##
## export_decl -> nseq(Attr) Export nseq(Attr) . declaration [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Export nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed export declaration.
At this point, if the attribute is complete, a value or type declaration is expected.

contract: If LPAR Bytes RPAR Attr For LPAR Const Ident Of Bytes COLON
##
## Ends in an error in state: 605.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Const Ident Of expr . RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const Ident Of expr . RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const Ident Of expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: If LPAR Bytes RPAR For LPAR Let Ident Of Ident SEMI
##
## Ends in an error in state: 638.
##
## for_of_stmt(closed_stmt) -> For LPAR Let Ident Of expr . RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Let Ident Of expr . RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Let Ident Of expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 30, spurious reduction of production member_expr -> Ident
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: For LPAR Let Ident Of Ident SEMI
##
## Ends in an error in state: 547.
##
## for_of_stmt(statement) -> For LPAR Let Ident Of expr . RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Let Ident Of expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 30, spurious reduction of production member_expr -> Ident
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: Attr For LPAR Const Ident Of Bytes COLON
##
## Ends in an error in state: 510.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const Ident Of expr . RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const Ident Of expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: If LPAR Bytes RPAR For LPAR Const Ident Of Bytes While
##
## Ends in an error in state: 644.
##
## for_of_stmt(closed_stmt) -> For LPAR Const Ident Of expr . RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Const Ident Of expr . RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Const Ident Of expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: If LPAR Bytes RPAR Attr For LPAR Let Ident Of Bytes While
##
## Ends in an error in state: 599.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Let Ident Of expr . RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let Ident Of expr . RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let Ident Of expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: Attr For LPAR Let Ident Of Bytes While
##
## Ends in an error in state: 504.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let Ident Of expr . RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let Ident Of expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: For LPAR Const Ident Of Bytes While
##
## Ends in an error in state: 553.
##
## for_of_stmt(statement) -> For LPAR Const Ident Of expr . RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Const Ident Of expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##

Ill-formed 'for-of' loop.
At this point, if the expression denoting the index range is complete,
a closing parenthesis ')' is expected.

contract: For LPAR Let Ident Of Ident RPAR ZWSP
##
## Ends in an error in state: 548.
##
## for_of_stmt(statement) -> For LPAR Let Ident Of expr RPAR . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Let Ident Of expr RPAR
##
contract: If LPAR Ident RPAR For LPAR Let Ident Of Ident RPAR ZWSP
##
## Ends in an error in state: 639.
##
## for_of_stmt(closed_stmt) -> For LPAR Let Ident Of expr RPAR . closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Let Ident Of expr RPAR . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Let Ident Of expr RPAR
##
contract: Attr For LPAR Const Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 511.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const Ident Of expr RPAR . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const Ident Of expr RPAR
##
contract: If LPAR Bytes RPAR Attr For LPAR Const Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 606.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Const Ident Of expr RPAR . closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const Ident Of expr RPAR . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const Ident Of expr RPAR
##
contract: If LPAR Bytes RPAR For LPAR Const Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 645.
##
## for_of_stmt(closed_stmt) -> For LPAR Const Ident Of expr RPAR . closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Const Ident Of expr RPAR . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Const Ident Of expr RPAR
##
contract: If LPAR Bytes RPAR Attr For LPAR Let Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 600.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Let Ident Of expr RPAR . closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let Ident Of expr RPAR . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let Ident Of expr RPAR
##
contract: For LPAR Const Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 554.
##
## for_of_stmt(statement) -> For LPAR Const Ident Of expr RPAR . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Const Ident Of expr RPAR
##
contract: Attr For LPAR Let Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 505.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let Ident Of expr RPAR . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let Ident Of expr RPAR
##

Ill-formed 'for-of' loop.
At this point, the body of the loop is expected as a statement.

contract: If LPAR Bytes RPAR Attr For LPAR Const Ident Of ZWSP
##
## Ends in an error in state: 604.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Const Ident Of . expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const Ident Of . expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const Ident Of
##
contract: For LPAR Let Ident Of ZWSP
##
## Ends in an error in state: 546.
##
## for_of_stmt(statement) -> For LPAR Let Ident Of . expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Let Ident Of
##
contract: If LPAR Ident RPAR For LPAR Let Ident Of ZWSP
##
## Ends in an error in state: 637.
##
## for_of_stmt(closed_stmt) -> For LPAR Let Ident Of . expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Let Ident Of . expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Let Ident Of
##
contract: Attr For LPAR Const Ident Of ZWSP
##
## Ends in an error in state: 509.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const Ident Of . expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const Ident Of
##
contract: If LPAR Bytes RPAR For LPAR Const Ident Of ZWSP
##
## Ends in an error in state: 643.
##
## for_of_stmt(closed_stmt) -> For LPAR Const Ident Of . expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Const Ident Of . expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Const Ident Of
##
contract: If LPAR Bytes RPAR Attr For LPAR Let Ident Of ZWSP
##
## Ends in an error in state: 598.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Let Ident Of . expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let Ident Of . expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let Ident Of
##
contract: Attr For LPAR Let Ident Of ZWSP
##
## Ends in an error in state: 503.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let Ident Of . expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let Ident Of
##

Ill-formed 'for-of' loop.
At this point, the range of the index is expected as an expression.

contract: If LPAR Bytes RPAR Attr For LPAR Const Ident ZWSP
##
## Ends in an error in state: 603.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Const Ident . Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const Ident . Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## var_pattern -> Ident . [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const Ident
##
contract: For LPAR Let Ident ZWSP
##
## Ends in an error in state: 545.
##
## for_of_stmt(statement) -> For LPAR Let Ident . Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## var_pattern -> Ident . [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## For LPAR Let Ident
##
contract: If LPAR Ident RPAR For LPAR Let Ident ZWSP
##
## Ends in an error in state: 636.
##
## for_of_stmt(closed_stmt) -> For LPAR Let Ident . Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Let Ident . Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## var_pattern -> Ident . [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## For LPAR Let Ident
##
contract: Attr For LPAR Const Ident ZWSP
##
## Ends in an error in state: 508.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const Ident . Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## var_pattern -> Ident . [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const Ident
##
contract: If LPAR Bytes RPAR For LPAR Const Ident ZWSP
##
## Ends in an error in state: 642.
##
## for_of_stmt(closed_stmt) -> For LPAR Const Ident . Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Const Ident . Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## var_pattern -> Ident . [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## For LPAR Const Ident
##
contract: If LPAR Bytes RPAR Attr For LPAR Let Ident ZWSP
##
## Ends in an error in state: 597.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Let Ident . Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let Ident . Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## var_pattern -> Ident . [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let Ident
##
contract: For LPAR Const Ident Of ZWSP
##
## Ends in an error in state: 552.
##
## for_of_stmt(statement) -> For LPAR Const Ident Of . expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Const Ident Of
##
contract: For LPAR Const Ident ZWSP
##
## Ends in an error in state: 551.
##
## for_of_stmt(statement) -> For LPAR Const Ident . Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## var_pattern -> Ident . [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## For LPAR Const Ident
##
contract: Attr For LPAR Let Ident ZWSP
##
## Ends in an error in state: 502.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let Ident . Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## var_pattern -> Ident . [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let Ident
##

Ill-formed 'for-of' loop.
At this point, the keyword 'of' is expected, followed by the index
range as an expression.

contract: For LPAR Let ZWSP
##
## Ends in an error in state: 544.
##
## for_of_stmt(statement) -> For LPAR Let . Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## let_decl -> Let . binding_list [ SEMI ]
##
## The known suffix of the stack is as follows:
## For LPAR Let
##
contract: If LPAR Ident RPAR For LPAR Let ZWSP
##
## Ends in an error in state: 635.
##
## for_of_stmt(closed_stmt) -> For LPAR Let . Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Let . Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## let_decl -> Let . binding_list [ SEMI ]
##
## The known suffix of the stack is as follows:
## For LPAR Let
##
contract: Attr For LPAR Const ZWSP
##
## Ends in an error in state: 507.
##
## const_decl -> Const . binding_list [ SEMI ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const . Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const
##
contract: If LPAR Bytes RPAR Attr For LPAR Const ZWSP
##
## Ends in an error in state: 602.
##
## const_decl -> Const . binding_list [ SEMI ]
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Const . Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Const . Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Const
##
contract: If LPAR Bytes RPAR For LPAR Const ZWSP
##
## Ends in an error in state: 641.
##
## const_decl -> Const . binding_list [ SEMI ]
## for_of_stmt(closed_stmt) -> For LPAR Const . Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR Const . Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Const
##
contract: If LPAR Bytes RPAR Attr For LPAR Let ZWSP
##
## Ends in an error in state: 596.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR Let . Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let . Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## let_decl -> Let . binding_list [ SEMI ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let
##
contract: For LPAR Const ZWSP
##
## Ends in an error in state: 550.
##
## const_decl -> Const . binding_list [ SEMI ]
## for_of_stmt(statement) -> For LPAR Const . Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR Const
##
contract: Attr For LPAR Let ZWSP
##
## Ends in an error in state: 501.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR Let . Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## let_decl -> Let . binding_list [ SEMI ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR Let
##

Ill-formed 'for-of' loop.
At this point, the index is expected as a variable.

contract: For LPAR ZWSP
##
## Ends in an error in state: 430.
##
## for_of_stmt(statement) -> For LPAR . Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> For LPAR . Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR
##
contract: If LPAR Ident RPAR For LPAR ZWSP
##
## Ends in an error in state: 406.
##
## for_of_stmt(closed_stmt) -> For LPAR . Const Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(closed_stmt) -> For LPAR . Let Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For LPAR . Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> For LPAR . Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(closed_stmt) -> For LPAR . SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR . SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR . SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR . SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR . for_initialiser SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR . for_initialiser SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR . for_initialiser SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR . for_initialiser SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR . SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR
##
contract: Attr For LPAR ZWSP
##
## Ends in an error in state: 438.
##
## for_of_stmt(statement) -> nseq(Attr) For LPAR . Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR . Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR
##
contract: If LPAR Bytes RPAR Attr For LPAR ZWSP
##
## Ends in an error in state: 573.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR . Const Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(closed_stmt) -> nseq(Attr) For LPAR . Let Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR . Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> nseq(Attr) For LPAR . Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR . for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR
##

Ill-formed bounded ("for-of") loop.
At this point, one of the following is expected:
  * the 'const' keyword,
  * the 'let' keyword;
followed by the index as a variable.

contract: For ZWSP
##
## Ends in an error in state: 429.
##
## for_of_stmt(statement) -> For . LPAR Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> For . LPAR Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For
##
contract: If LPAR Ident RPAR For ZWSP
##
## Ends in an error in state: 405.
##
## for_of_stmt(closed_stmt) -> For . LPAR Const Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(closed_stmt) -> For . LPAR Let Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> For . LPAR Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> For . LPAR Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(closed_stmt) -> For . LPAR SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For . LPAR SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For . LPAR SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For . LPAR SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For . LPAR for_initialiser SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For . LPAR for_initialiser SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For . LPAR for_initialiser SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For . LPAR for_initialiser SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For . LPAR SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For
##
contract: Attr For ZWSP
##
## Ends in an error in state: 437.
##
## for_of_stmt(statement) -> nseq(Attr) For . LPAR Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> nseq(Attr) For . LPAR Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For
##
contract: If LPAR Bytes RPAR Attr For ZWSP
##
## Ends in an error in state: 572.
##
## for_of_stmt(closed_stmt) -> nseq(Attr) For . LPAR Const Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(closed_stmt) -> nseq(Attr) For . LPAR Let Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) For . LPAR Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> nseq(Attr) For . LPAR Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For . LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For
##

Ill-formed bounded ("for-of") loop.
At this point, an opening parenthesis '(' is expected, followed by
either the keyword 'const' or 'let'.

contract: If LPAR Bytes SEMI
##
## Ends in an error in state: 396.
##
## par(if_cond) -> LPAR if_cond . RPAR [ While WILD Verbatim UIdent Type Switch String Return MINUS Let LPAR LBRACKET LBRACE Int Import If Ident INCR For Export DECR Contract Const Bytes BOOL_NOT Attr ]
##
## The known suffix of the stack is as follows:
## LPAR if_cond
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
## In state 398, spurious reduction of production if_cond -> expr
##

Ill-formed conditional statement.
At this point, if the condition is complete, a closing parenthesis ')'
is expected.

contract: If LPAR Ident RPAR If LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 403.
##
## if_else_stmt(closed_stmt) -> If par(if_cond) . closed_stmt Else closed_stmt [ Else ]
## if_else_stmt(statement) -> If par(if_cond) . closed_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_stmt -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##
contract: If LPAR Ident RPAR ZWSP
##
## Ends in an error in state: 399.
##
## if_else_stmt(statement) -> If par(if_cond) . closed_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_stmt -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##
contract: Attr If LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 428.
##
## if_stmt -> nseq(Attr) If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) If par(if_cond)
##

Ill-formed conditional statement.
At this point, the statement executed when the condition is true is
expected.

contract: If LPAR Ident RPAR If ZWSP
##
## Ends in an error in state: 402.
##
## if_else_stmt(closed_stmt) -> If . par(if_cond) closed_stmt Else closed_stmt [ Else ]
## if_else_stmt(statement) -> If . par(if_cond) closed_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_stmt -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## If
##
contract: If ZWSP
##
## Ends in an error in state: 394.
##
## if_else_stmt(statement) -> If . par(if_cond) closed_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_stmt -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## If
##
contract: Attr If ZWSP
##
## Ends in an error in state: 427.
##
## if_stmt -> nseq(Attr) If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) If
##

Ill-formed conditional statement.
At this point, the condition is expected as an expression between
parentheses.

contract: If LPAR ZWSP
##
## Ends in an error in state: 395.
##
## par(if_cond) -> LPAR . if_cond RPAR [ While WILD Verbatim UIdent Type Switch String Return MINUS Let LPAR LBRACKET LBRACE Int Import If Ident INCR For Export DECR Contract Const Bytes BOOL_NOT Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed conditional statement.
At this point, the condition is expected as an expression.

contract: Import UIdent EQ UIdent DOT ZWSP
##
## Ends in an error in state: 60.
##
## nsepseq(module_name,DOT) -> UIdent DOT . nsepseq(module_name,DOT) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##
contract: Import UIdent EQ ZWSP
##
## Ends in an error in state: 378.
##
## import_stmt -> Import UIdent EQ . nsepseq(module_name,DOT) [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import UIdent EQ
##

Ill-formed module aliasing.
At this point, the qualified name of the aliased module is expected.

contract: Import ZWSP
##
## Ends in an error in state: 376.
##
## import_stmt -> Import . UIdent EQ nsepseq(module_name,DOT) [ SEMI RBRACE Else EOF Default Case ]
## import_stmt -> Import . TIMES As UIdent From String [ SEMI RBRACE Else EOF Default Case ]
## import_stmt -> Import . braces(nsepseq(field_name,COMMA)) From String [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import
##

Ill-formed module aliasing.
At this point, the alias is expected as a module name.

contract: Import UIdent ZWSP
##
## Ends in an error in state: 377.
##
## import_stmt -> Import UIdent . EQ nsepseq(module_name,DOT) [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import UIdent
##

Ill-formed module aliasing.
At this point, the assignment symbol '=' is expected, followed by the
qualified name of the aliased module

contract: LBRACE Ident SEMI ZWSP
##
## Ends in an error in state: 709.
##
## nsepseq(property,object_sep) -> property object_sep . nsepseq(property,object_sep) [ RBRACE ]
## nseq(__anonymous_0(property,object_sep)) -> property object_sep . [ RBRACE ]
## nseq(__anonymous_0(property,object_sep)) -> property object_sep . nseq(__anonymous_0(property,object_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property object_sep
##

Ill-formed block of statements.
At this point, one of the following is expected:
  * another statement;
  * a closing brace '}' if the block is complete.

contract: Switch LPAR Ident RPAR LBRACE Case ZWSP
##
## Ends in an error in state: 681.
##
## case -> Case . expr COLON [ RBRACE Default Case ]
## case -> Case . expr COLON case_statements [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## Case
##

Ill-formed switch statement.
At this point, an expression is expected, whose value is used to
select the case to be executed first.

contract: Switch LPAR Bytes SEMI
##
## Ends in an error in state: 315.
##
## par(switch_cond) -> LPAR switch_cond . RPAR [ LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAR switch_cond
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
## In state 317, spurious reduction of production switch_cond -> expr
##

Ill-formed switch statement.
At this point, if the expression is complete, a closing parenthesis
')' is expected.

contract: Switch LPAR Ident RPAR LBRACE Case Ident COLON ZWSP
##
## Ends in an error in state: 683.
##
## case -> Case expr COLON . [ RBRACE Default Case ]
## case -> Case expr COLON . case_statements [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## Case expr COLON
##

Ill-formed switch statement.
At this point, one of the following is expected:
  * case statements separated by semicolons ';';
  * a new case starting with the keyword 'case';
  * the default case starting with the keyword 'default';
  * a `break` to terminate the current switch;
  * a closing brace '}' if the switch is complete.

contract: Switch LPAR Ident RPAR LBRACE Default COLON ZWSP
##
## Ends in an error in state: 321.
##
## default_case -> Default COLON . [ RBRACE ]
## default_case -> Default COLON . case_statements [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default COLON
##

Ill-formed switch statement.
At this point, one of the following is expected:
  * case statements separated by semicolons ';';
  * a `break` to terminate the current switch;
  * a closing brace '}' if the switch is complete.

contract: Switch LPAR Bytes RPAR LBRACE Case Bytes SEMI
##
## Ends in an error in state: 682.
##
## case -> Case expr . COLON [ RBRACE Default Case ]
## case -> Case expr . COLON case_statements [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##

Ill-formed switch statement.
At this point, if the case expression is complete, a colon ':' is
expected.

contract: Switch LPAR Ident RPAR LBRACE Default ZWSP
##
## Ends in an error in state: 320.
##
## default_case -> Default . COLON [ RBRACE ]
## default_case -> Default . COLON case_statements [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default
##

Ill-formed switch statement.
At this point, a colon ':' for the default case is expected.

contract: Switch LPAR Ident RPAR LBRACE ZWSP
##
## Ends in an error in state: 319.
##
## braces(cases) -> LBRACE . cases RBRACE [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed switch statement.
At this point, a case starting with the keyword 'case' is expected.

contract: Switch LPAR Ident RPAR ZWSP
##
## Ends in an error in state: 318.
##
## switch_stmt -> Switch par(switch_cond) . braces(cases) [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Switch par(switch_cond)
##

Ill-formed switch statement.
At this point, cases are expected between braces '{' '}'.

contract: Switch ZWSP
##
## Ends in an error in state: 190.
##
## switch_stmt -> Switch . par(switch_cond) braces(cases) [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Switch
##

Ill-formed switch statement.
At this point, an expression between parentheses is expected.

contract: Switch LPAR ZWSP
##
## Ends in an error in state: 191.
##
## par(switch_cond) -> LPAR . switch_cond RPAR [ LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed switch statement.
At this point, the expression evaluated against the cases is expected.

contract: Switch LPAR Bytes RPAR LBRACE Default COLON Return While
##
## Ends in an error in state: 677.
##
## nsepseq(case_statement,SEMI) -> case_statement . [ RBRACE Default Case ]
## nsepseq(case_statement,SEMI) -> case_statement . SEMI nsepseq(case_statement,SEMI) [ RBRACE Default Case ]
## nseq(__anonymous_0(case_statement,SEMI)) -> case_statement . SEMI [ RBRACE Default Case ]
## nseq(__anonymous_0(case_statement,SEMI)) -> case_statement . SEMI nseq(__anonymous_0(case_statement,SEMI)) [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## case_statement
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 322, spurious reduction of production return_stmt -> Return
## In state 435, spurious reduction of production base_stmt(statement) -> return_stmt
## In state 476, spurious reduction of production statement -> base_stmt(statement)
## In state 672, spurious reduction of production case_statement -> statement
##

Ill-formed switch statement.
At this point, if the case statement is complete, one of the following
is expected:
  * a semicolon ';' followed by another case statement;
  * a new case starting with the keyword 'case';
  * the default case starting with the keyword 'default';
  * a closing brace '}' if the switch is complete.

contract: LBRACE ZWSP
##
## Ends in an error in state: 39.
##
## braces(__anonymous_3) -> LBRACE . sep_or_term_list(property,object_sep) RBRACE [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
## braces(statements) -> LBRACE . statements RBRACE [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed block of statements.
At this point, the first statement is expected.

contract: LBRACKET ELLIPSIS ZWSP
##
## Ends in an error in state: 741.
##
## array_item -> ELLIPSIS . expr [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed tuple inclusion.
At this point, an expression denoting the included tuple is expected.

contract: LBRACKET Ident COLON
##
## Ends in an error in state: 746.
##
## nsepseq(array_item,COMMA) -> array_item . [ RBRACKET ]
## nsepseq(array_item,COMMA) -> array_item . COMMA nsepseq(array_item,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## array_item
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 30, spurious reduction of production member_expr -> Ident
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
## In state 745, spurious reduction of production array_item -> expr
##

Ill-formed tuple expression.
At this point, if the component is complete, one of the following is
expected:
  * a comma ',' followed by another component;
  * a closing bracket ']' if the tuple is complete.

contract: LPAR ZWSP
##
## Ends in an error in state: 10.
##
## par(expr) -> LPAR . expr RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed  parenthesised expression.
At this point, an expression is expected.

contract: Let LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 363.
##
## braces(property_patterns) -> LBRACE property_patterns . RBRACE [ EQ COLON ]
## property_patterns -> property_patterns . object_sep property_pattern [ SEMI RBRACE COMMA ]
## property_patterns -> property_patterns . object_sep object_rest_pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACE property_patterns
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a comma ',' or semicolon ';' followed by another field pattern;
  * a comma ',' or semicolon followed by an ellipsis '...' and a
    variable matching the rest of the record;
  * a closing brace '}' if the record pattern is complete.

contract: Let LBRACE Ident COMMA ELLIPSIS ZWSP
##
## Ends in an error in state: 366.
##
## object_rest_pattern -> ELLIPSIS . Ident [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed record pattern.
At this point, a variable is expected to match the remaining record.

contract: Let LBRACE Ident COLON ZWSP
##
## Ends in an error in state: 346.
##
## property_pattern -> Ident COLON . binding_initializer [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Ident COLON
##

Ill-formed record field pattern.
At this point, one of the following is expected:
  * optional attributes followed by a variable;
  * a catch-all '_' pattern;
  * a record pattern;
  * a tuple pattern.

contract: Let LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 365.
##
## property_patterns -> property_patterns object_sep . property_pattern [ SEMI RBRACE COMMA ]
## property_patterns -> property_patterns object_sep . object_rest_pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_patterns object_sep
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * another field pattern;
  * a pattern matching the rest of the record, starting with an
    ellipsis '...'.

contract: Let LBRACE Ident EQ ZWSP
##
## Ends in an error in state: 344.
##
## property_pattern -> Ident EQ . expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record pattern.
At this point, the default value for the field is expected as an
expression.

contract: Let LBRACE Ident ZWSP
##
## Ends in an error in state: 343.
##
## property_pattern -> Ident . EQ expr [ SEMI RBRACE COMMA ]
## property_pattern -> Ident . COLON binding_initializer [ SEMI RBRACE COMMA ]
## var_pattern -> Ident . [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by a default value as an
    expression;
  * a colon ':' followed by a pattern for the right-hand side of the
    field;
  * a comma ',' or semicolon ';' followed by another field pattern;
  * a closing brace '}' if the record pattern is complete.

contract: Let LBRACE ZWSP
##
## Ends in an error in state: 342.
##
## braces(property_patterns) -> LBRACE . property_patterns RBRACE [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record pattern.
At this point, field patterns are expected to be separated by commas
',' or semicolons ';'.

contract: Let LBRACKET WILD COLON
##
## Ends in an error in state: 334.
##
## array_item_patterns -> array_item_patterns . COMMA array_item_pattern [ RBRACKET COMMA ]
## array_item_patterns -> array_item_patterns . COMMA array_rest_pattern [ RBRACKET COMMA ]
## brackets(array_item_patterns) -> LBRACKET array_item_patterns . RBRACKET [ RBRACKET EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET array_item_patterns
##

Ill-formed tuple pattern.
At this point, one of the following is expected:
  * a comma ',' followed by another tuple component as a pattern;
  * a comma ',' followed by a pattern matching the rest of the tuple,
    starting with an ellipsis '...';
  * a closing bracket ']' if the tuple pattern is complete.

contract: Let LBRACKET WILD COMMA ZWSP
##
## Ends in an error in state: 336.
##
## array_item_patterns -> array_item_patterns COMMA . array_item_pattern [ RBRACKET COMMA ]
## array_item_patterns -> array_item_patterns COMMA . array_rest_pattern [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## array_item_patterns COMMA
##

Ill-formed tuple pattern.
At this point, one of the following is expected:
  * another component as a pattern;
  * a pattern matching the rest of the tuple, starting with an
    ellipsis '...'.

contract: Let LBRACKET WILD COMMA ELLIPSIS ZWSP
##
## Ends in an error in state: 337.
##
## array_rest_pattern -> ELLIPSIS . Ident [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed pattern for the rest of a tuple.
At this point, a variable is expected to match the rest of the tuple.

contract: Let LBRACKET ZWSP
##
## Ends in an error in state: 326.
##
## brackets(array_item_patterns) -> LBRACKET . array_item_patterns RBRACKET [ RBRACKET EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed tuple pattern.
At this point, a tuple component is expected as a pattern.

contract: Let WILD COLON Ident EQ ZWSP
##
## Ends in an error in state: 358.
##
## binding_initializer -> binding_pattern binding_type EQ . expr [ SEMI RBRACE Else EOF Default Case COMMA ]
##
## The known suffix of the stack is as follows:
## binding_pattern binding_type EQ
##

Ill-formed value declaration.
At this point, an expression is expected.

contract: Let WILD COLON Ident ZWSP
##
## Ends in an error in state: 357.
##
## binding_initializer -> binding_pattern binding_type . EQ expr [ SEMI RBRACE Else EOF Default Case COMMA ]
##
## The known suffix of the stack is as follows:
## binding_pattern binding_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 356, spurious reduction of production binding_type -> COLON type_expr
##

Ill-formed value declaration.
At this point, if the type annotation is complete, the assignment
symbol '=' is expected, followed by an expression.

contract: Let WILD COLON ZWSP
##
## Ends in an error in state: 353.
##
## binding_type -> COLON . type_expr [ EQ ]
## binding_type -> COLON . type_parameters type_expr [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.

contract: Let WILD ZWSP
##
## Ends in an error in state: 350.
##
## binding_initializer -> binding_pattern . EQ expr [ SEMI RBRACE Else EOF Default Case COMMA ]
## binding_initializer -> binding_pattern . binding_type EQ expr [ SEMI RBRACE Else EOF Default Case COMMA ]
##
## The known suffix of the stack is as follows:
## binding_pattern
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

contract: MINUS LPAR LBRACE Ident RBRACE ZWSP
##
## Ends in an error in state: 749.
##
## par(expr) -> LPAR expr . RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##

Ill-formed parenthesised type expression.
At this point, a closing parenthesis ')' is expected.

contract: Namespace UIdent LBRACE ZWSP
##
## Ends in an error in state: 766.
##
## braces(stmts_or_namespace) -> LBRACE . stmts_or_namespace RBRACE [ SEMI RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed module declaration.
At this point, the first statement or submodule is expected.

contract: Namespace UIdent ZWSP
##
## Ends in an error in state: 765.
##
## namespace -> Namespace UIdent . braces(stmts_or_namespace) [ SEMI RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## Namespace UIdent
##

Ill-formed module declaration.
At this point, an opening brace '{' is expected, followed by
statements and/or submodules.

contract: Namespace ZWSP
##
## Ends in an error in state: 764.
##
## namespace -> Namespace . UIdent braces(stmts_or_namespace) [ SEMI RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## Namespace
##

Ill-formed module declaration.
At this point, the name of the module is expected, starting with a
capital letter.

contract: Type UIdent EQ ZWSP
##
## Ends in an error in state: 48.
##
## type_decl -> Type UIdent EQ . type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type UIdent EQ
##
contract: Type Ident EQ ZWSP
##
## Ends in an error in state: 185.
##
## type_decl -> Type Ident EQ . type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type Ident EQ
##
contract: Type UIdent LT Ident GT EQ ZWSP
##
## Ends in an error in state: 181.
##
## type_decl -> Type UIdent type_params EQ . type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type UIdent type_params EQ
##

Ill-formed type declaration.
At this point, a type expression is expected.

contract: UIdent LPAR Bytes SEMI
##
## Ends in an error in state: 757.
##
## nsepseq(ctor_arg,COMMA) -> ctor_arg . [ RPAR ]
## nsepseq(ctor_arg,COMMA) -> ctor_arg . COMMA nsepseq(ctor_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
## In state 755, spurious reduction of production ctor_arg -> expr
##

Ill-formed instantiation of a parametric type.
At this point, if the argument is complete, one of the following is
expected:
  * a comma ',' followed by another argument as an expression;
  * a closing parenthesis ')' if there are no more arguments.

contract: UIdent LPAR ZWSP
##
## Ends in an error in state: 7.
##
## ctor_expr -> UIdent LPAR . option(ctor_args) RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## UIdent LPAR
##

Ill-formed instantiation of a constructor.
At this point, one of the following is expected:
  * arguments as expressions separated by commas ',';
  * a closing parenthesis ')' if the constructor has no arguments.

contract: UIdent LPAR Ident COMMA ZWSP
##
## Ends in an error in state: 758.
##
## nsepseq(ctor_arg,COMMA) -> ctor_arg COMMA . nsepseq(ctor_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_arg COMMA
##

Ill-formed instantiation of a constructor.
At this point, an argument is expected as an expression.

contract: Type UIdent LT Ident GT ZWSP ZWSP
##
## Ends in an error in state: 180.
##
## type_decl -> Type UIdent type_params . EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type UIdent type_params
##

Ill-formed parametric type declaration.
At this point, an assignment symbol '=' is expected, followed by a
type expression.

contract: Type UIdent ZWSP
##
## Ends in an error in state: 47.
##
## type_decl -> Type UIdent . EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
## type_decl -> Type UIdent . type_params EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type UIdent
##
contract: Type Ident ZWSP
##
## Ends in an error in state: 184.
##
## type_decl -> Type Ident . EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
## type_decl -> Type Ident . type_params EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * an opening chevron '<' followed by type parameters, if defining a
    parametric type;
  * an assignment symbol '=' followed by a type expression, if the
    type is not parametric.

contract: Type ZWSP
##
## Ends in an error in state: 46.
##
## type_decl -> Type . Ident EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
## type_decl -> Type . Ident type_params EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
## type_decl -> Type . UIdent EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
## type_decl -> Type . UIdent type_params EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, the name of the type being defined is expected.

contract: UIdent DOT UIdent ZWSP
##
## Ends in an error in state: 42.
##
## module_access_e -> UIdent . DOT module_var_e [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a value in a module.
At this point, the selection symbol '.' is expected, followed by the
qualified name of a value.

contract: UIdent DOT ZWSP
##
## Ends in an error in state: 41.
##
## module_access_e -> UIdent DOT . module_var_e [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a value in a module.
At this point, the qualified name of a value is expected.

contract: Ident BOOL_AND ZWSP
##
## Ends in an error in state: 235.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK Else EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##
contract: Ident BOOL_OR ZWSP
##
## Ends in an error in state: 286.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK Else EOF Default Case COMMA COLON BOOL_OR ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##
contract: Ident EQ2 ZWSP
##
## Ends in an error in state: 265.
##
## bin_op(comp_expr_level,EQ2,add_expr_level) -> comp_expr_level EQ2 . add_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK NE LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ2
##
contract: Ident GT While
##
## Ends in an error in state: 267.
##
## bin_op(comp_expr_level,gt,add_expr_level) -> comp_expr_level gt . add_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK NE LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level gt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 262, spurious reduction of production gt -> GT
##
contract: Bytes GT ZWSP EQ ZWSP
##
## Ends in an error in state: 269.
##
## bin_op(comp_expr_level,ge,add_expr_level) -> comp_expr_level ge . add_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK NE LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level ge
##
contract: Ident LE ZWSP
##
## Ends in an error in state: 260.
##
## bin_op(comp_expr_level,LE,add_expr_level) -> comp_expr_level LE . add_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK NE LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
contract: Ident LT ZWSP
##
## Ends in an error in state: 258.
##
## bin_op(comp_expr_level,LT,add_expr_level) -> comp_expr_level LT . add_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK NE LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##
contract: Ident MINUS ZWSP
##
## Ends in an error in state: 256.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
contract: Ident NE ZWSP
##
## Ends in an error in state: 237.
##
## bin_op(comp_expr_level,NE,add_expr_level) -> comp_expr_level NE . add_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK NE LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##
contract: Ident PLUS ZWSP
##
## Ends in an error in state: 250.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ SEMI RPAR RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
contract: Ident REM ZWSP
##
## Ends in an error in state: 254.
##
## bin_op(mult_expr_level,REM,unary_expr_level) -> mult_expr_level REM . unary_expr_level [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level REM
##
contract: Ident SLASH ZWSP
##
## Ends in an error in state: 252.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
contract: Ident TIMES ZWSP
##
## Ends in an error in state: 215.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##
contract: BOOL_NOT ZWSP
##
## Ends in an error in state: 199.
##
## unary_expr_level -> BOOL_NOT . call_expr_level [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## BOOL_NOT
##
interactive_expr: ZWSP
##
## Ends in an error in state: 795.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##
contract: MINUS ZWSP
##
## Ends in an error in state: 9.
##
## unary_expr_level -> MINUS . call_expr_level [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Ill-formed expression.
At this point, an expression is expected.

contract: Let WILD EQ ZWSP
##
## Ends in an error in state: 351.
##
## binding_initializer -> binding_pattern EQ . expr [ SEMI RBRACE Else EOF Default Case COMMA ]
##
## The known suffix of the stack is as follows:
## binding_pattern EQ
##

Ill-formed value declaration.
At this point, the expression to bound is expected.

contract: Ident DOT ZWSP
##
## Ends in an error in state: 311.
##
## projection -> member_expr DOT . Ident [ TIMES SLASH SEMI RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS NE MULT_EQ MINUS_EQ MINUS LT LPAR LE LBRACKET GT Else EQ2 EQ EOF Default DOT DIV_EQ Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## member_expr DOT
##

Ill-formed selection in a record.
At this point, the name of a record field is expected.

contract: Bytes LBRACKET Bytes SEMI
##
## Ends in an error in state: 309.
##
## brackets(expr) -> LBRACKET expr . RBRACKET [ TIMES SLASH SEMI RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS NE MULT_EQ MINUS_EQ MINUS LT LPAR LE LBRACKET GT Else EQ2 EQ EOF Default DOT DIV_EQ Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## LBRACKET expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##

Ill-formed selection in a tuple.
At this point, a closing bracket ']' is expected.

contract: Ident LBRACKET ZWSP
##
## Ends in an error in state: 206.
##
## brackets(expr) -> LBRACKET . expr RBRACKET [ TIMES SLASH SEMI RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS NE MULT_EQ MINUS_EQ MINUS LT LPAR LE LBRACKET GT Else EQ2 EQ EOF Default DOT DIV_EQ Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed selection in a tuple.
At this point, the index of a component is expected, '0' denoting the
first component.

contract: Ident LPAR ZWSP
##
## Ends in an error in state: 218.
##
## par(ioption(nsepseq(fun_arg,COMMA))) -> LPAR . RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND As ]
## par(ioption(nsepseq(fun_arg,COMMA))) -> LPAR . nsepseq(fun_arg,COMMA) RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function call.
At this point, one of the following is expected:
  * an argument as an expression;
  * a closing parenthesis ')' if there are no arguments.

contract: Ident LPAR Ident COMMA ZWSP
##
## Ends in an error in state: 225.
##
## nsepseq(fun_arg,COMMA) -> fun_arg COMMA . nsepseq(fun_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## fun_arg COMMA
##

Ill-formed function call.
At this point, an argument is expected as an expression.

contract: Bytes LPAR Bytes SEMI
##
## Ends in an error in state: 224.
##
## nsepseq(fun_arg,COMMA) -> fun_arg . [ RPAR ]
## nsepseq(fun_arg,COMMA) -> fun_arg . COMMA nsepseq(fun_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## fun_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
## In state 227, spurious reduction of production fun_arg -> expr
##

Ill-formed function call.
At this point, one of the following is expected:
  * a comma ',' followed by an argument as an expression;
  * a closing parenthesis ')' if there are no more arguments.

contract: Return While
##
## Ends in an error in state: 788.
##
## toplevel_stmts -> stmt_or_namespace . SEMI toplevel_stmts [ EOF ]
## toplevel_stmts -> stmt_or_namespace . option(SEMI) [ EOF ]
##
## The known suffix of the stack is as follows:
## stmt_or_namespace
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 322, spurious reduction of production return_stmt -> Return
## In state 435, spurious reduction of production base_stmt(statement) -> return_stmt
## In state 476, spurious reduction of production statement -> base_stmt(statement)
## In state 773, spurious reduction of production stmt_or_namespace -> statement
##

Ill-formed top-level statement.
At this point, if the statement is complete, one of the following is
expected:
  * a semicolon ';' followed by another statement;
  * a semicolon ';' followed by the end of file;
  * the end of the file.

contract: While LPAR Ident RPAR ZWSP
##
## Ends in an error in state: 763.
##
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##
contract: If LPAR Ident RPAR While LPAR Ident RPAR ZWSP
##
## Ends in an error in state: 401.
##
## while_stmt(closed_stmt) -> While par(while_cond) . closed_stmt [ Else ]
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##

Ill-formed unbounded ("while") loop.
At this point, the body of the loop is expected as a statement.

contract: While LPAR Bytes SEMI
##
## Ends in an error in state: 760.
##
## par(while_cond) -> LPAR while_cond . RPAR [ While WILD Verbatim UIdent Type Switch String Return MINUS Let LPAR LBRACKET LBRACE Int Import If Ident INCR For Export DECR Contract Const Bytes BOOL_NOT Attr ]
##
## The known suffix of the stack is as follows:
## LPAR while_cond
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
## In state 762, spurious reduction of production while_cond -> expr
##

Ill-formed unbounded ("while") loop.
At this point, if the conditional expression is complete, a closing
parenthesis ')' is expected.

contract: While LPAR ZWSP
##
## Ends in an error in state: 2.
##
## par(while_cond) -> LPAR . while_cond RPAR [ While WILD Verbatim UIdent Type Switch String Return MINUS Let LPAR LBRACKET LBRACE Int Import If Ident INCR For Export DECR Contract Const Bytes BOOL_NOT Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed while loop.
At this point, a Boolean expression is expected.

contract: While ZWSP
##
## Ends in an error in state: 1.
##
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## While
##
contract: If LPAR Ident RPAR While ZWSP
##
## Ends in an error in state: 400.
##
## while_stmt(closed_stmt) -> While . par(while_cond) closed_stmt [ Else ]
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## While
##

Ill-formed unbounded ("while") loop.
At this point, a Boolean expression is expected between parentheses.

contract: ZWSP
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##
contract: Directive ZWSP
##
## Ends in an error in state: 786.
##
## toplevel_stmts -> Directive . [ EOF ]
## toplevel_stmts -> Directive . toplevel_stmts [ EOF ]
##
## The known suffix of the stack is as follows:
## Directive
##

Ill-formed contract.
At this point, a top-level statement is expected.

contract: Let Attr VBAR
##
## Ends in an error in state: 330.
##
## var_pattern -> nseq(Attr) . Ident [ SEMI RBRACKET RBRACE EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed attributed variable in a pattern.
At this point, if the attribute is complete, a variable is
expected.

contract: Attr VBAR
##
## Ends in an error in state: 775.
##
## base_stmt(statement) -> nseq(Attr) . expr_stmt [ SEMI RBRACE EOF ]
## export_decl -> nseq(Attr) . Export declaration [ SEMI RBRACE EOF ]
## export_decl -> nseq(Attr) . Export nseq(Attr) declaration [ SEMI RBRACE EOF ]
## for_of_stmt(statement) -> nseq(Attr) . For LPAR Const Ident Of expr RPAR statement [ SEMI RBRACE EOF ]
## for_of_stmt(statement) -> nseq(Attr) . For LPAR Let Ident Of expr RPAR statement [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI RPAR [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI RPAR statement [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF ]
## if_stmt -> nseq(Attr) . If par(if_cond) statement [ SEMI RBRACE EOF ]
## namespace_stmt -> nseq(Attr) . namespace [ SEMI RBRACE EOF ]
## namespace_stmt -> nseq(Attr) . Export namespace [ SEMI RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-defined statement.
At this point, one of the following is expected:
  * an assignment;
  * a function call;
  * a ternary test expression;
  * an expressions annotated with its type;
  * the keyword 'namespace';
  * the keyword 'for';
  * the keyword 'if';
  * the keyword 'export';
  * the keyword 'const';
  * the keyword 'let';
  * the keyword 'type'.

contract: LBRACE Return SEMI Attr ZWSP
##
## Ends in an error in state: 436.
##
## base_stmt(statement) -> nseq(Attr) . expr_stmt [ SEMI RBRACE EOF Default Case ]
## export_decl -> nseq(Attr) . Export declaration [ SEMI RBRACE EOF Default Case ]
## export_decl -> nseq(Attr) . Export nseq(Attr) declaration [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> nseq(Attr) . For LPAR Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> nseq(Attr) . For LPAR Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## if_stmt -> nseq(Attr) . If par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-defined statement.
At this point, one of the following is expected:
  * an assignment;
  * a function call;
  * a ternary test expression;
  * an expressions annotated with its type;
  * the keyword 'for';
  * the keyword 'if';
  * the keyword 'export';
  * the keyword 'const';
  * the keyword 'let';
  * the keyword 'type'.

contract: Ident EQ ZWSP
##
## Ends in an error in state: 468.
##
## assign_stmt -> assign_lhs EQ . expr [ SEMI RPAR RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## assign_lhs EQ
##

Ill-formed assignment.
At this point, the right-hand side is expected as an expression.

contract: LBRACKET ZWSP
##
## Ends in an error in state: 21.
##
## brackets(ioption(nsepseq(array_item,COMMA))) -> LBRACKET . RBRACKET [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
## brackets(ioption(nsepseq(array_item,COMMA))) -> LBRACKET . nsepseq(array_item,COMMA) RBRACKET [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##
contract: LBRACKET Ident COMMA ZWSP
##
## Ends in an error in state: 747.
##
## nsepseq(array_item,COMMA) -> array_item COMMA . nsepseq(array_item,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## array_item COMMA
##

Ill-formed tuple expression.
At this point, one of the following is expected:
  * a component as an expression;
  * an ellipsis '...' followed by an expression whose type is a tuple.

contract: Type Ident LT Ident GT ZWSP ZWSP
##
## Ends in an error in state: 187.
##
## type_decl -> Type Ident type_params . EQ type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type Ident type_params
##

Ill-formed parametric type declaration.
At this point, the assignment symbol '=' is expected, followed by a
type expression.

contract: Type Ident LT Ident GT EQ ZWSP
##
## Ends in an error in state: 188.
##
## type_decl -> Type Ident type_params EQ . type_expr [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Type Ident type_params EQ
##

Ill-formed parametric type declaration.
At this point, the right-hand side is expected as a type expression.

contract: Const Ident COLON LT ZWSP
##
## Ends in an error in state: 11.
##
## chevrons(nsepseq(type_param,COMMA)) -> LT . nsepseq(type_param,COMMA) GT [ WILD VBAR UIdent String Parameter LPAR LBRACKET LBRACE Int Ident ES6FUN EQ Attr ]
## chevrons(nsepseq(type_param,COMMA)) -> LT . nsepseq(type_param,COMMA) GT ZWSP [ WILD VBAR UIdent String Parameter LPAR LBRACKET LBRACE Int Ident ES6FUN EQ Attr ]
##
## The known suffix of the stack is as follows:
## LT
##
contract: Const Ident COLON LT UIdent COMMA ZWSP
##
## Ends in an error in state: 13.
##
## nsepseq(type_param,COMMA) -> UIdent COMMA . nsepseq(type_param,COMMA) [ GT ]
##
## The known suffix of the stack is as follows:
## UIdent COMMA
##
contract: Const Ident COLON LT Ident COMMA ZWSP
##
## Ends in an error in state: 15.
##
## nsepseq(type_param,COMMA) -> Ident COMMA . nsepseq(type_param,COMMA) [ GT ]
##
## The known suffix of the stack is as follows:
## Ident COMMA
##

Ill-formed generic type declaration.
At this point, a type parameter is expected.

contract: Const Ident COLON LT UIdent ZWSP
##
## Ends in an error in state: 12.
##
## nsepseq(type_param,COMMA) -> UIdent . [ GT ]
## nsepseq(type_param,COMMA) -> UIdent . COMMA nsepseq(type_param,COMMA) [ GT ]
##
## The known suffix of the stack is as follows:
## UIdent
##
contract: Const Ident COLON LT Ident ZWSP
##
## Ends in an error in state: 14.
##
## nsepseq(type_param,COMMA) -> Ident . [ GT ]
## nsepseq(type_param,COMMA) -> Ident . COMMA nsepseq(type_param,COMMA) [ GT ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed generic type declaration.
At this point, one of the following is expected:
 * a closing chevron '>' if the type is complete.
 * a comma, followed by another type parameter.

contract: Const Ident COLON LT UIdent GT ZWSP ZWSP
##
## Ends in an error in state: 354.
##
## binding_type -> COLON type_parameters . type_expr [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON type_parameters
##

Ill-formed type annotation.
At this point, if the type type parameters are complete, a type expression is expected.

contract: Bytes QMARK ZWSP
##
## Ends in an error in state: 453.
##
## ternary_expr(non_decl_expr_stmt(expr_stmt)) -> disj_expr_level QMARK . non_decl_expr_stmt(expr_stmt) COLON non_decl_expr_stmt(expr_stmt) [ SEMI RBRACE Else EOF Default Case COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK
##
contract: For LPAR SEMI SEMI Ident QMARK ZWSP
##
## Ends in an error in state: 484.
##
## ternary_expr(non_decl_expr_stmt(closed_non_decl_expr_stmt)) -> disj_expr_level QMARK . non_decl_expr_stmt(closed_non_decl_expr_stmt) COLON non_decl_expr_stmt(closed_non_decl_expr_stmt) [ RPAR COMMA COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK
##
interactive_expr: Bytes QMARK ZWSP
##
## Ends in an error in state: 229.
##
## ternary_expr(expr) -> disj_expr_level QMARK . expr COLON expr [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK
##

Ill-formed ternary conditional expression.
At this point, an expression for the truthy alternative is expected.

contract: Import TIMES ZWSP
##
## Ends in an error in state: 380.
##
## import_stmt -> Import TIMES . As UIdent From String [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import TIMES
##

Ill-formed import statement.
At this point, the keyword 'from' is expected.

contract: Import TIMES As ZWSP
##
## Ends in an error in state: 381.
##
## import_stmt -> Import TIMES As . UIdent From String [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import TIMES As
##

Ill-formed import statement.
At this point, the name of the module alias is expected, starting with a
capital letter.

contract: Import TIMES As UIdent ZWSP
##
## Ends in an error in state: 382.
##
## import_stmt -> Import TIMES As UIdent . From String [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import TIMES As UIdent
##
contract: Import LBRACE Ident RBRACE ZWSP
##
## Ends in an error in state: 391.
##
## import_stmt -> Import braces(nsepseq(field_name,COMMA)) . From String [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import braces(nsepseq(field_name,COMMA))
##

Ill-formed import statement.
At this point, the keyword 'from' is expected.

contract: Import TIMES As UIdent From ZWSP
##
## Ends in an error in state: 383.
##
## import_stmt -> Import TIMES As UIdent From . String [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import TIMES As UIdent From
##
contract: Import LBRACE Ident RBRACE From ZWSP
##
## Ends in an error in state: 392.
##
## import_stmt -> Import braces(nsepseq(field_name,COMMA)) From . String [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Import braces(nsepseq(field_name,COMMA)) From
##

Ill-formed import statement.
At this point, a path to another file is expected as a string.

contract: Import LBRACE ZWSP
##
## Ends in an error in state: 385.
##
## braces(nsepseq(field_name,COMMA)) -> LBRACE . nsepseq(field_name,COMMA) RBRACE [ From ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
contract: Import LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 387.
##
## nsepseq(field_name,COMMA) -> Ident COMMA . nsepseq(field_name,COMMA) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident COMMA
##

Ill-formed import statement.
At this point, a value of a module is expected.

contract: Import LBRACE Ident ZWSP
##
## Ends in an error in state: 389.
##
## braces(nsepseq(field_name,COMMA)) -> LBRACE nsepseq(field_name,COMMA) . RBRACE [ From ]
##
## The known suffix of the stack is as follows:
## LBRACE nsepseq(field_name,COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 386, spurious reduction of production nsepseq(field_name,COMMA) -> Ident
##

Ill-formed import statement.
At this point, if all the values are complete, a closing brace '}' is expected.

contract: If LPAR Bytes RPAR Attr ZWSP
##
## Ends in an error in state: 426.
##
## base_stmt(closed_stmt) -> nseq(Attr) . expr_stmt [ Else ]
## base_stmt(statement) -> nseq(Attr) . expr_stmt [ SEMI RBRACE EOF Default Case ]
## export_decl -> nseq(Attr) . Export declaration [ SEMI RBRACE Else EOF Default Case ]
## export_decl -> nseq(Attr) . Export nseq(Attr) declaration [ SEMI RBRACE Else EOF Default Case ]
## for_of_stmt(closed_stmt) -> nseq(Attr) . For LPAR Const Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(closed_stmt) -> nseq(Attr) . For LPAR Let Ident Of expr RPAR closed_stmt [ Else ]
## for_of_stmt(statement) -> nseq(Attr) . For LPAR Const Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(statement) -> nseq(Attr) . For LPAR Let Ident Of expr RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## if_stmt -> nseq(Attr) . If par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed export declaration.
At this point, one of the following is expected:
  * a value declaration starting with the keyword 'const' or 'let';
  * a type declaration starting with the keyword 'type';
  * an export statement starting with the keyword 'export'.

interactive_expr: ES6FUN ZWSP
##
## Ends in an error in state: 36.
##
## fun_expr -> ES6FUN . par(parameters) ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> ES6FUN . par(parameters) type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> ES6FUN . LPAR RPAR ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> ES6FUN . LPAR RPAR type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> ES6FUN . Ident ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> ES6FUN . WILD ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN
##

Ill-formed function expression.
At this point, one of the following is expected:
  * a opening parenthesis, followed by parameters, if any;
  * a single parameter.

contract: LBRACE UIdent ZWSP
##
## Ends in an error in state: 40.
##
## code_inj -> UIdent . Verbatim [ TIMES SLASH REM QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT EQ2 DOT BOOL_OR BOOL_AND As ]
## ctor_expr -> UIdent . LPAR option(ctor_args) RPAR [ TIMES SLASH REM QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT EQ2 DOT BOOL_OR BOOL_AND As ]
## module_access_e -> UIdent . DOT module_var_e [ TIMES SLASH REM QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT EQ2 DOT BOOL_OR BOOL_AND As ]
## property_name -> UIdent . [ COLON ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed code injection, module access, or constructor.
At this point, one of the following is expected:
  * a verbatim string if defining code injection;
  * the selection symbol '.' followed by the qualified name of a value
    in a module;
  * an opening parenthesis '(' followed by a constructor argument as
    an expression;
  * a colon ':' if defining a property.

contract: UIdent ZWSP
##
## Ends in an error in state: 5.
##
## code_inj -> UIdent . Verbatim [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
## ctor_expr -> UIdent . LPAR option(ctor_args) RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
## module_access_e -> UIdent . DOT module_var_e [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE LBRACKET GT Else EQ2 EOF Default DOT Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed code injection, module access, or constructor.
At this point, one of the following is expected:
  * a verbatim string if defining code injection;
  * the selection symbol '.' followed by the qualified name of a value
    in a module;
  * an opening parenthesis '(' followed by a constructor argument as
    an expression.

interactive_expr: Bytes As VBAR ZWSP
##
## Ends in an error in state: 50.
##
## sum_type -> VBAR . nsepseq(variant,VBAR) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## union_type -> VBAR . nsepseq(object_type,VBAR) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant or union type.
At this point, one of the following is expected:
  * attributes for the variant or object type;
  * an opening bracket '[' followed by a data constructor as a string;
  * an opening brace '{' if defining a union type (object type).

interactive_expr: Bytes As VBAR LBRACKET ZWSP
##
## Ends in an error in state: 51.
##
## brackets(variant_comp) -> LBRACKET . String RBRACKET [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## brackets(variant_comp) -> LBRACKET . String COMMA ctor_params RBRACKET [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed variant of a sum type.
At this point, a data constructor is expected as a string, starting
with a capital letter.

interactive_expr: Bytes As VBAR LBRACKET String ZWSP
##
## Ends in an error in state: 52.
##
## brackets(variant_comp) -> LBRACKET String . RBRACKET [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## brackets(variant_comp) -> LBRACKET String . COMMA ctor_params RBRACKET [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET String
##

Ill-formed variant of a sum type.
At this point, one of the following is expected:
  * a comma ',' followed by a constructor parameter as a type
    expression;
  * a closing bracket ']' if the constructor is constant.

interactive_expr: Bytes As VBAR LBRACKET String COMMA ZWSP
##
## Ends in an error in state: 54.
##
## brackets(variant_comp) -> LBRACKET String COMMA . ctor_params RBRACKET [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET String COMMA
##

Ill-formed variant of a sum type.
At this point, a constructor parameter is expected as a type
expression.

interactive_expr: Bytes As Ident LT ZWSP
##
## Ends in an error in state: 56.
##
## chevrons(type_ctor_args) -> LT . type_ctor_args GT [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## chevrons(type_ctor_args) -> LT . type_ctor_args GT ZWSP [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LT
##

Ill-formed instantiation of a parametric type.
At this point, a type argument is expected as a type expression.

interactive_expr: Bytes As LPAR ZWSP
##
## Ends in an error in state: 63.
##
## par(type_expr) -> LPAR . type_expr RPAR [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function parameter or parenthesised expression.
At this point, one of the following is expected:
  * a parameter if defining a functional type;
  * a type expression if writing a parenthesised type.

interactive_expr: Bytes As LBRACKET ZWSP
##
## Ends in an error in state: 64.
##
## brackets(type_components) -> LBRACKET . type_components RBRACKET [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## brackets(variant_comp) -> LBRACKET . String RBRACKET [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## brackets(variant_comp) -> LBRACKET . String COMMA ctor_params RBRACKET [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed type tuple.
At this point, a component is expected as a type expression.

interactive_expr: Bytes As LBRACE ZWSP
##
## Ends in an error in state: 75.
##
## object_type -> LBRACE . sep_or_term_list(field_decl,object_sep) RBRACE [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: Bytes As Attr LBRACE ZWSP
##
## Ends in an error in state: 109.
##
## object_type -> nseq(Attr) LBRACE . sep_or_term_list(field_decl,object_sep) RBRACE [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) LBRACE
##

Ill-formed record type.
At this point, a field declaration is expected.

interactive_expr: Bytes As LBRACE Ident ZWSP
##
## Ends in an error in state: 76.
##
## field_decl -> Ident . [ SEMI RBRACE COMMA ]
## field_decl -> Ident . type_annotation [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Ident
##
interactive_expr: Bytes As LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 114.
##
## field_decl -> nseq(Attr) Ident . [ SEMI RBRACE COMMA ]
## field_decl -> nseq(Attr) Ident . type_annotation [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident
##

Ill-formed record type.
At this point, one of the following is expected:
  * a comma ',' or semicolon ';' followed by another field declaration;
  * a colon ':' followed by a type expression;
  * a closing brace '}' if the record type is complete.

interactive_expr: Bytes As LBRACE Attr ZWSP
##
## Ends in an error in state: 113.
##
## field_decl -> nseq(Attr) . Ident [ SEMI RBRACE COMMA ]
## field_decl -> nseq(Attr) . Ident type_annotation [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record type.
At this point, if the attribute is complete, a field name is expected.

interactive_expr: ES6FUN LPAR Bytes COLON ZWSP
##
## Ends in an error in state: 77.
##
## type_annotation -> COLON . type_expr [ SEMI RPAR RBRACE COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.

interactive_expr: Bytes As ES6FUN ZWSP
##
## Ends in an error in state: 80.
##
## fun_type -> ES6FUN . par(nsepseq(fun_param,COMMA)) ARROW type_expr [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ES6FUN
##

Ill-formed functional type expression.
At this point, an opening parenthesis '(' followed by parameters are
expected.

interactive_expr: Bytes As ES6FUN LPAR ZWSP
##
## Ends in an error in state: 81.
##
## par(nsepseq(fun_param,COMMA)) -> LPAR . nsepseq(fun_param,COMMA) RPAR [ ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function parameter.
At this point, a parameter is expected.

interactive_expr: Bytes As ES6FUN LPAR Ident ZWSP
##
## Ends in an error in state: 82.
##
## fun_param -> Ident . type_annotation [ RPAR COMMA ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed function parameter type.
At this point, a colon ':' is expected, followed by a type expression.

interactive_expr: Bytes As ES6FUN LPAR Ident COLON Ident While
##
## Ends in an error in state: 86.
##
## nsepseq(fun_param,COMMA) -> fun_param . [ RPAR ]
## nsepseq(fun_param,COMMA) -> fun_param . COMMA nsepseq(fun_param,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## fun_param
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 134, spurious reduction of production type_annotation -> COLON type_expr
## In state 83, spurious reduction of production fun_param -> Ident type_annotation
##

Ill-formed functional type.
At this point, if the parameter type is complete, one of the following
is expected:
  * a comma ',' followed by a parameter as a variable;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Bytes As ES6FUN LPAR Ident COLON Ident COMMA ZWSP
##
## Ends in an error in state: 87.
##
## nsepseq(fun_param,COMMA) -> fun_param COMMA . nsepseq(fun_param,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## fun_param COMMA
##

Ill-formed functional type.
At this point, a parameter is expected as a variable.

interactive_expr: Bytes As ES6FUN LPAR Ident COLON Ident RPAR ARROW ZWSP
##
## Ends in an error in state: 90.
##
## fun_type -> ES6FUN par(nsepseq(fun_param,COMMA)) ARROW . type_expr [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ES6FUN par(nsepseq(fun_param,COMMA)) ARROW
##

Ill-formed functional type expression.
At this point, the return type is expected as a type expression.

interactive_expr: Bytes As LBRACE Ident RBRACE VBAR ZWSP
##
## Ends in an error in state: 107.
##
## nsepseq(object_type,VBAR) -> object_type VBAR . nsepseq(object_type,VBAR) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## object_type VBAR
##

Ill-formed discriminated union.
At this point, another record type is expected.

interactive_expr: Bytes As LBRACE Ident RBRACE VBAR Attr ZWSP
##
## Ends in an error in state: 108.
##
## object_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,object_sep) RBRACE [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record type.
At this point, a record type is expected to start with an opening
brace '{'.

interactive_expr: Bytes As LBRACE Ident COLON Ident While
##
## Ends in an error in state: 117.
##
## nsepseq(field_decl,object_sep) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,object_sep) -> field_decl . object_sep nsepseq(field_decl,object_sep) [ RBRACE ]
## nseq(__anonymous_0(field_decl,object_sep)) -> field_decl . object_sep [ RBRACE ]
## nseq(__anonymous_0(field_decl,object_sep)) -> field_decl . object_sep nseq(__anonymous_0(field_decl,object_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 134, spurious reduction of production type_annotation -> COLON type_expr
## In state 135, spurious reduction of production field_decl -> Ident type_annotation
##

Ill-formed record type.
At this point, one of the following is expected:
  * a comma ',' or semicolon ';' followed by another field declaration;
  * a closing brace '}' if the record type is complete.

interactive_expr: Bytes As LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 120.
##
## nsepseq(field_decl,object_sep) -> field_decl object_sep . nsepseq(field_decl,object_sep) [ RBRACE ]
## nseq(__anonymous_0(field_decl,object_sep)) -> field_decl object_sep . [ RBRACE ]
## nseq(__anonymous_0(field_decl,object_sep)) -> field_decl object_sep . nseq(__anonymous_0(field_decl,object_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl object_sep
##

Ill-formed record expression.
At this point, one of the following is expected:
  * another field assignment;
  * a closing brace '}' if the record type is complete.

interactive_expr: Bytes As Attr ZWSP
##
## Ends in an error in state: 124.
##
## core_type -> nseq(Attr) . type_tuple [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## object_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,object_sep) RBRACE [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## sum_type -> nseq(Attr) . VBAR nsepseq(variant,VBAR) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## variant -> nseq(Attr) . brackets(variant_comp) [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##
contract: Ident As LBRACKET Attr ZWSP
##
## Ends in an error in state: 155.
##
## object_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,object_sep) RBRACE [ VBAR RBRACKET COMMA ]
## sum_type -> nseq(Attr) . VBAR nsepseq(variant,VBAR) [ RBRACKET COMMA ]
## type_component_no_string -> nseq(Attr) . type_tuple [ RBRACKET COMMA ]
## variant -> nseq(Attr) . brackets(variant_comp) [ VBAR RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed type expression.
At this point, one of the following is expected:
  * an opening brace '{' if defining a record type;
  * an opening bracket '[' if defining a tuple of types;
  * a vertical bar '|' followed by a variant.

interactive_expr: Bytes As Attr VBAR ZWSP
##
## Ends in an error in state: 125.
##
## sum_type -> nseq(Attr) VBAR . nsepseq(variant,VBAR) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) VBAR
##
interactive_expr: Bytes As VBAR LBRACKET String RBRACKET VBAR ZWSP
##
## Ends in an error in state: 94.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##

Ill-formed discriminated union.
At this point, another variant is expected as a record type.

interactive_expr: Bytes As Attr VBAR Attr ZWSP
##
## Ends in an error in state: 95.
##
## variant -> nseq(Attr) . brackets(variant_comp) [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed variant of a sum type.
At this point, if the attribute is complete, an opening bracket '[' is
expected.

interactive_expr: Bytes As VBAR LBRACKET String COMMA Ident While
##
## Ends in an error in state: 173.
##
## nsepseq(ctor_param,COMMA) -> ctor_param . [ RBRACKET ]
## nsepseq(ctor_param,COMMA) -> ctor_param . COMMA nsepseq(ctor_param,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## ctor_param
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 169, spurious reduction of production ctor_param -> type_expr
##

Ill-formed variant of a sum type.
At this point, one of the following is expected:
  * a comma ',' followed by another constructor parameter as a type
    expression;
  * a closing bracket ']' if the variant is complete.

interactive_expr: Bytes As VBAR LBRACKET String COMMA Ident COMMA ZWSP
##
## Ends in an error in state: 174.
##
## nsepseq(ctor_param,COMMA) -> ctor_param COMMA . nsepseq(ctor_param,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## ctor_param COMMA
##

Ill-formed variant of a sum type.
At this point, a constructor parameter is expected as a type
expression.

interactive_expr: Bytes As LBRACKET Ident While
##
## Ends in an error in state: 139.
##
## type_component_no_string -> Ident . [ RBRACKET COMMA ]
## type_ctor_app -> Ident . chevrons(type_ctor_args) [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed tuple of types.
At this point, one of the following is expected:
  * a comma ',' followed by another component as a type expression;
  * a closing bracket ']' if the tuple is complete.

interactive_expr: Bytes As LBRACKET Ident COMMA ZWSP
##
## Ends in an error in state: 146.
##
## type_components -> type_component_no_string COMMA . nsepseq(type_component,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_component_no_string COMMA
##
contract: Ident As LBRACKET Ident COMMA Ident COMMA ZWSP
##
## Ends in an error in state: 149.
##
## nsepseq(type_component,COMMA) -> type_component COMMA . nsepseq(type_component,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_component COMMA
##

Ill-formed tuple of types.
At this point, a component is expected as a type expression.

interactive_expr: Bytes As LPAR Ident While
##
## Ends in an error in state: 159.
##
## par(type_expr) -> LPAR type_expr . RPAR [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
##

Ill-formed parenthesised type expression.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Bytes As Ident LT Ident While
##
## Ends in an error in state: 165.
##
## nsepseq(type_ctor_arg,COMMA) -> type_ctor_arg . [ GT ]
## nsepseq(type_ctor_arg,COMMA) -> type_ctor_arg . COMMA nsepseq(type_ctor_arg,COMMA) [ GT ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 161, spurious reduction of production type_ctor_arg -> type_expr
##

Ill-formed instantiation of a parametric type.
At this point, one of the following is expected:
  * a comma ',' followed by another type argument as a type expression;
  * a closing chevron '>' if there are no more arguments.

interactive_expr: Bytes As Ident LT Ident COMMA ZWSP
##
## Ends in an error in state: 166.
##
## nsepseq(type_ctor_arg,COMMA) -> type_ctor_arg COMMA . nsepseq(type_ctor_arg,COMMA) [ GT ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg COMMA
##

Ill-formed instantiation of a parametric type.
At this point, another type argument is expected as a type expression.

interactive_expr: Bytes As UIdent DOT ZWSP
##
## Ends in an error in state: 67.
##
## module_access_t -> UIdent DOT . module_var_t [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a type in a module.
At this point, the qualified name of a type is expected.

interactive_expr: Bytes As UIdent DOT UIdent ZWSP
##
## Ends in an error in state: 68.
##
## module_access_t -> UIdent . DOT module_var_t [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## type_ctor_app -> UIdent . chevrons(type_ctor_args) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a type in a module.
At this point, one of the following is expected:
  * a dot '.', followed by a type of the module;
  * an opening chevron '<' followed by a type parameter
    and a closing chevron '>'.

interactive_expr: Bytes As VBAR Attr ZWSP
##
## Ends in an error in state: 176.
##
## object_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,object_sep) RBRACE [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
## variant -> nseq(Attr) . brackets(variant_comp) [ VBAR SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed variant or union type.
At this point, if the attribute is complete, one of the following is
expected:
  * an opening bracket '[' if defining a variant;
  * an opening brace '(' if defining a union type (object type).

interactive_expr: LT Ident GT WILD
##
## Ends in an error in state: 208.
##
## fun_expr -> type_parameters . ES6FUN par(parameters) ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters . ES6FUN par(parameters) type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters . ES6FUN LPAR RPAR ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters . ES6FUN LPAR RPAR type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production chevrons(nsepseq(type_param,COMMA)) -> LT nsepseq(type_param,COMMA) GT
## In state 279, spurious reduction of production type_parameters -> chevrons(nsepseq(type_param,COMMA))
##

Ill-formed functional expression.
At this point, if the type parameters are complete, the value
parameters are expected between parentheses.

interactive_expr: LT Ident GT ES6FUN ZWSP
##
## Ends in an error in state: 209.
##
## fun_expr -> type_parameters ES6FUN . par(parameters) ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters ES6FUN . par(parameters) type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters ES6FUN . LPAR RPAR ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters ES6FUN . LPAR RPAR type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN
##

Ill-formed function expression.
At this point, a opening parenthesis is expected, followed by
parameters, if any;

interactive_expr: LT Ident GT ES6FUN LPAR ZWSP
##
## Ends in an error in state: 210.
##
## fun_expr -> type_parameters ES6FUN LPAR . RPAR ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters ES6FUN LPAR . RPAR type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## par(parameters) -> LPAR . parameters RPAR [ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN LPAR
##
interactive_expr: ES6FUN LPAR ZWSP
##
## Ends in an error in state: 724.
##
## fun_expr -> ES6FUN LPAR . RPAR ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> ES6FUN LPAR . RPAR type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## par(parameters) -> LPAR . parameters RPAR [ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ES6FUN LPAR
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * a closing parenthesis ')';
  * a parameter name.

interactive_expr: ES6FUN LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 734.
##
## fun_expr -> ES6FUN par(parameters) . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> ES6FUN par(parameters) . type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN par(parameters)
##
interactive_expr: ES6FUN LPAR RPAR ZWSP
##
## Ends in an error in state: 725.
##
## fun_expr -> ES6FUN LPAR RPAR . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> ES6FUN LPAR RPAR . type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN LPAR RPAR
##
interactive_expr: LT Ident GT ES6FUN LPAR RPAR ZWSP
##
## Ends in an error in state: 211.
##
## fun_expr -> type_parameters ES6FUN LPAR RPAR . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters ES6FUN LPAR RPAR . type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN LPAR RPAR
##
interactive_expr: LT Ident GT ES6FUN LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 303.
##
## fun_expr -> type_parameters ES6FUN par(parameters) . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
## fun_expr -> type_parameters ES6FUN par(parameters) . type_annotation ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN par(parameters)
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * an arrow '=>' followed by the function body;
  * the return type annotation starting with a colon ':'.

interactive_expr: Bytes QMARK Bytes SEMI
##
## Ends in an error in state: 230.
##
## ternary_expr(expr) -> disj_expr_level QMARK expr . COLON expr [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: For LPAR SEMI SEMI Ident QMARK DECR Ident COMMA
##
## Ends in an error in state: 485.
##
## ternary_expr(non_decl_expr_stmt(closed_non_decl_expr_stmt)) -> disj_expr_level QMARK non_decl_expr_stmt(closed_non_decl_expr_stmt) . COLON non_decl_expr_stmt(closed_non_decl_expr_stmt) [ RPAR COMMA COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK non_decl_expr_stmt(closed_non_decl_expr_stmt)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 482, spurious reduction of production non_decl_expr_stmt(closed_non_decl_expr_stmt) -> increment_decrement_operators
##
contract: Ident QMARK DECR Ident Else
##
## Ends in an error in state: 454.
##
## ternary_expr(non_decl_expr_stmt(expr_stmt)) -> disj_expr_level QMARK non_decl_expr_stmt(expr_stmt) . COLON non_decl_expr_stmt(expr_stmt) [ SEMI RBRACE Else EOF Default Case COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK non_decl_expr_stmt(expr_stmt)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 444, spurious reduction of production non_decl_expr_stmt(expr_stmt) -> increment_decrement_operators
##

Ill-formed ternary conditional expression.
At this point, a colon ':' is expected, followed by the falsy alternative as an expression.

interactive_expr: Bytes QMARK Bytes COLON ZWSP
##
## Ends in an error in state: 231.
##
## ternary_expr(expr) -> disj_expr_level QMARK expr COLON . expr [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK expr COLON
##
contract: For LPAR SEMI SEMI Ident QMARK DECR Ident COLON ZWSP
##
## Ends in an error in state: 486.
##
## ternary_expr(non_decl_expr_stmt(closed_non_decl_expr_stmt)) -> disj_expr_level QMARK non_decl_expr_stmt(closed_non_decl_expr_stmt) COLON . non_decl_expr_stmt(closed_non_decl_expr_stmt) [ RPAR COMMA COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK non_decl_expr_stmt(closed_non_decl_expr_stmt) COLON
##

Ill-formed ternary conditional expression.
At this point, the falsy alternative is expected as an expression.

interactive_expr: Bytes As ZWSP
##
## Ends in an error in state: 281.
##
## as_expr -> call_expr_level As . type_expr [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## call_expr_level As
##

Ill-formed annotated expression.
At this point, a type expression is expected.

interactive_expr: LT Ident GT ES6FUN LPAR RPAR COLON Ident While
##
## Ends in an error in state: 292.
##
## fun_expr -> type_parameters ES6FUN LPAR RPAR type_annotation . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN LPAR RPAR type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 134, spurious reduction of production type_annotation -> COLON type_expr
##
interactive_expr: ES6FUN WILD ZWSP
##
## Ends in an error in state: 37.
##
## fun_expr -> ES6FUN WILD . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN WILD
##
interactive_expr: Bytes As ES6FUN LPAR Ident COLON Ident RPAR ZWSP
##
## Ends in an error in state: 89.
##
## fun_type -> ES6FUN par(nsepseq(fun_param,COMMA)) . ARROW type_expr [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ES6FUN par(nsepseq(fun_param,COMMA))
##
interactive_expr: LT Ident GT ES6FUN LPAR Bytes RPAR COLON Ident While
##
## Ends in an error in state: 306.
##
## fun_expr -> type_parameters ES6FUN par(parameters) type_annotation . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN par(parameters) type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 134, spurious reduction of production type_annotation -> COLON type_expr
##
interactive_expr: ES6FUN LPAR RPAR COLON Ident While
##
## Ends in an error in state: 728.
##
## fun_expr -> ES6FUN LPAR RPAR type_annotation . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN LPAR RPAR type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 134, spurious reduction of production type_annotation -> COLON type_expr
##
interactive_expr: ES6FUN Ident ZWSP
##
## Ends in an error in state: 731.
##
## fun_expr -> ES6FUN Ident . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN Ident
##
interactive_expr: ES6FUN LPAR Bytes RPAR COLON Ident While
##
## Ends in an error in state: 737.
##
## fun_expr -> ES6FUN par(parameters) type_annotation . ARROW body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN par(parameters) type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 134, spurious reduction of production type_annotation -> COLON type_expr
##

Ill-formed function expression.
At this point, an arrow '=>' is expected.

interactive_expr: ES6FUN LPAR Bytes COLON Ident While
##
## Ends in an error in state: 297.
##
## nsepseq(parameter,COMMA) -> parameter . [ RPAR ]
## nsepseq(parameter,COMMA) -> parameter . COMMA nsepseq(parameter,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## parameter
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 134, spurious reduction of production type_annotation -> COLON type_expr
## In state 301, spurious reduction of production parameter -> expr type_annotation
##

Ill-formed functional expression.
At this point, if the type of the parameter is complete, one of the
following is expected:
  * a comma ',' followed by another parameter;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: ES6FUN LPAR Bytes COMMA ZWSP
##
## Ends in an error in state: 298.
##
## nsepseq(parameter,COMMA) -> parameter COMMA . nsepseq(parameter,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## parameter COMMA
##

Ill-formed function parameters.
At this point, another parameter is expected.

interactive_expr: ES6FUN LPAR Bytes SEMI
##
## Ends in an error in state: 300.
##
## parameter -> expr . [ RPAR COMMA ]
## parameter -> expr . type_annotation [ RPAR COMMA ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##

Ill-formed function parameter.
At this point, one of the following is expected:
  * a type annotation starting with a colon ':';
  * a closing parenthesis ')' otherwise.

contract: Ident QMARK Ident LPAR RPAR While
##
## Ends in an error in state: 452.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ QMARK BOOL_OR ]
## ternary_expr(non_decl_expr_stmt(expr_stmt)) -> disj_expr_level . QMARK non_decl_expr_stmt(expr_stmt) COLON non_decl_expr_stmt(expr_stmt) [ SEMI RBRACE Else EOF Default Case COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 457, spurious reduction of production call_expr_level -> call_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
##
contract: For LPAR SEMI SEMI Ident ZWSP
##
## Ends in an error in state: 483.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ QMARK BOOL_OR ]
## ternary_expr(non_decl_expr_stmt(closed_non_decl_expr_stmt)) -> disj_expr_level . QMARK non_decl_expr_stmt(closed_non_decl_expr_stmt) COLON non_decl_expr_stmt(closed_non_decl_expr_stmt) [ RPAR COMMA COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 404, spurious reduction of production member_expr -> Ident
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
##

Ill-formed expression.
At this point, if the boolean expression is complete, one of the following is expected:
  * a question mark '?' if defining a ternary conditional expression;
  * the boolean disjunction operator '||' if defining a boolean expression.

contract: Ident QMARK Ident DIV_EQ Bytes COLON ZWSP
##
## Ends in an error in state: 455.
##
## ternary_expr(non_decl_expr_stmt(expr_stmt)) -> disj_expr_level QMARK non_decl_expr_stmt(expr_stmt) COLON . non_decl_expr_stmt(expr_stmt) [ SEMI RBRACE Else EOF Default Case COLON ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK non_decl_expr_stmt(expr_stmt) COLON
##

Ill-formed ternary conditional statement.
At this point, the expression in case the condition is false is
expected.

contract: Ident REM_EQ ZWSP
##
## Ends in an error in state: 460.
##
## assign_stmt -> assign_lhs REM_EQ . expr [ SEMI RPAR RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## assign_lhs REM_EQ
##
contract: Ident PLUS_EQ ZWSP
##
## Ends in an error in state: 462.
##
## assign_stmt -> assign_lhs PLUS_EQ . expr [ SEMI RPAR RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## assign_lhs PLUS_EQ
##
contract: Ident MULT_EQ ZWSP
##
## Ends in an error in state: 464.
##
## assign_stmt -> assign_lhs MULT_EQ . expr [ SEMI RPAR RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## assign_lhs MULT_EQ
##
contract: Ident MINUS_EQ ZWSP
##
## Ends in an error in state: 466.
##
## assign_stmt -> assign_lhs MINUS_EQ . expr [ SEMI RPAR RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## assign_lhs MINUS_EQ
##
contract: Ident DIV_EQ ZWSP
##
## Ends in an error in state: 470.
##
## assign_stmt -> assign_lhs DIV_EQ . expr [ SEMI RPAR RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## assign_lhs DIV_EQ
##

Ill-formed assignment.
At this point, an expression is expected.

contract: If LPAR Bytes RPAR Return Else ZWSP
##
## Ends in an error in state: 670.
##
## if_else_stmt(statement) -> If par(if_cond) closed_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_stmt Else
##
contract: If LPAR Bytes RPAR If LPAR Bytes RPAR Return Else ZWSP
##
## Ends in an error in state: 664.
##
## if_else_stmt(closed_stmt) -> If par(if_cond) closed_stmt Else . closed_stmt [ Else ]
## if_else_stmt(statement) -> If par(if_cond) closed_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_stmt Else
##

Ill-formed conditional statement.
At this point, the statement of the 'else' branch is expected.

contract: Switch LPAR Bytes RPAR LBRACE Default COLON Return SEMI ZWSP
##
## Ends in an error in state: 678.
##
## nsepseq(case_statement,SEMI) -> case_statement SEMI . nsepseq(case_statement,SEMI) [ RBRACE Default Case ]
## nseq(__anonymous_0(case_statement,SEMI)) -> case_statement SEMI . [ RBRACE Default Case ]
## nseq(__anonymous_0(case_statement,SEMI)) -> case_statement SEMI . nseq(__anonymous_0(case_statement,SEMI)) [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## case_statement SEMI
##

Ill-formed switch statement.
At this point, one of the following is expected:
  * another statement for the current case;
  * a new case starting with the keyword 'case';
  * the default case starting with the keyword 'default';
  * a `break` to terminate the current switch;
  * a closing brace '}' if the switch is complete.

contract: Switch LPAR Bytes RPAR LBRACE Default COLON Return Default
##
## Ends in an error in state: 688.
##
## braces(cases) -> LBRACE cases . RBRACE [ SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## LBRACE cases
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 322, spurious reduction of production return_stmt -> Return
## In state 435, spurious reduction of production base_stmt(statement) -> return_stmt
## In state 476, spurious reduction of production statement -> base_stmt(statement)
## In state 672, spurious reduction of production case_statement -> statement
## In state 677, spurious reduction of production nsepseq(case_statement,SEMI) -> case_statement
## In state 675, spurious reduction of production sep_or_term_list(case_statement,SEMI) -> nsepseq(case_statement,SEMI)
## In state 673, spurious reduction of production case_statements -> sep_or_term_list(case_statement,SEMI)
## In state 676, spurious reduction of production default_case -> Default COLON case_statements
## In state 687, spurious reduction of production cases -> default_case
##

Ill-formed switch statement.
At this point, if the case is complete, one of the following is expected:
  * another case;
  * a closing brace '}' if no more cases.

contract: LBRACE Return While
##
## Ends in an error in state: 696.
##
## braces(statements) -> LBRACE statements . RBRACE [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE statements
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 322, spurious reduction of production return_stmt -> Return
## In state 435, spurious reduction of production base_stmt(statement) -> return_stmt
## In state 476, spurious reduction of production statement -> base_stmt(statement)
## In state 698, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 721, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
## In state 702, spurious reduction of production statements -> sep_or_term_list(statement,SEMI)
##

Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * a semicolon ';' followed by another statement;
  * closing brace '}' if no more statements.

contract: LBRACE Return SEMI ZWSP
##
## Ends in an error in state: 699.
##
## nsepseq(statement,SEMI) -> statement SEMI . nsepseq(statement,SEMI) [ RBRACE ]
## nseq(__anonymous_0(statement,SEMI)) -> statement SEMI . [ RBRACE ]
## nseq(__anonymous_0(statement,SEMI)) -> statement SEMI . nseq(__anonymous_0(statement,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## statement SEMI
##

Ill-formed block of statements.
At this point, one of the following is expected:
  * another statement;
  * a closing brace '}' if no more statements.

contract: LBRACE ELLIPSIS Bytes COLON
##
## Ends in an error in state: 708.
##
## nsepseq(property,object_sep) -> property . [ RBRACE ]
## nsepseq(property,object_sep) -> property . object_sep nsepseq(property,object_sep) [ RBRACE ]
## nseq(__anonymous_0(property,object_sep)) -> property . object_sep [ RBRACE ]
## nseq(__anonymous_0(property,object_sep)) -> property . object_sep nseq(__anonymous_0(property,object_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
## In state 740, spurious reduction of production property -> ELLIPSIS expr
##

Ill-formed record expression.
At this point, if the property is complete, one of the following is
expected:
  * a semicolon ';' or comma ',' followed by another property;
  * a closing brace '}' if no more properties.

interactive_expr: ES6FUN LPAR Bytes RPAR COLON Ident ARROW ZWSP
##
## Ends in an error in state: 738.
##
## fun_expr -> ES6FUN par(parameters) type_annotation ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN par(parameters) type_annotation ARROW
##
interactive_expr: ES6FUN LPAR Bytes RPAR ARROW ZWSP
##
## Ends in an error in state: 735.
##
## fun_expr -> ES6FUN par(parameters) ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN par(parameters) ARROW
##
interactive_expr: ES6FUN Ident ARROW ZWSP
##
## Ends in an error in state: 732.
##
## fun_expr -> ES6FUN Ident ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN Ident ARROW
##
interactive_expr: ES6FUN LPAR RPAR COLON Ident ARROW ZWSP
##
## Ends in an error in state: 729.
##
## fun_expr -> ES6FUN LPAR RPAR type_annotation ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN LPAR RPAR type_annotation ARROW
##
interactive_expr: ES6FUN LPAR RPAR ARROW ZWSP
##
## Ends in an error in state: 726.
##
## fun_expr -> ES6FUN LPAR RPAR ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN LPAR RPAR ARROW
##
interactive_expr: LT Ident GT ES6FUN LPAR Bytes RPAR COLON Ident ARROW ZWSP
##
## Ends in an error in state: 307.
##
## fun_expr -> type_parameters ES6FUN par(parameters) type_annotation ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN par(parameters) type_annotation ARROW
##
interactive_expr: LT Ident GT ES6FUN LPAR Bytes RPAR ARROW ZWSP
##
## Ends in an error in state: 304.
##
## fun_expr -> type_parameters ES6FUN par(parameters) ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN par(parameters) ARROW
##
interactive_expr: LT Ident GT ES6FUN LPAR RPAR COLON Ident ARROW ZWSP
##
## Ends in an error in state: 293.
##
## fun_expr -> type_parameters ES6FUN LPAR RPAR type_annotation ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN LPAR RPAR type_annotation ARROW
##
interactive_expr: LT Ident GT ES6FUN LPAR RPAR ARROW ZWSP
##
## Ends in an error in state: 212.
##
## fun_expr -> type_parameters ES6FUN LPAR RPAR ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## type_parameters ES6FUN LPAR RPAR ARROW
##
interactive_expr: ES6FUN WILD ARROW ZWSP
##
## Ends in an error in state: 38.
##
## fun_expr -> ES6FUN WILD ARROW . body [ SEMI RPAR RBRACKET RBRACE Else EOF Default Case COMMA COLON ]
##
## The known suffix of the stack is as follows:
## ES6FUN WILD ARROW
##

Ill-formed functional expression.
At this point, the body is expected as one of the following:
  * an expression;
  * a block of statements between braces '{' '}'.

contract: Namespace UIdent LBRACE Return While
##
## Ends in an error in state: 771.
##
## nsepseq(stmt_or_namespace,SEMI) -> stmt_or_namespace . [ RBRACE ]
## nsepseq(stmt_or_namespace,SEMI) -> stmt_or_namespace . SEMI nsepseq(stmt_or_namespace,SEMI) [ RBRACE ]
## nseq(__anonymous_0(stmt_or_namespace,SEMI)) -> stmt_or_namespace . SEMI [ RBRACE ]
## nseq(__anonymous_0(stmt_or_namespace,SEMI)) -> stmt_or_namespace . SEMI nseq(__anonymous_0(stmt_or_namespace,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## stmt_or_namespace
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 322, spurious reduction of production return_stmt -> Return
## In state 435, spurious reduction of production base_stmt(statement) -> return_stmt
## In state 476, spurious reduction of production statement -> base_stmt(statement)
## In state 773, spurious reduction of production stmt_or_namespace -> statement
##

Ill-formed module declaration.
At this point, if the declaration is complete, one of the following is
expected:
  * a semicolon ';', followed by another declaration;
  * a closing brace '}' if the module is complete.

contract: Namespace UIdent LBRACE Return SEMI ZWSP
##
## Ends in an error in state: 772.
##
## nsepseq(stmt_or_namespace,SEMI) -> stmt_or_namespace SEMI . nsepseq(stmt_or_namespace,SEMI) [ RBRACE ]
## nseq(__anonymous_0(stmt_or_namespace,SEMI)) -> stmt_or_namespace SEMI . [ RBRACE ]
## nseq(__anonymous_0(stmt_or_namespace,SEMI)) -> stmt_or_namespace SEMI . nseq(__anonymous_0(stmt_or_namespace,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## stmt_or_namespace SEMI
##

Ill-formed module declaration.
At this point, one of the following is expected:
  * a statement or a submodule declaration;
  * a closing brace '}' if the module is complete.

contract: Return SEMI ZWSP
##
## Ends in an error in state: 789.
##
## option(SEMI) -> SEMI . [ EOF ]
## toplevel_stmts -> stmt_or_namespace SEMI . toplevel_stmts [ EOF ]
##
## The known suffix of the stack is as follows:
## stmt_or_namespace SEMI
##

Ill-formed top-level declaration.
At this point, one of the following is expected:
  * another top-level statement;
  * the end of the file, if no more statements.

interactive_expr: LBRACE Attr ZWSP
##
## Ends in an error in state: 711.
##
## property -> nseq(Attr) . property_name COLON expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record expression (object).
At this point, if the attribute is complete, a field name (property
name) is expected.

contract: LBRACE Attr ZWSP
##
## Ends in an error in state: 719.
##
## base_stmt(statement) -> nseq(Attr) . expr_stmt [ SEMI RBRACE ]
## export_decl -> nseq(Attr) . Export declaration [ SEMI RBRACE ]
## export_decl -> nseq(Attr) . Export nseq(Attr) declaration [ SEMI RBRACE ]
## for_of_stmt(statement) -> nseq(Attr) . For LPAR Const Ident Of expr RPAR statement [ SEMI RBRACE ]
## for_of_stmt(statement) -> nseq(Attr) . For LPAR Let Ident Of expr RPAR statement [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI RPAR [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI RPAR statement [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI RPAR statement [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI RPAR statement [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI RPAR statement [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE ]
## for_stmt(statement) -> nseq(Attr) . For LPAR for_initialiser SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE ]
## if_stmt -> nseq(Attr) . If par(if_cond) statement [ SEMI RBRACE ]
## property -> nseq(Attr) . property_name COLON expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed statement.
At this point if the attribute is complete, one of the following is
expected:
  * a declaration starting with the keywords 'let', 'const' or 'type';
  * the keyword 'export' followed by a declaration;
  * a property name (record field) if defining an object (record).

contract: Contract ZWSP
##
## Ends in an error in state: 194.
##
## call_expr -> Contract . LPAR nsepseq(module_name,DOT) RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## Contract
##

Ill-formed contract as a module.
At this point, an opening parenthesis '(' is expected.

contract: Contract LPAR ZWSP
##
## Ends in an error in state: 195.
##
## call_expr -> Contract LPAR . nsepseq(module_name,DOT) RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## Contract LPAR
##

Ill-formed contract as a module.
At this point, the qualified name of the module is expected.

contract: Contract LPAR UIdent ZWSP
##
## Ends in an error in state: 196.
##
## call_expr -> Contract LPAR nsepseq(module_name,DOT) . RPAR [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LPAR LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND As ]
##
## The known suffix of the stack is as follows:
## Contract LPAR nsepseq(module_name,DOT)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 59, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
##

Ill-formed contract as a module.
At this point, a closing parenthesis ')' is expected.

contract: Ident As Parameter ZWSP
##
## Ends in an error in state: 58.
##
## parameter_of_type -> Parameter . nsepseq(module_name,DOT) [ SEMI RPAR RBRACKET RBRACE GT Else EQ EOF Default Case COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## Parameter
##

Ill-formed parameter of a contract.
At this point, a module path is expected.

contract: INCR ZWSP
##
## Ends in an error in state: 34.
##
## increment_decrement_operators -> INCR . Ident [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## INCR
##

Ill-formed arithmetic expression.
At this point, the incremented variable is expected.

contract: DECR ZWSP
##
## Ends in an error in state: 192.
##
## increment_decrement_operators -> DECR . Ident [ TIMES SLASH SEMI RPAR REM RBRACKET RBRACE QMARK PLUS NE MINUS LT LE GT Else EQ2 EOF Default Case COMMA COLON BOOL_OR BOOL_AND ]
##
## The known suffix of the stack is as follows:
## DECR
##

Ill-formed arithmetic expression.
At this point, the decremented variable is expected.

contract: If LPAR Bytes RPAR For LPAR SEMI ZWSP
##
## Ends in an error in state: 407.
##
## for_stmt(closed_stmt) -> For LPAR SEMI . SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI . SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI . expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI . expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR SEMI . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR SEMI
##
contract: If LPAR Bytes RPAR Attr For LPAR SEMI ZWSP
##
## Ends in an error in state: 574.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI . SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI . SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI . expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI . expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR SEMI
##
contract: For LPAR SEMI ZWSP
##
## Ends in an error in state: 431.
##
## for_stmt(statement) -> For LPAR SEMI . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR SEMI
##
contract: Attr For LPAR SEMI ZWSP
##
## Ends in an error in state: 439.
##
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR SEMI
##
contract: Attr For LPAR DECR Ident SEMI ZWSP
##
## Ends in an error in state: 514.
##
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser SEMI
##
contract: If LPAR Bytes RPAR For LPAR DECR Ident SEMI ZWSP
##
## Ends in an error in state: 648.
##
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI . SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI . SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI . expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI . expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser SEMI
##
contract: For LPAR DECR Ident SEMI ZWSP
##
## Ends in an error in state: 557.
##
## for_stmt(statement) -> For LPAR for_initialiser SEMI . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser SEMI
##
contract: If LPAR Bytes RPAR Attr For LPAR DECR Ident SEMI ZWSP
##
## Ends in an error in state: 609.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI . expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser SEMI
##

Ill-formed 'for' loop.
At this point, one of the following is expected:
  * the condition as a boolean expression;
  * a semicolon ';' if no condition.

contract: For LPAR SEMI SEMI DECR Ident COLON
##
## Ends in an error in state: 491.
##
## nsepseq(closed_non_decl_expr_stmt,COMMA) -> closed_non_decl_expr_stmt . [ RPAR ]
## nsepseq(closed_non_decl_expr_stmt,COMMA) -> closed_non_decl_expr_stmt . COMMA nsepseq(closed_non_decl_expr_stmt,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## closed_non_decl_expr_stmt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 482, spurious reduction of production non_decl_expr_stmt(closed_non_decl_expr_stmt) -> increment_decrement_operators
## In state 481, spurious reduction of production closed_non_decl_expr_stmt -> non_decl_expr_stmt(closed_non_decl_expr_stmt)
##

Ill-formed 'for' loop.
At this point, if the statement is complete, one of the following is expected:
  * a comma ',' followed by another increment or decrement statement;
  * a closing parenthesis ')' if no more increment nor decrement.

contract: For LPAR SEMI SEMI DECR Ident COMMA ZWSP
##
## Ends in an error in state: 492.
##
## nsepseq(closed_non_decl_expr_stmt,COMMA) -> closed_non_decl_expr_stmt COMMA . nsepseq(closed_non_decl_expr_stmt,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## closed_non_decl_expr_stmt COMMA
##

Ill-formed 'for' loop.
At this point, increment or decrement statement is expected, e.g. 'i++'.

contract: Attr For LPAR SEMI Bytes While
##
## Ends in an error in state: 494.
##
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR SEMI expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: If LPAR Bytes RPAR For LPAR SEMI Bytes While
##
## Ends in an error in state: 628.
##
## for_stmt(closed_stmt) -> For LPAR SEMI expr . SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI expr . SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR SEMI expr . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR SEMI expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: For LPAR SEMI Bytes While
##
## Ends in an error in state: 537.
##
## for_stmt(statement) -> For LPAR SEMI expr . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR SEMI expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: If LPAR Bytes RPAR Attr For LPAR SEMI Bytes While
##
## Ends in an error in state: 589.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI expr . SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI expr . SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR SEMI expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: Attr For LPAR DECR Ident SEMI Bytes While
##
## Ends in an error in state: 521.
##
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser SEMI expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: If LPAR Bytes RPAR For LPAR DECR Ident SEMI Bytes While
##
## Ends in an error in state: 655.
##
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI expr . SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI expr . SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser SEMI expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: For LPAR DECR Ident SEMI Bytes While
##
## Ends in an error in state: 564.
##
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser SEMI expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##
contract: If LPAR Bytes RPAR Attr For LPAR DECR Ident SEMI Bytes While
##
## Ends in an error in state: 616.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr . SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser SEMI expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 205, spurious reduction of production call_expr_level -> member_expr
## In state 280, spurious reduction of production unary_expr_level -> call_expr_level
## In state 207, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 214, spurious reduction of production add_expr_level -> mult_expr_level
## In state 277, spurious reduction of production comp_expr_level -> add_expr_level
## In state 278, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 234, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 228, spurious reduction of production expr -> disj_expr_level
##

Ill-formed 'for' loop.
At this point, if the condition is complete, a semicolon ';' is expected.

contract: Attr For LPAR SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 495.
##
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR SEMI expr SEMI
##
contract: If LPAR Bytes RPAR For LPAR SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 629.
##
## for_stmt(closed_stmt) -> For LPAR SEMI expr SEMI . RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI expr SEMI . RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR SEMI expr SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR SEMI expr SEMI
##
contract: For LPAR SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 538.
##
## for_stmt(statement) -> For LPAR SEMI expr SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR SEMI expr SEMI
##
contract: If LPAR Bytes RPAR Attr For LPAR SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 590.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI expr SEMI . RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI expr SEMI . RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR SEMI expr SEMI
##
contract: Attr For LPAR DECR Ident SEMI SEMI ZWSP
##
## Ends in an error in state: 515.
##
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser SEMI SEMI
##
contract: If LPAR Bytes RPAR For LPAR DECR Ident SEMI SEMI ZWSP
##
## Ends in an error in state: 649.
##
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI SEMI . RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI SEMI . RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser SEMI SEMI
##
contract: For LPAR DECR Ident SEMI SEMI ZWSP
##
## Ends in an error in state: 558.
##
## for_stmt(statement) -> For LPAR for_initialiser SEMI SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser SEMI SEMI
##
contract: If LPAR Bytes RPAR Attr For LPAR DECR Ident SEMI SEMI ZWSP
##
## Ends in an error in state: 610.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser SEMI SEMI
##
contract: Attr For LPAR DECR Ident SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 522.
##
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser SEMI expr SEMI
##
contract: If LPAR Bytes RPAR For LPAR DECR Ident SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 656.
##
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI expr SEMI . RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI expr SEMI . RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser SEMI expr SEMI
##
contract: For LPAR DECR Ident SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 565.
##
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser SEMI expr SEMI
##
contract: If LPAR Bytes RPAR Attr For LPAR DECR Ident SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 617.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser SEMI expr SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser SEMI expr SEMI
##
contract: If LPAR Bytes RPAR For LPAR SEMI SEMI ZWSP
##
## Ends in an error in state: 408.
##
## for_stmt(closed_stmt) -> For LPAR SEMI SEMI . RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI SEMI . RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR SEMI SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR SEMI SEMI
##
contract: If LPAR Bytes RPAR Attr For LPAR SEMI SEMI ZWSP
##
## Ends in an error in state: 575.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI SEMI . RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI SEMI . RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR SEMI SEMI
##
contract: For LPAR SEMI SEMI ZWSP
##
## Ends in an error in state: 432.
##
## for_stmt(statement) -> For LPAR SEMI SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR SEMI SEMI
##
contract: Attr For LPAR SEMI SEMI ZWSP
##
## Ends in an error in state: 440.
##
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI SEMI . RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI SEMI . RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR SEMI SEMI . nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR SEMI SEMI
##

Ill-formed 'for' loop.
At this point, one of the following is expected:
  * at least one increment or decrement statement, e.g. 'i++';
  * a closing parenthesis ')' if no increment nor decrement.

contract: Attr For LPAR DECR Ident COLON
##
## Ends in an error in state: 513.
##
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 444, spurious reduction of production non_decl_expr_stmt(expr_stmt) -> increment_decrement_operators
## In state 443, spurious reduction of production expr_stmt -> non_decl_expr_stmt(expr_stmt)
## In state 528, spurious reduction of production for_initialiser -> expr_stmt
##
contract: If LPAR Bytes RPAR For LPAR DECR Ident COLON
##
## Ends in an error in state: 647.
##
## for_stmt(closed_stmt) -> For LPAR for_initialiser . SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser . SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser . SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser . SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 444, spurious reduction of production non_decl_expr_stmt(expr_stmt) -> increment_decrement_operators
## In state 443, spurious reduction of production expr_stmt -> non_decl_expr_stmt(expr_stmt)
## In state 528, spurious reduction of production for_initialiser -> expr_stmt
##
contract: For LPAR DECR Ident COLON
##
## Ends in an error in state: 556.
##
## for_stmt(statement) -> For LPAR for_initialiser . SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## For LPAR for_initialiser
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 444, spurious reduction of production non_decl_expr_stmt(expr_stmt) -> increment_decrement_operators
## In state 443, spurious reduction of production expr_stmt -> non_decl_expr_stmt(expr_stmt)
## In state 528, spurious reduction of production for_initialiser -> expr_stmt
##
contract: If LPAR Bytes RPAR Attr For LPAR DECR Ident COLON
##
## Ends in an error in state: 608.
##
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI RPAR closed_stmt [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ Else ]
## for_stmt(closed_stmt) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR closed_stmt [ Else ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI RPAR statement [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR [ SEMI RBRACE EOF Default Case ]
## for_stmt(statement) -> nseq(Attr) For LPAR for_initialiser . SEMI expr SEMI nsepseq(closed_non_decl_expr_stmt,COMMA) RPAR statement [ SEMI RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) For LPAR for_initialiser
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 444, spurious reduction of production non_decl_expr_stmt(expr_stmt) -> increment_decrement_operators
## In state 443, spurious reduction of production expr_stmt -> non_decl_expr_stmt(expr_stmt)
## In state 528, spurious reduction of production for_initialiser -> expr_stmt
##

Ill-formed 'for' loop.
At this point, if the initialiser statement is complete, a semicolon ';' is expected.

contract: Ident As LBRACKET Int While
##
## Ends in an error in state: 145.
##
## type_components -> type_component_no_string . [ RBRACKET ]
## type_components -> type_component_no_string . COMMA nsepseq(type_component,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_component_no_string
##
contract: Ident As LBRACKET Ident COMMA Ident While
##
## Ends in an error in state: 148.
##
## nsepseq(type_component,COMMA) -> type_component . [ RBRACKET ]
## nsepseq(type_component,COMMA) -> type_component . COMMA nsepseq(type_component,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_component
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 79, spurious reduction of production core_type -> Ident
## In state 133, spurious reduction of production type_expr -> core_type
## In state 147, spurious reduction of production type_component -> type_expr
##

Ill-formed type component in a tuple.
At this point, one of the following is expected:
  * a comma ',' followed by another component as a type expression;
  * a closing bracket ']' if the tuple is complete.

contract: Ident As LBRACKET UIdent ZWSP
##
## Ends in an error in state: 66.
##
## module_access_t -> UIdent . DOT module_var_t [ RBRACKET COMMA ]
## type_component_no_string -> UIdent . [ RBRACKET COMMA ]
## type_ctor_app -> UIdent . chevrons(type_ctor_args) [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed type component in a tuple.
At this point, one of the following is expected:
  * a selection operator '.' if defining a module path;
  * a comma ',' followed by another component as a type expression;
  * a closing bracket ']' if the tuple is complete;
  * a type parameter after a chevron '<'.
