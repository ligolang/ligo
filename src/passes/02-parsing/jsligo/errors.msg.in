contract: ZWSP
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.
At this point, a top-level declaration is expected.

contract: Type ZWSP
##
## Ends in an error in state: 245.
##
## type_decl -> Type . type_name EQ type_expr [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## type_decl -> Type . type_name type_vars EQ type_expr [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, a new type name is expected.

contract: Type Ident ZWSP
##
## Ends in an error in state: 250.
##
## type_decl -> Type type_name . EQ type_expr [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## type_decl -> Type type_name . type_vars EQ type_expr [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Type type_name
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by a type;
  * type parameters (variables) between chevrons ('<', '>') if the
    type is generic.

interactive_expr: LT ZWSP
##
## Ends in an error in state: 43.
##
## chevrons(sep_or_term(type_var,COMMA)) -> LT . sep_or_term(type_var,COMMA) gt [ WILD VBAR UIdent String ParameterOf Nat LPAR LBRACKET LBRACE Int Ident ES6FUN EQ EIdent Attr ]
##
## The known suffix of the stack is as follows:
## LT
##

Ill-formed generic declaration.
At this point, a type parameter is expected as a variable.

interactive_expr: LT Ident ZWSP
##
## Ends in an error in state: 48.
##
## nsepseq(type_var,COMMA) -> type_var . [ GT ]
## nsepseq(type_var,COMMA) -> type_var . COMMA nsepseq(type_var,COMMA) [ GT ]
## nseq(__anonymous_0(type_var,COMMA)) -> type_var . COMMA [ GT ]
## nseq(__anonymous_0(type_var,COMMA)) -> type_var . COMMA nseq(__anonymous_0(type_var,COMMA)) [ GT ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed generic declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another type parameter (variable);
  * a closing chevron '>' if there are no more parameters.

interactive_expr: LT Ident COMMA ZWSP
##
## Ends in an error in state: 49.
##
## nsepseq(type_var,COMMA) -> type_var COMMA . nsepseq(type_var,COMMA) [ GT ]
## nseq(__anonymous_0(type_var,COMMA)) -> type_var COMMA . [ GT ]
## nseq(__anonymous_0(type_var,COMMA)) -> type_var COMMA . nseq(__anonymous_0(type_var,COMMA)) [ GT ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##

Ill-formed generic declaration.
At this point, one of the following is expected:
  * another type parameter (variable);
  * a closing chevron '>' if there are no more parameters.

contract: Type Ident EQ ZWSP
##
## Ends in an error in state: 251.
##
## type_decl -> Type type_name EQ . type_expr [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Type type_name EQ
##
contract: Type Ident LT GT EQ ZWSP
##
## Ends in an error in state: 254.
##
## type_decl -> Type type_name type_vars EQ . type_expr [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Type type_name type_vars EQ
##
contract: Interface UIdent LBRACE Type EIdent LT GT EQ ZWSP
##
## Ends in an error in state: 543.
##
## interface_type -> Type type_name type_vars EQ . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Type type_name type_vars EQ
##

Ill-formed type declaration.
At this point, a type is expected.

interactive_expr: ContractOf LPAR UIdent DOT ZWSP
##
## Ends in an error in state: 120.
##
## namespace_path(namespace_name) -> namespace_name DOT . namespace_path(namespace_name) [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
## namespace_path(namespace_name) -> namespace_name DOT . namespace_name [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## namespace_name DOT
##

Ill-formed selection in a namespace.
At this point, a namespace name is expected.

interactive_expr: ES6FUN LPAR Ident COLON ZWSP
##
## Ends in an error in state: 110.
##
## type_annotation(type_expr) -> COLON . type_expr [ SEMI RPAR RBRACE PARAMS COMMA ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type is expected.

contract: Type Ident LT GT XOR
##
## Ends in an error in state: 253.
##
## type_decl -> Type type_name type_vars . EQ type_expr [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Type type_name type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production gt -> GT
## In state 55, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) gt
## In state 256, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##
contract: Interface UIdent LBRACE Type EIdent LT GT XOR
##
## Ends in an error in state: 542.
##
## interface_type -> Type type_name type_vars . EQ type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Type type_name type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production gt -> GT
## In state 55, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) gt
## In state 256, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##

Ill-formed generic type declaration.
At this point, if the type parameters are complete, the assignment
symbol '=' is expected, followed by a type.

contract: Namespace ZWSP
##
## Ends in an error in state: 532.
##
## namespace_decl -> Namespace . namespace_binder braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## namespace_decl -> Namespace . namespace_binder interface braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Namespace
##

Ill-formed namespace declaration.
At this point, a namespace name is expected.

contract: Namespace UIdent ZWSP
##
## Ends in an error in state: 535.
##
## namespace_decl -> Namespace namespace_binder . braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## namespace_decl -> Namespace namespace_binder . interface braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Namespace namespace_binder
##

Ill-formed namespace declaration.
At this point, one of the following is expected:
  * the keyword 'implements' followed by an interface;
  * a block of statements starting with an opening brace '{'.

contract: Namespace UIdent LBRACE ZWSP
##
## Ends in an error in state: 244.
##
## braces(statements) -> LBRACE . statements RBRACE [ XOR While When WILD Verbatim VBAR UIdent Type True Tez TIMES Switch String SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS2 PLUS PARAMS OR Nat Namespace NE Mutez Match MINUS2 MINUS Let LT LPAR LE LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ2 EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed block of statements.
At this point, a statement is expected.

contract: Namespace UIdent LBRACE While ZWSP
##
## Ends in an error in state: 1.
##
## while_stmt(catenable_stmt) -> While . par(while_cond) catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_ending_with_expr) -> While . par(while_cond) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##
contract: Return If LPAR Bytes RPAR While ZWSP
##
## Ends in an error in state: 997.
##
## while_stmt(__anonymous_5) -> While . par(while_cond) type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(closed_non_if_stmt) -> While . par(while_cond) closed_non_if_stmt [ SEMI_ELSE Else ]
## while_stmt(export(type_decl)) -> While . par(while_cond) export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_not_ending_with_expr) -> While . par(while_cond) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##
contract: Return While LPAR Bytes RPAR While ZWSP
##
## Ends in an error in state: 993.
##
## while_stmt(__anonymous_5) -> While . par(while_cond) type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(export(type_decl)) -> While . par(while_cond) export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_not_ending_with_expr) -> While . par(while_cond) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##
contract: Namespace UIdent LBRACE Return While ZWSP
##
## Ends in an error in state: 991.
##
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_not_ending_with_expr) -> While . par(while_cond) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> While . par(while_cond) stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##

Ill-formed while-loop.
At this point, the invariant between parentheses is expected.

contract: Namespace UIdent LBRACE While LPAR ZWSP
##
## Ends in an error in state: 2.
##
## par(while_cond) -> LPAR . while_cond RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## par(while_cond) -> LPAR . while_cond PARAMS RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed while-loop.
At this point, the invariant is expected as a boolean expression.

interactive_expr: PLUS2 ZWSP
##
## Ends in an error in state: 27.
##
## pre_incr_expr -> PLUS2 . WILD [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
## pre_incr_expr -> PLUS2 . Ident [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
## pre_incr_expr -> PLUS2 . EIdent [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## PLUS2
##

Ill-formed increment.
At this point, the incremented variable is expected.

interactive_expr: LPAR ZWSP
##
## Ends in an error in state: 36.
##
## par(expr) -> LPAR . expr RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(expr) -> LPAR . expr PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected.

interactive_expr: Match ZWSP
##
## Ends in an error in state: 35.
##
## match_expr -> Match . match_subject braces(match_clauses) [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## Match
##

Ill-formed pattern matching.
At this point, the matched expression is expected.

contract: Const LBRACKET ZWSP
##
## Ends in an error in state: 595.
##
## brackets(sep_or_term(element(pattern),COMMA)) -> LBRACKET . sep_or_term(element(pattern),COMMA) RBRACKET [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##
interactive_expr: ES6FUN LPAR LBRACKET ZWSP
##
## Ends in an error in state: 71.
##
## brackets(sep_or_term(element(param_pattern),COMMA)) -> LBRACKET . sep_or_term(element(param_pattern),COMMA) RBRACKET [ SEMI RPAR RBRACKET RBRACE PARAMS COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed array pattern.
At this point, a pattern matching the first element is expected.

contract: Const LBRACE ZWSP
##
## Ends in an error in state: 596.
##
## braces(sep_or_term(property_pattern(pattern),property_sep)) -> LBRACE . sep_or_term(property_pattern(pattern),property_sep) RBRACE [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: ES6FUN LPAR LBRACE ZWSP
##
## Ends in an error in state: 72.
##
## braces(sep_or_term(property_pattern(param_pattern),property_sep)) -> LBRACE . sep_or_term(property_pattern(param_pattern),property_sep) RBRACE [ SEMI RPAR RBRACKET RBRACE PARAMS COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record pattern.
At this point, a pattern matching the first field is expected.

contract: Const LBRACE Attr ZWSP
##
## Ends in an error in state: 597.
##
## property_pattern(pattern) -> Attr . property_pattern(pattern) [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated field pattern.
At this point, one of the following is expected:
  * another decorator;
  * a field pattern.

contract: Const LBRACE Ident ZWSP
##
## Ends in an error in state: 599.
##
## property_pattern(pattern) -> property_id . [ SEMI RBRACE COMMA ]
## property_pattern(pattern) -> property_id . COLON pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id
##
interactive_expr: ES6FUN LPAR LBRACE Ident ZWSP
##
## Ends in an error in state: 76.
##
## property_pattern(param_pattern) -> property_id . [ SEMI RBRACE COMMA ]
## property_pattern(param_pattern) -> property_id . COLON param_pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a colon ':' followed by a pattern matching the field;
  * a field separator (';' or ',');
  * a closing brace '}' if no more fields.

contract: Const LBRACE Ident COLON ZWSP
##
## Ends in an error in state: 600.
##
## property_pattern(pattern) -> property_id COLON . pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id COLON
##
interactive_expr: ES6FUN LPAR LBRACE Ident COLON ZWSP
##
## Ends in an error in state: 77.
##
## property_pattern(param_pattern) -> property_id COLON . param_pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id COLON
##

Ill-formed record pattern.
At this point, a pattern matching the field is expected.

contract: Const Attr ZWSP
##
## Ends in an error in state: 606.
##
## pattern -> Attr . pattern [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## Attr
##
interactive_expr: ES6FUN LPAR LBRACE Attr ZWSP
##
## Ends in an error in state: 73.
##
## property_pattern(param_pattern) -> Attr . property_pattern(param_pattern) [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated pattern
At this point, one of the following is expected:
  * another decorator;
  * a pattern.

contract: Const LBRACE Ident COLON Bytes ZWSP
##
## Ends in an error in state: 642.
##
## nsepseq(property_pattern(pattern),property_sep) -> property_pattern(pattern) . [ RBRACE ]
## nsepseq(property_pattern(pattern),property_sep) -> property_pattern(pattern) . property_sep nsepseq(property_pattern(pattern),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_pattern(pattern),property_sep)) -> property_pattern(pattern) . property_sep [ RBRACE ]
## nseq(__anonymous_0(property_pattern(pattern),property_sep)) -> property_pattern(pattern) . property_sep nseq(__anonymous_0(property_pattern(pattern),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_pattern(pattern)
##
interactive_expr: ES6FUN LPAR LBRACE Ident COLON Ident ZWSP
##
## Ends in an error in state: 87.
##
## nsepseq(property_pattern(param_pattern),property_sep) -> property_pattern(param_pattern) . [ RBRACE ]
## nsepseq(property_pattern(param_pattern),property_sep) -> property_pattern(param_pattern) . property_sep nsepseq(property_pattern(param_pattern),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) -> property_pattern(param_pattern) . property_sep [ RBRACE ]
## nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) -> property_pattern(param_pattern) . property_sep nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_pattern(param_pattern)
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a field separator (';' or ',');
  * a closing brace '}' if no more fields.

contract: Const LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 643.
##
## nsepseq(property_pattern(pattern),property_sep) -> property_pattern(pattern) property_sep . nsepseq(property_pattern(pattern),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_pattern(pattern),property_sep)) -> property_pattern(pattern) property_sep . [ RBRACE ]
## nseq(__anonymous_0(property_pattern(pattern),property_sep)) -> property_pattern(pattern) property_sep . nseq(__anonymous_0(property_pattern(pattern),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_pattern(pattern) property_sep
##
interactive_expr: ES6FUN LPAR LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 90.
##
## nsepseq(property_pattern(param_pattern),property_sep) -> property_pattern(param_pattern) property_sep . nsepseq(property_pattern(param_pattern),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) -> property_pattern(param_pattern) property_sep . [ RBRACE ]
## nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) -> property_pattern(param_pattern) property_sep . nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_pattern(param_pattern) property_sep
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a field pattern;
  * a closing brace '}' if no more fields.

contract: Const LBRACKET ELLIPSIS ZWSP
##
## Ends in an error in state: 649.
##
## element(pattern) -> ELLIPSIS . pattern [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##
interactive_expr: ES6FUN LPAR LBRACKET ELLIPSIS ZWSP
##
## Ends in an error in state: 96.
##
## element(param_pattern) -> ELLIPSIS . param_pattern [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed array pattern.
At this point, a pattern matching the rest of the array is expected.

contract: Const LBRACKET Bytes ZWSP
##
## Ends in an error in state: 657.
##
## nsepseq(element(pattern),COMMA) -> element(pattern) . [ RBRACKET ]
## nsepseq(element(pattern),COMMA) -> element(pattern) . COMMA nsepseq(element(pattern),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(pattern),COMMA)) -> element(pattern) . COMMA [ RBRACKET ]
## nseq(__anonymous_0(element(pattern),COMMA)) -> element(pattern) . COMMA nseq(__anonymous_0(element(pattern),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(pattern)
##
interactive_expr: ES6FUN LPAR LBRACKET Ident ZWSP
##
## Ends in an error in state: 104.
##
## nsepseq(element(param_pattern),COMMA) -> element(param_pattern) . [ RBRACKET ]
## nsepseq(element(param_pattern),COMMA) -> element(param_pattern) . COMMA nsepseq(element(param_pattern),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(param_pattern),COMMA)) -> element(param_pattern) . COMMA [ RBRACKET ]
## nseq(__anonymous_0(element(param_pattern),COMMA)) -> element(param_pattern) . COMMA nseq(__anonymous_0(element(param_pattern),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(param_pattern)
##

Ill-formed array pattern.
At this point, one of following is expected:
  * a comma ',' followed by another element pattern;
  * a closing bracket ']' if no more elements.

contract: Const LBRACKET Bytes COMMA ZWSP
##
## Ends in an error in state: 658.
##
## nsepseq(element(pattern),COMMA) -> element(pattern) COMMA . nsepseq(element(pattern),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(pattern),COMMA)) -> element(pattern) COMMA . [ RBRACKET ]
## nseq(__anonymous_0(element(pattern),COMMA)) -> element(pattern) COMMA . nseq(__anonymous_0(element(pattern),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(pattern) COMMA
##
interactive_expr: ES6FUN LPAR LBRACKET Ident COMMA ZWSP
##
## Ends in an error in state: 105.
##
## nsepseq(element(param_pattern),COMMA) -> element(param_pattern) COMMA . nsepseq(element(param_pattern),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(param_pattern),COMMA)) -> element(param_pattern) COMMA . [ RBRACKET ]
## nseq(__anonymous_0(element(param_pattern),COMMA)) -> element(param_pattern) COMMA . nseq(__anonymous_0(element(param_pattern),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(param_pattern) COMMA
##

Ill-formed array pattern.
At this point, one of the following is expected:
  * a pattern matching an element;
  * a closing bracket ']' if no more elements.

interactive_expr: MINUS2 ZWSP
##
## Ends in an error in state: 37.
##
## pre_decr_expr -> MINUS2 . WILD [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
## pre_decr_expr -> MINUS2 . Ident [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
## pre_decr_expr -> MINUS2 . EIdent [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## MINUS2
##

Ill-formed decrement.
At this point, the decremented variable is expected.

interactive_expr: LBRACKET ZWSP
##
## Ends in an error in state: 42.
##
## brackets(sep_or_term(element(expr),COMMA)) -> LBRACKET . sep_or_term(element(expr),COMMA) RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Directive Default DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed array expression.
At this point, the first element is expected.

interactive_expr: LBRACE ZWSP
##
## Ends in an error in state: 59.
##
## braces(sep_or_term(property(expr),property_sep)) -> LBRACE . sep_or_term(property(expr),property_sep) RBRACE [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr As ]
## braces(update_expr) -> LBRACE . update_expr RBRACE [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr As ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record or record update.
At this point, one of the following is expected:
  * the first field of a record;
  * a rest expression ('...') denoting the record being updated.

interactive_expr: LBRACE ELLIPSIS ZWSP
##
## Ends in an error in state: 62.
##
## update_expr -> ELLIPSIS . expr property_sep updates [ RBRACE ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed record update.
At this point, the record to update is expected.

interactive_expr: Function ZWSP
##
## Ends in an error in state: 68.
##
## function_expr -> Function . fun_par_params braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function . fun_par_params ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function . type_vars fun_par_params braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function . type_vars fun_par_params ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function
##

Ill-formed function expression.
At this point, one of the following is expected:
  * an opening parenthesis '(' optionally followed by parameters;
  * an opening chevron '<' optionally followed by type parameters.

interactive_expr: ES6FUN LPAR ZWSP
##
## Ends in an error in state: 69.
##
## par(fun_params) -> LPAR . fun_params RPAR [ LBRACE COLON ARROW ]
## par(fun_params) -> LPAR . fun_params PARAMS RPAR [ LBRACE COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function.
At this point, one of the following is expected:
  * the first parameter (variable);
  * a closing parenthesis ')' if no parameters.

interactive_expr: ES6FUN LPAR Ident ZWSP
##
## Ends in an error in state: 109.
##
## fun_param -> param_pattern . type_annotation(type_expr) [ RPAR PARAMS COMMA ]
## fun_param -> param_pattern . [ RPAR PARAMS COMMA ]
##
## The known suffix of the stack is as follows:
## param_pattern
##

Ill-formed function parameter.
At this point, one of the following is expected:
  * a comma ',' followed by another parameter;
  * a colon ':' followed by the type of the parameter;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: ES6FUN LPAR PARAMS ZWSP
##
## Ends in an error in state: 235.
##
## par(fun_params) -> LPAR fun_params PARAMS . RPAR [ LBRACE COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR fun_params PARAMS
##

Ill-formed function.
At this point, a closing parenthesis ')' is expected.

interactive_expr: ES6FUN LPAR Ident COLON Ident XOR
##
## Ends in an error in state: 237.
##
## nsepseq(fun_param,COMMA) -> fun_param . [ RPAR PARAMS ]
## nsepseq(fun_param,COMMA) -> fun_param . COMMA nsepseq(fun_param,COMMA) [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_param,COMMA)) -> fun_param . COMMA [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_param,COMMA)) -> fun_param . COMMA nseq(__anonymous_0(fun_param,COMMA)) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## fun_param
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 228, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 229, spurious reduction of production fun_param -> param_pattern type_annotation(type_expr)
##

Ill-formed function.
At this point, if the parameter is complete, one of the following is
expected:
  * a comma ',' followed by another parameter;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: ES6FUN LPAR Ident COMMA ZWSP
##
## Ends in an error in state: 238.
##
## nsepseq(fun_param,COMMA) -> fun_param COMMA . nsepseq(fun_param,COMMA) [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_param,COMMA)) -> fun_param COMMA . [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_param,COMMA)) -> fun_param COMMA . nseq(__anonymous_0(fun_param,COMMA)) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## fun_param COMMA
##

Ill-formed function.
At this point, one of the following is expected:
  * another parameter;
  * a closing parenthesis ')' otherwise.

interactive_expr: Function LT GT XOR
##
## Ends in an error in state: 241.
##
## function_expr -> Function type_vars . fun_par_params braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function type_vars . fun_par_params ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production gt -> GT
## In state 55, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) gt
## In state 256, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##

Ill-formed function expression.
At this point, an opening parenthesis '(' is expected.

interactive_expr: Function LT GT LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 243.
##
## function_expr -> Function type_vars fun_par_params . braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function type_vars fun_par_params . ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function type_vars fun_par_params
##
interactive_expr: Function LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 1169.
##
## function_expr -> Function fun_par_params . braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function fun_par_params . ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_par_params
##

Ill-formed function expression.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * a block of statements starting with an opening brace '{'.

interactive_expr: LT GT ES6FUN LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 485.
##
## arrow_fun_expr -> type_vars ES6FUN fun_par_params . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars ES6FUN fun_par_params . ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_par_params
##
interactive_expr: ES6FUN LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 515.
##
## arrow_fun_expr -> ES6FUN fun_par_params . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> ES6FUN fun_par_params . ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_par_params
##

Ill-formed arrow function.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * an arrow '=>' followed by the body.

interactive_expr: ES6FUN LPAR PARAMS RPAR COLON ZWSP
##
## Ends in an error in state: 486.
##
## type_annotation(__anonymous_6) -> COLON . option(ES6FUN) core_type [ LBRACE ARROW ]
##
## The known suffix of the stack is as follows:
## COLON
##
interactive_expr: ES6FUN LPAR PARAMS RPAR COLON ES6FUN ZWSP
##
## Ends in an error in state: 488.
##
## type_annotation(__anonymous_6) -> COLON option(ES6FUN) . core_type [ LBRACE ARROW ]
##
## The known suffix of the stack is as follows:
## COLON option(ES6FUN)
##

Ill-formed function.
At this point, a type (without parentheses) is expected.

interactive_expr: ES6FUN LPAR PARAMS RPAR COLON Attr ZWSP
##
## Ends in an error in state: 198.
##
## attr_type -> Attr . core_type [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated type.
At this point, one of the following is expected:
  * another decorator;
  * a type.

interactive_expr: Function LT GT LPAR PARAMS RPAR COLON Ident XOR
##
## Ends in an error in state: 1166.
##
## function_expr -> Function type_vars fun_par_params ret_type . braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function type_vars fun_par_params ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 489, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) core_type
## In state 492, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##
interactive_expr: Function LPAR PARAMS RPAR COLON Ident XOR
##
## Ends in an error in state: 1170.
##
## function_expr -> Function fun_par_params ret_type . braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_par_params ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 489, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) core_type
## In state 492, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##

Ill-formed function expression.
At this point, if the return type is complete, a block of statements
is expected to start with an opening brace '{'.

interactive_expr: ES6FUN ZWSP
##
## Ends in an error in state: 260.
##
## arrow_fun_expr -> ES6FUN . fun_par_params ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> ES6FUN . fun_par_params ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> ES6FUN . WILD ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> ES6FUN . Ident ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> ES6FUN . EIdent ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN
##
interactive_expr: LT GT XOR
##
## Ends in an error in state: 316.
##
## arrow_fun_expr -> type_vars . ES6FUN fun_par_params ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars . ES6FUN fun_par_params ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars . ES6FUN WILD ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars . ES6FUN Ident ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars . ES6FUN EIdent ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production gt -> GT
## In state 55, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) gt
## In state 256, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##
interactive_expr: LT GT ES6FUN ZWSP
##
## Ends in an error in state: 317.
##
## arrow_fun_expr -> type_vars ES6FUN . fun_par_params ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars ES6FUN . fun_par_params ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars ES6FUN . WILD ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars ES6FUN . Ident ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars ES6FUN . EIdent ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN
##

Ill-formed arrow function.
At this point, one of the following is expected:
  * an opening parenthesis '(' optionally followed by parameters;
  * a single parameter (variable).

interactive_expr: ES6FUN Ident ZWSP
##
## Ends in an error in state: 509.
##
## arrow_fun_expr -> ES6FUN Ident . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN Ident
##
interactive_expr: LT GT ES6FUN Ident ZWSP
##
## Ends in an error in state: 479.
##
## arrow_fun_expr -> type_vars ES6FUN Ident . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN Ident
##
interactive_expr: ES6FUN WILD ZWSP
##
## Ends in an error in state: 261.
##
## arrow_fun_expr -> ES6FUN WILD . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN WILD
##
interactive_expr: LT GT ES6FUN WILD ZWSP
##
## Ends in an error in state: 318.
##
## arrow_fun_expr -> type_vars ES6FUN WILD . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN WILD
##
interactive_expr: LT GT ES6FUN EIdent ZWSP
##
## Ends in an error in state: 482.
##
## arrow_fun_expr -> type_vars ES6FUN EIdent . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN EIdent
##
interactive_expr: ES6FUN EIdent ZWSP
##
## Ends in an error in state: 512.
##
## arrow_fun_expr -> ES6FUN EIdent . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN EIdent
##

Ill-formed arrow function.
At this point, an arrow '=>' is expected.

interactive_expr: ES6FUN Ident ARROW ZWSP
##
## Ends in an error in state: 510.
##
## arrow_fun_expr -> ES6FUN Ident ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN Ident ARROW
##
interactive_expr: LT GT ES6FUN Ident ARROW ZWSP
##
## Ends in an error in state: 480.
##
## arrow_fun_expr -> type_vars ES6FUN Ident ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN Ident ARROW
##
interactive_expr: LT GT ES6FUN LPAR RPAR COLON Ident ARROW ZWSP
##
## Ends in an error in state: 494.
##
## arrow_fun_expr -> type_vars ES6FUN fun_par_params ret_type ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_par_params ret_type ARROW
##
interactive_expr: ES6FUN LPAR RPAR COLON Ident ARROW ZWSP
##
## Ends in an error in state: 519.
##
## arrow_fun_expr -> ES6FUN fun_par_params ret_type ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_par_params ret_type ARROW
##
interactive_expr: LT GT ES6FUN LPAR PARAMS RPAR ARROW ZWSP
##
## Ends in an error in state: 490.
##
## arrow_fun_expr -> type_vars ES6FUN fun_par_params ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_par_params ARROW
##
interactive_expr: ES6FUN LPAR PARAMS RPAR ARROW ZWSP
##
## Ends in an error in state: 516.
##
## arrow_fun_expr -> ES6FUN fun_par_params ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_par_params ARROW
##
interactive_expr: ES6FUN WILD ARROW ZWSP
##
## Ends in an error in state: 262.
##
## arrow_fun_expr -> ES6FUN WILD ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN WILD ARROW
##
interactive_expr: LT GT ES6FUN WILD ARROW ZWSP
##
## Ends in an error in state: 319.
##
## arrow_fun_expr -> type_vars ES6FUN WILD ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN WILD ARROW
##
interactive_expr: LT GT ES6FUN EIdent ARROW ZWSP
##
## Ends in an error in state: 483.
##
## arrow_fun_expr -> type_vars ES6FUN EIdent ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN EIdent ARROW
##
interactive_expr: ES6FUN EIdent ARROW ZWSP
##
## Ends in an error in state: 513.
##
## arrow_fun_expr -> ES6FUN EIdent ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN EIdent ARROW
##

Ill-formed arrow function.
At this point, one of the following is expected:
  * the body as a non-record expression (use parentheses otherwise);
  * a block of statements starting with an opening brace '{'.

interactive_expr: ContractOf ZWSP
##
## Ends in an error in state: 269.
##
## contract_of_expr -> ContractOf . par(namespace_selection) [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## ContractOf
##

Ill-formed contract from a namespace.
At this point, an opening parenthesis '(' is expected.

interactive_expr: ContractOf LPAR ZWSP
##
## Ends in an error in state: 270.
##
## par(namespace_selection) -> LPAR . namespace_selection RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(namespace_selection) -> LPAR . namespace_selection PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed contract from a namespace.
At this point, a namespace name is expected.

interactive_expr: ContractOf LPAR UIdent ZWSP
##
## Ends in an error in state: 271.
##
## par(namespace_selection) -> LPAR namespace_selection . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(namespace_selection) -> LPAR namespace_selection . PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR namespace_selection
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 119, spurious reduction of production namespace_selection -> namespace_name
##
interactive_expr: ContractOf LPAR UIdent PARAMS ZWSP
##
## Ends in an error in state: 273.
##
## par(namespace_selection) -> LPAR namespace_selection PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR namespace_selection PARAMS
##

Ill-formed contract from a namespace.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Ident LBRACKET ZWSP
##
## Ends in an error in state: 6.
##
## brackets(Int) -> LBRACKET . Int RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Directive Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
## brackets(String) -> LBRACKET . String RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Directive Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed field selection.
At this point, one of the following is expected:
  * an integer denoting the field,
  * a string denoting the field.

interactive_expr: Ident LBRACKET String ZWSP
##
## Ends in an error in state: 7.
##
## brackets(String) -> LBRACKET String . RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Directive Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET String
##
interactive_expr: Ident LBRACKET Int ZWSP
##
## Ends in an error in state: 9.
##
## brackets(Int) -> LBRACKET Int . RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Directive Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET Int
##

Ill-formed field selection.
At this point, a closing bracket ']' is expected.

interactive_expr: Ident DOT ZWSP
##
## Ends in an error in state: 11.
##
## selection -> DOT . property_name [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Directive Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## DOT
##

Ill-formed field selection.
At this point, a field name is expected.

interactive_expr: UIdent DOT ZWSP
##
## Ends in an error in state: 289.
##
## namespace_path(selected_expr) -> namespace_name DOT . namespace_path(selected_expr) [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## namespace_path(selected_expr) -> namespace_name DOT . selected_expr [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## namespace_name DOT
##

Ill-formed namespace selection.
At this point, one of the following is expected:
  * a namespace name;
  * a string denoting a constructor;
  * a record or array.

interactive_expr: Attr ZWSP
##
## Ends in an error in state: 304.
##
## expr -> Attr . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated expression.
At this point, one of the following is expected:
  * another decorator;
  * an expression.

interactive_expr: Ident REM_EQ ZWSP
##
## Ends in an error in state: 351.
##
## bin_op(left_hs,REM_EQ,expr) -> left_hs REM_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs REM_EQ
##
interactive_expr: Ident PLUS_EQ ZWSP
##
## Ends in an error in state: 452.
##
## bin_op(left_hs,PLUS_EQ,expr) -> left_hs PLUS_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs PLUS_EQ
##
interactive_expr: Ident MULT_EQ ZWSP
##
## Ends in an error in state: 454.
##
## bin_op(left_hs,MULT_EQ,expr) -> left_hs MULT_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs MULT_EQ
##
interactive_expr: Ident MINUS_EQ ZWSP
##
## Ends in an error in state: 456.
##
## bin_op(left_hs,MINUS_EQ,expr) -> left_hs MINUS_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs MINUS_EQ
##
interactive_expr: Ident EQ ZWSP
##
## Ends in an error in state: 458.
##
## bin_op(left_hs,EQ,expr) -> left_hs EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs EQ
##
interactive_expr: Ident DIV_EQ ZWSP
##
## Ends in an error in state: 460.
##
## bin_op(left_hs,DIV_EQ,expr) -> left_hs DIV_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs DIV_EQ
##
interactive_expr: Ident BIT_XOR_EQ ZWSP
##
## Ends in an error in state: 462.
##
## bin_op(left_hs,BIT_XOR_EQ,expr) -> left_hs BIT_XOR_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs BIT_XOR_EQ
##
interactive_expr: Ident BIT_SR_EQ ZWSP
##
## Ends in an error in state: 464.
##
## bin_op(left_hs,BIT_SR_EQ,expr) -> left_hs BIT_SR_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs BIT_SR_EQ
##
interactive_expr: Ident BIT_SL_EQ ZWSP
##
## Ends in an error in state: 466.
##
## bin_op(left_hs,BIT_SL_EQ,expr) -> left_hs BIT_SL_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs BIT_SL_EQ
##
interactive_expr: Ident BIT_OR_EQ ZWSP
##
## Ends in an error in state: 468.
##
## bin_op(left_hs,BIT_OR_EQ,expr) -> left_hs BIT_OR_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs BIT_OR_EQ
##
interactive_expr: Ident BIT_AND_EQ ZWSP
##
## Ends in an error in state: 470.
##
## bin_op(left_hs,BIT_AND_EQ,expr) -> left_hs BIT_AND_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs BIT_AND_EQ
##

Ill-formed assigment.
At this point, the right-hand side is expected as an expression.

interactive_expr: LT GT ES6FUN LPAR PARAMS RPAR COLON Ident XOR
##
## Ends in an error in state: 493.
##
## arrow_fun_expr -> type_vars ES6FUN fun_par_params ret_type . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_par_params ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 489, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) core_type
## In state 492, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##
interactive_expr: ES6FUN LPAR PARAMS RPAR COLON Ident XOR
##
## Ends in an error in state: 518.
##
## arrow_fun_expr -> ES6FUN fun_par_params ret_type . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_par_params ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 489, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) core_type
## In state 492, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##

Ill-formed arrow function.
At this point, if the return type is complete, an arrow '=>' is
expected.

interactive_expr: LBRACE Attr ZWSP
##
## Ends in an error in state: 1175.
##
## property(expr) -> Attr . property(expr) [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated field.
At this point, one of the following is expected:
  * another decorator;
  * a field without decorator.

interactive_expr: LBRACE Ident ZWSP
##
## Ends in an error in state: 1176.
##
## property(expr) -> property_id . [ SEMI RBRACE COMMA ]
## property(expr) -> property_id . COLON expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id
##

Ill-formed record.
At this point, one of the following is expected:
  * a colon ':' followed by an expression;
  * a field separator (';' or ',') if name punning;
  * a closing brace '}' if no more fields.

interactive_expr: LBRACE Ident COLON ZWSP
##
## Ends in an error in state: 1177.
##
## property(expr) -> property_id COLON . expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id COLON
##

Ill-formed record.
At this point, an expression is expected for the field.

interactive_expr: LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 1183.
##
## nsepseq(property(expr),property_sep) -> property(expr) property_sep . nsepseq(property(expr),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property(expr),property_sep)) -> property(expr) property_sep . [ RBRACE ]
## nseq(__anonymous_0(property(expr),property_sep)) -> property(expr) property_sep . nseq(__anonymous_0(property(expr),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property(expr) property_sep
##

Ill-formed record.
At this point, one of the following is expected:
  * a field;
  * a closing brace '}' if no more fields.

interactive_expr: LBRACKET ELLIPSIS ZWSP
##
## Ends in an error in state: 1193.
##
## element(expr) -> ELLIPSIS . expr [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed array.
At this point, and expression denoting an array is expected.

contract: Namespace UIdent LBRACE Switch ZWSP
##
## Ends in an error in state: 257.
##
## switch_stmt -> Switch . par(switch_subject) braces(cases) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Switch
##

Ill-formed switch.
At this point, an opening parenthesis '(' is expected, followed by an
expression.

contract: Namespace UIdent LBRACE Switch LPAR ZWSP
##
## Ends in an error in state: 258.
##
## par(switch_subject) -> LPAR . switch_subject RPAR [ LBRACE ]
## par(switch_subject) -> LPAR . switch_subject PARAMS RPAR [ LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed switch.
At this point, the expression used to switch is expected.

contract: Let ZWSP
##
## Ends in an error in state: 586.
##
## value_decl -> Let . bindings [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Let
##

Ill-formed value declaration.
At this point, a pattern is expected, e.g. a variable.

contract: Const Bytes ZWSP
##
## Ends in an error in state: 663.
##
## val_binding -> pattern . EQ expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA Break Attr ]
## val_binding -> pattern . binding_type EQ expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA Break Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the type of the value;
  * the assignment symbol '=' followed by an expression.

contract: Const Bytes COLON ZWSP
##
## Ends in an error in state: 549.
##
## type_annotation(gen_type_expr) -> COLON . gen_type_expr [ SEMI RBRACE EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, one of the following is expected:
  * a type;
  * an opening chevron '<' followed by type variables if the type is
    generic.

contract: Const Bytes COLON LT GT XOR
##
## Ends in an error in state: 550.
##
## gen_type_expr -> type_vars . type_expr [ SEMI RBRACE EQ ]
##
## The known suffix of the stack is as follows:
## type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production gt -> GT
## In state 55, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) gt
## In state 256, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##

Ill-formed generic type annotation.
At this point, if the type variables are complete, a type is expected.

contract: Const Bytes COLON Ident XOR
##
## Ends in an error in state: 666.
##
## val_binding -> pattern binding_type . EQ expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA Break Attr ]
##
## The known suffix of the stack is as follows:
## pattern binding_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 552, spurious reduction of production gen_type_expr -> type_expr
## In state 553, spurious reduction of production type_annotation(gen_type_expr) -> COLON gen_type_expr
## In state 554, spurious reduction of production binding_type -> type_annotation(gen_type_expr)
##

Ill-formed value declaration.
At this point, if the type is complete, the assignment symbol '=' is
expected, followed by an expression.

interactive_expr: Bytes WILD
##
## Ends in an error in state: 1250.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
##

Ill-formed expression.
At this point, if the expression is complete, the end of the input is
expected.

contract: Bytes LPAR RPAR ZWSP
##
## Ends in an error in state: 1245.
##
## contract -> statements . EOF [ # ]
##
## The known suffix of the stack is as follows:
## statements
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 365, spurious reduction of production app_expr -> call_expr
## In state 878, spurious reduction of production expr_stmt -> app_expr
## In state 925, spurious reduction of production non_if_stmt(statement) -> expr_stmt
## In state 907, spurious reduction of production statement -> non_if_stmt(statement)
## In state 1121, spurious reduction of production last_or_more(statement) -> statement
## In state 1126, spurious reduction of production statements -> last_or_more(statement)
##

Ill-formed contract.
At this point, if the statement is complete, one of the following is
expected:
  * a semicolon ';' followed by another statement;
  * a statement;
  * the end of the contract.

contract: Interface ZWSP
##
## Ends in an error in state: 672.
##
## interface_decl -> Interface . interface_name interface_body [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## interface_decl -> Interface . interface_name extends interface_body [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Interface
##

Ill-formed interface declaration.
At this point, the name of the interface is expected.

contract: Interface UIdent ZWSP
##
## Ends in an error in state: 674.
##
## interface_decl -> Interface interface_name . interface_body [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## interface_decl -> Interface interface_name . extends interface_body [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Interface interface_name
##

Ill-formed interface declaration.
At this point, one of the following is expected:
  * an opening brace '{' is expected, followed by entries;
  * the keyword 'extends'.

contract: Interface UIdent LBRACE ZWSP
##
## Ends in an error in state: 537.
##
## braces(interface_entries) -> LBRACE . interface_entries RBRACE [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed interface.
At this point, one of the following is expected:
  * the keyword 'type' to define a type;
  * the keyword 'const' to define a constant;
  * a decorator for the above.

contract: Interface UIdent LBRACE Type ZWSP
##
## Ends in an error in state: 538.
##
## interface_type -> Type . type_name EQ type_expr [ SEMI RBRACE ]
## interface_type -> Type . type_name type_vars EQ type_expr [ SEMI RBRACE ]
## interface_type -> Type . type_name [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed interface.
At this point, a type name is expected.

contract: Interface UIdent LBRACE Type Ident ZWSP
##
## Ends in an error in state: 539.
##
## interface_type -> Type type_name . EQ type_expr [ SEMI RBRACE ]
## interface_type -> Type type_name . type_vars EQ type_expr [ SEMI RBRACE ]
## interface_type -> Type type_name . [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Type type_name
##

Ill-formed type declaration in an interface.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by a type;
  * type parameters (variables) between chevrons ('<', '>') if the
    type is generic.
  * a semicolon ';' followed by another entry;
  * a closing brace '}' if no more entries.

contract: Interface UIdent LBRACE Type Ident EQ ZWSP
##
## Ends in an error in state: 540.
##
## interface_type -> Type type_name EQ . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Type type_name EQ
##

Ill-formed interface.
At this point, a type is expected.

contract: Interface UIdent LBRACE Const ZWSP
##
## Ends in an error in state: 545.
##
## interface_const -> Const . WILD option(QMARK) binding_type [ SEMI RBRACE ]
## interface_const -> Const . Ident option(QMARK) binding_type [ SEMI RBRACE ]
## interface_const -> Const . EIdent option(QMARK) binding_type [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const
##

Ill-formed value declaration in an interface.
At this point, the name of the constant is expected.

contract: Interface UIdent LBRACE Const Ident ZWSP
##
## Ends in an error in state: 556.
##
## interface_const -> Const Ident . option(QMARK) binding_type [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const Ident
##
contract: Interface UIdent LBRACE Const WILD ZWSP
##
## Ends in an error in state: 546.
##
## interface_const -> Const WILD . option(QMARK) binding_type [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const WILD
##
contract: Interface UIdent LBRACE Const EIdent ZWSP
##
## Ends in an error in state: 559.
##
## interface_const -> Const EIdent . option(QMARK) binding_type [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const EIdent
##

Ill-formed value declarations in an interface.
At this point, one of the following is expected:
  * a colon ':', followed by the type of the value.
  * a question mark '?', marking the declaration as optional.

contract: Interface UIdent LBRACE Const WILD QMARK ZWSP
##
## Ends in an error in state: 548.
##
## interface_const -> Const WILD option(QMARK) . binding_type [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const WILD option(QMARK)
##
contract: Interface UIdent LBRACE Const Ident QMARK ZWSP
##
## Ends in an error in state: 557.
##
## interface_const -> Const Ident option(QMARK) . binding_type [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const Ident option(QMARK)
##
contract: Interface UIdent LBRACE Const EIdent QMARK ZWSP
##
## Ends in an error in state: 560.
##
## interface_const -> Const EIdent option(QMARK) . binding_type [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const EIdent option(QMARK)
##

Ill-formed value declaration in an interface.
At this point, a colon ':' is expected, followed by the type of the
value.

contract: Interface UIdent LBRACE Attr ZWSP
##
## Ends in an error in state: 562.
##
## interface_entry -> Attr . interface_entry [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated declaration in an interface.
At this point, one of the following is expected:
  * another decorator;
  * a declaration without a decorator (starting with 'type' or
    'const').

contract: Interface UIdent LBRACE Const Ident COLON Ident XOR
##
## Ends in an error in state: 570.
##
## nsepseq(interface_entry,SEMI) -> interface_entry . [ RBRACE ]
## nsepseq(interface_entry,SEMI) -> interface_entry . SEMI nsepseq(interface_entry,SEMI) [ RBRACE ]
## nseq(__anonymous_0(interface_entry,SEMI)) -> interface_entry . SEMI [ RBRACE ]
## nseq(__anonymous_0(interface_entry,SEMI)) -> interface_entry . SEMI nseq(__anonymous_0(interface_entry,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## interface_entry
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 552, spurious reduction of production gen_type_expr -> type_expr
## In state 553, spurious reduction of production type_annotation(gen_type_expr) -> COLON gen_type_expr
## In state 554, spurious reduction of production binding_type -> type_annotation(gen_type_expr)
## In state 558, spurious reduction of production interface_const -> Const Ident option(QMARK) binding_type
## In state 565, spurious reduction of production interface_entry -> interface_const
##

Ill-formed interface.
At this point, if the declaration is complete, one of the following is
expected:
  * a semicolon ';' followed by another declaration ('type' or 'const');
  * a closing brace '}' if no more declarations.

contract: Interface UIdent LBRACE Type Ident SEMI ZWSP
##
## Ends in an error in state: 571.
##
## nsepseq(interface_entry,SEMI) -> interface_entry SEMI . nsepseq(interface_entry,SEMI) [ RBRACE ]
## nseq(__anonymous_0(interface_entry,SEMI)) -> interface_entry SEMI . [ RBRACE ]
## nseq(__anonymous_0(interface_entry,SEMI)) -> interface_entry SEMI . nseq(__anonymous_0(interface_entry,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## interface_entry SEMI
##

Ill-formed interface.
At this point, one of the following is expected:
  * a declaration starting with the keyword 'type' or 'const';
  * a closing brace '}' if no more declarations.

contract: Import ZWSP
##
## Ends in an error in state: 680.
##
## import_decl -> Import . namespace_name EQ namespace_selection [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
## import_decl -> Import . TIMES As namespace_name From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
## import_decl -> Import . braces(sep_or_term(variable,COMMA)) From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import
##

Ill-formed import declaration.
At this point, one of the following is expected:
  * a namespace name if aliasing a namespace;
  * the symbol '*' to import all entries from a namespace;
  * an opening brace '{' to import a list of entries.

contract: Import TIMES ZWSP
##
## Ends in an error in state: 681.
##
## import_decl -> Import TIMES . As namespace_name From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import TIMES
##

Ill-formed import declaration.
At this point, the keyword 'as' is expected.

contract: Import TIMES As ZWSP
##
## Ends in an error in state: 682.
##
## import_decl -> Import TIMES As . namespace_name From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import TIMES As
##

Ill-formed import declaration.
At this point, the name of the namespace is expected.

contract: Import TIMES As UIdent ZWSP
##
## Ends in an error in state: 683.
##
## import_decl -> Import TIMES As namespace_name . From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import TIMES As namespace_name
##
contract: Import LBRACE RBRACE ZWSP
##
## Ends in an error in state: 708.
##
## import_decl -> Import braces(sep_or_term(variable,COMMA)) . From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import braces(sep_or_term(variable,COMMA))
##

Ill-formed import declaration.
At this point, the keyword 'from' is expected.

contract: Import TIMES As UIdent From ZWSP
##
## Ends in an error in state: 684.
##
## import_decl -> Import TIMES As namespace_name From . file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import TIMES As namespace_name From
##
contract: Import LBRACE RBRACE From ZWSP
##
## Ends in an error in state: 709.
##
## import_decl -> Import braces(sep_or_term(variable,COMMA)) From . file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import braces(sep_or_term(variable,COMMA)) From
##

Ill-formed import declaration.
At this point, a file path to a LIGO source is expected as a string.

contract: Import LBRACE ZWSP
##
## Ends in an error in state: 687.
##
## braces(sep_or_term(variable,COMMA)) -> LBRACE . sep_or_term(variable,COMMA) RBRACE [ From ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed import declaration.
At this point, the name of an imported type or value is expected.

contract: Import LBRACE WILD ZWSP
##
## Ends in an error in state: 688.
##
## nsepseq(variable,COMMA) -> WILD . [ RBRACE ]
## nsepseq(variable,COMMA) -> WILD . COMMA nsepseq(variable,COMMA) [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> WILD . COMMA [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> WILD . COMMA nseq(__anonymous_0(variable,COMMA)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## WILD
##
contract: Import LBRACE Ident ZWSP
##
## Ends in an error in state: 690.
##
## nsepseq(variable,COMMA) -> Ident . [ RBRACE ]
## nsepseq(variable,COMMA) -> Ident . COMMA nsepseq(variable,COMMA) [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> Ident . COMMA [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> Ident . COMMA nseq(__anonymous_0(variable,COMMA)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##
contract: Import LBRACE EIdent ZWSP
##
## Ends in an error in state: 692.
##
## nsepseq(variable,COMMA) -> EIdent . [ RBRACE ]
## nsepseq(variable,COMMA) -> EIdent . COMMA nsepseq(variable,COMMA) [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> EIdent . COMMA [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> EIdent . COMMA nseq(__anonymous_0(variable,COMMA)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## EIdent
##

Ill-formed import declaration.
At this point, one of the following is expected:
  * a comma ',' followed by the name of an imported type or value;
  * a closing brace '}' if no more imports.

contract: Import LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 691.
##
## nsepseq(variable,COMMA) -> Ident COMMA . nsepseq(variable,COMMA) [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> Ident COMMA . [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> Ident COMMA . nseq(__anonymous_0(variable,COMMA)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident COMMA
##
contract: Import LBRACE EIdent COMMA ZWSP
##
## Ends in an error in state: 693.
##
## nsepseq(variable,COMMA) -> EIdent COMMA . nsepseq(variable,COMMA) [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> EIdent COMMA . [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> EIdent COMMA . nseq(__anonymous_0(variable,COMMA)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## EIdent COMMA
##
contract: Import LBRACE WILD COMMA ZWSP
##
## Ends in an error in state: 689.
##
## nsepseq(variable,COMMA) -> WILD COMMA . nsepseq(variable,COMMA) [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> WILD COMMA . [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> WILD COMMA . nseq(__anonymous_0(variable,COMMA)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## WILD COMMA
##

Ill-formed import declaration.
At this point, one of the following is expected:
  * the name of an imported type or value;
  * a closing brace '}' if no more imports.

contract: Import UIdent ZWSP
##
## Ends in an error in state: 705.
##
## import_decl -> Import namespace_name . EQ namespace_selection [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import namespace_name
##

Ill-formed import declaration.
At this point, the assignment symbol '=' is expected.

contract: Import UIdent EQ ZWSP
##
## Ends in an error in state: 706.
##
## import_decl -> Import namespace_name EQ . namespace_selection [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import namespace_name EQ
##

Ill-formed import declaration.
At this point, a namespace name is expected.

contract: Namespace UIdent LBRACE If ZWSP
##
## Ends in an error in state: 711.
##
## if_else_stmt(catenable_stmt) -> If . par(if_cond) closed_non_if_stmt Else catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(catenable_stmt) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt Else stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_else_stmt(stmt_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_stmt(catenable_stmt) -> If . par(if_cond) catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_ending_with_expr) -> If . par(if_cond) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##
contract: Namespace UIdent LBRACE Return If ZWSP
##
## Ends in an error in state: 1068.
##
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt Else stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> If . par(if_cond) closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_stmt(statement) -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> If . par(if_cond) stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##
contract: If LPAR Bytes RPAR If ZWSP
##
## Ends in an error in state: 721.
##
## if_else_stmt(catenable_stmt) -> If . par(if_cond) closed_non_if_stmt Else catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(catenable_stmt) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(closed_non_if_stmt) -> If . par(if_cond) closed_non_if_stmt Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt Else stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_else_stmt(stmt_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_stmt(catenable_stmt) -> If . par(if_cond) catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_ending_with_expr) -> If . par(if_cond) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##
contract: Return If LPAR Bytes RPAR If ZWSP
##
## Ends in an error in state: 999.
##
## if_else_stmt(__anonymous_5) -> If . par(if_cond) closed_non_if_stmt Else type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(__anonymous_5) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(closed_non_if_stmt) -> If . par(if_cond) closed_non_if_stmt Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(export(type_decl)) -> If . par(if_cond) closed_non_if_stmt Else export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(export(type_decl)) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt Else stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(__anonymous_5) -> If . par(if_cond) type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(export(type_decl)) -> If . par(if_cond) export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##
contract: Return While LPAR Bytes RPAR If ZWSP
##
## Ends in an error in state: 995.
##
## if_else_stmt(__anonymous_5) -> If . par(if_cond) closed_non_if_stmt Else type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(__anonymous_5) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(export(type_decl)) -> If . par(if_cond) closed_non_if_stmt Else export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(export(type_decl)) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt Else stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(__anonymous_5) -> If . par(if_cond) type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(export(type_decl)) -> If . par(if_cond) export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_not_ending_with_expr) -> If . par(if_cond) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional statement.
At this point, an opening parenthesis '(' is expected, followed by the
condition.

contract: Namespace UIdent LBRACE If LPAR ZWSP
##
## Ends in an error in state: 712.
##
## par(if_cond) -> LPAR . if_cond RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## par(if_cond) -> LPAR . if_cond PARAMS RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed conditional statement.
At this point, the condition is expected as a boolean expression.

contract: Function ZWSP
##
## Ends in an error in state: 723.
##
## fun_decl -> Function . fun_name option(ES6FUN) par(fun_params) braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function . fun_name option(ES6FUN) par(fun_params) ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function . fun_name type_vars option(ES6FUN) par(fun_params) braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function . fun_name type_vars option(ES6FUN) par(fun_params) ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function
##

Ill-formed function declaration.
At this point, the function name is expected.

contract: Function Ident ZWSP
##
## Ends in an error in state: 728.
##
## fun_decl -> Function fun_name . option(ES6FUN) par(fun_params) braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function fun_name . option(ES6FUN) par(fun_params) ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function fun_name . type_vars option(ES6FUN) par(fun_params) braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function fun_name . type_vars option(ES6FUN) par(fun_params) ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_name
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * an opening parenthesis '(' optionally followed by parameters;
  * an opening chevron '<' optionally followed by type parameters.

contract: Function Ident LT GT XOR
##
## Ends in an error in state: 729.
##
## fun_decl -> Function fun_name type_vars . option(ES6FUN) par(fun_params) braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function fun_name type_vars . option(ES6FUN) par(fun_params) ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_name type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production gt -> GT
## In state 55, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) gt
## In state 256, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##
contract: Function Ident LT GT ES6FUN ZWSP
##
## Ends in an error in state: 730.
##
## fun_decl -> Function fun_name type_vars option(ES6FUN) . par(fun_params) braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function fun_name type_vars option(ES6FUN) . par(fun_params) ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_name type_vars option(ES6FUN)
##
contract: Function Ident ES6FUN ZWSP
##
## Ends in an error in state: 735.
##
## fun_decl -> Function fun_name option(ES6FUN) . par(fun_params) braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function fun_name option(ES6FUN) . par(fun_params) ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_name option(ES6FUN)
##

Ill-formed function declaration.
At this point, an opening parenthesis '(' is expected.

contract: Function Ident LT GT LPAR RPAR ZWSP
##
## Ends in an error in state: 731.
##
## fun_decl -> Function fun_name type_vars option(ES6FUN) par(fun_params) . braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function fun_name type_vars option(ES6FUN) par(fun_params) . ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_name type_vars option(ES6FUN) par(fun_params)
##
contract: Function Ident LPAR RPAR ZWSP
##
## Ends in an error in state: 736.
##
## fun_decl -> Function fun_name option(ES6FUN) par(fun_params) . braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## fun_decl -> Function fun_name option(ES6FUN) par(fun_params) . ret_type braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_name option(ES6FUN) par(fun_params)
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * the body as a block of statements starting with an opening brace
    '{'.

contract: Function Ident LT GT LPAR RPAR COLON Ident XOR
##
## Ends in an error in state: 732.
##
## fun_decl -> Function fun_name type_vars option(ES6FUN) par(fun_params) ret_type . braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_name type_vars option(ES6FUN) par(fun_params) ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 489, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) core_type
## In state 492, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##
contract: Function Ident LPAR RPAR COLON Ident XOR
##
## Ends in an error in state: 737.
##
## fun_decl -> Function fun_name option(ES6FUN) par(fun_params) ret_type . braces(statements) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_name option(ES6FUN) par(fun_params) ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 489, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) core_type
## In state 492, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##

Ill-formed function declaration.
At this point, if the return type is complete, the body is expected as
a block of statements starting with an opening brace '{'.

contract: Namespace UIdent LBRACE For LPAR ZWSP
##
## Ends in an error in state: 741.
##
## par(range_for) -> LPAR . range_for RPAR [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## par(range_for) -> LPAR . range_for PARAMS RPAR [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## par(range_of) -> LPAR . range_of RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## par(range_of) -> LPAR . range_of PARAMS RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed for-loop.
At this point, one of the following is expected:
  * the initialisation as a statement;
  * a semicolon ';' if no initialisation;
  * the keywords 'const' or 'let' followed by a variable.

contract: Namespace UIdent LBRACE For LPAR SEMI ZWSP
##
## Ends in an error in state: 742.
##
## range_for -> SEMI . SEMI [ RPAR PARAMS ]
## range_for -> SEMI . SEMI afterthought [ RPAR PARAMS ]
## range_for -> SEMI . condition SEMI [ RPAR PARAMS ]
## range_for -> SEMI . condition SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## SEMI
##

Ill-formed for-loop.
At this point, one of the following is expected:
  * the invariant as a boolean expression;
  * a semicolon ';' if no condition.

contract: Match LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 1211.
##
## match_expr -> Match match_subject . braces(match_clauses) [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## Match match_subject
##

Ill-formed pattern matching.
At this point, an opening brace '{' is expected.

contract: Match LPAR Bytes RPAR LBRACE ZWSP
##
## Ends in an error in state: 1212.
##
## braces(match_clauses) -> LBRACE . match_clauses RBRACE [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed pattern matching.
At this point, one of the following is expected:
  * the keyword 'when' for a normal clause;
  * the keyword 'default' for the default clause.

contract: Match LPAR Bytes RPAR LBRACE When ZWSP
##
## Ends in an error in state: 1213.
##
## match_clause -> When . par(when_pattern) COLON expr [ When RBRACE Default ]
## match_clause -> When . par(when_pattern) COLON expr SEMI [ When RBRACE Default ]
##
## The known suffix of the stack is as follows:
## When
##

Ill-formed pattern matching.
At this point, a pattern is expected between parentheses.

contract: Match LPAR Bytes RPAR LBRACE When LPAR ZWSP
##
## Ends in an error in state: 1214.
##
## par(when_pattern) -> LPAR . when_pattern RPAR [ COLON ]
## par(when_pattern) -> LPAR . when_pattern PARAMS RPAR [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern matching.
At this point, a pattern for the clause is expected.

contract: Match LPAR Bytes RPAR LBRACE When LPAR Bytes ZWSP
##
## Ends in an error in state: 1220.
##
## typed_pattern -> pattern . type_annotation(type_expr) [ RPAR PARAMS ]
## when_pattern -> pattern . [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## pattern
##

Ill-formed pattern matching.
At this point, one of the following is expected:
  * a colon ':' followed by a type for the pattern;
  * a closing parenthesis ')' if the pattern is complete;

contract: Match LPAR Bytes RPAR LBRACE When LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 1217.
##
## par(when_pattern) -> LPAR when_pattern PARAMS . RPAR [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR when_pattern PARAMS
##

Ill-formed pattern matching.
At this point, a closing parenthesis ')' is expected.

contract: Match LPAR Bytes RPAR LBRACE When LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 1222.
##
## match_clause -> When par(when_pattern) . COLON expr [ When RBRACE Default ]
## match_clause -> When par(when_pattern) . COLON expr SEMI [ When RBRACE Default ]
##
## The known suffix of the stack is as follows:
## When par(when_pattern)
##
contract: Match LPAR Bytes RPAR LBRACE Default ZWSP
##
## Ends in an error in state: 1226.
##
## match_default -> Default . COLON expr [ RBRACE ]
## match_default -> Default . COLON expr SEMI [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default
##

Ill-formed pattern matching.
At this point, a colon ':' is expected, followed by an expression.

contract: Match LPAR Bytes RPAR LBRACE When LPAR Bytes RPAR COLON ZWSP
##
## Ends in an error in state: 1223.
##
## match_clause -> When par(when_pattern) COLON . expr [ When RBRACE Default ]
## match_clause -> When par(when_pattern) COLON . expr SEMI [ When RBRACE Default ]
##
## The known suffix of the stack is as follows:
## When par(when_pattern) COLON
##
contract: Match LPAR Bytes RPAR LBRACE Default COLON ZWSP
##
## Ends in an error in state: 1227.
##
## match_default -> Default COLON . expr [ RBRACE ]
## match_default -> Default COLON . expr SEMI [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default COLON
##

Ill-formed pattern matching.
At this point, the case clause is expected as an expression.

interactive_expr: Bytes As LBRACE ZWSP
##
## Ends in an error in state: 126.
##
## braces(sep_or_term(property_decl,property_sep)) -> LBRACE . sep_or_term(property_decl,property_sep) RBRACE [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record type.
At this point, one of the following is expected:
  * a field name,
  * an integer denoting the field,
  * a string denoting the field.

interactive_expr: Bytes As LBRACE Ident ZWSP
##
## Ends in an error in state: 128.
##
## property_decl -> property_id . [ SEMI RBRACE COMMA ]
## property_decl -> property_id . type_annotation(type_expr) [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id
##

Ill-formed record type.
At this point, one of the following is expected:
  * a field separator (',' or ';');
  * a closing brace '}' if no more fields;
  * a colon ':' followed by the type of the field.

interactive_expr: Bytes As LBRACE Ident COLON Ident XOR
##
## Ends in an error in state: 133.
##
## nsepseq(property_decl,property_sep) -> property_decl . [ RBRACE ]
## nsepseq(property_decl,property_sep) -> property_decl . property_sep nsepseq(property_decl,property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_decl,property_sep)) -> property_decl . property_sep [ RBRACE ]
## nseq(__anonymous_0(property_decl,property_sep)) -> property_decl . property_sep nseq(__anonymous_0(property_decl,property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 228, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 129, spurious reduction of production property_decl -> property_id type_annotation(type_expr)
##

Ill-formed record type.
At this point, one of the following is expected:
  * a field separator (';' or ',') followed by another field;
  * a closing brace '}' if no more fields.

interactive_expr: Bytes As LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 134.
##
## nsepseq(property_decl,property_sep) -> property_decl property_sep . nsepseq(property_decl,property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_decl,property_sep)) -> property_decl property_sep . [ RBRACE ]
## nseq(__anonymous_0(property_decl,property_sep)) -> property_decl property_sep . nseq(__anonymous_0(property_decl,property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_decl property_sep
##

Ill-formed record type.
At this point, one of the following is expected:
  * another field declaration;
  * a closing brace '}' if no more fields.

interactive_expr: Bytes As ParameterOf ZWSP
##
## Ends in an error in state: 115.
##
## parameter_of_type -> ParameterOf . namespace_selection [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## ParameterOf
##

Ill-formed parameter of a contract.
At this point, a namespace name is expected.

interactive_expr: Bytes As LPAR ZWSP
##
## Ends in an error in state: 124.
##
## par(type_expr) -> LPAR . type_expr RPAR [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
## par(type_expr) -> LPAR . type_expr PARAMS RPAR [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised type.
At this point, a type is expected.

interactive_expr: Bytes As ES6FUN ZWSP
##
## Ends in an error in state: 142.
##
## fun_type -> ES6FUN . par(fun_type_params) ARROW type_expr [ While When WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN
##

Ill-formed function type.
At this point, an opening parenthesis '(' is expected.

interactive_expr: Bytes As ES6FUN LPAR ZWSP
##
## Ends in an error in state: 143.
##
## par(fun_type_params) -> LPAR . fun_type_params RPAR [ ARROW ]
## par(fun_type_params) -> LPAR . fun_type_params PARAMS RPAR [ ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function type.
At this point, one of the following is expected:
  * the first parameter (variable);
  * a closing parenthesis ')' if no parameters.

interactive_expr: Bytes As ES6FUN LPAR Ident ZWSP
##
## Ends in an error in state: 146.
##
## fun_type_param -> Ident . type_annotation(type_expr) [ RPAR PARAMS COMMA ]
##
## The known suffix of the stack is as follows:
## Ident
##
contract: Bytes As ES6FUN LPAR WILD ZWSP
##
## Ends in an error in state: 144.
##
## fun_type_param -> WILD . type_annotation(type_expr) [ RPAR PARAMS COMMA ]
##
## The known suffix of the stack is as follows:
## WILD
##
contract: Bytes As ES6FUN LPAR EIdent ZWSP
##
## Ends in an error in state: 148.
##
## fun_type_param -> EIdent . type_annotation(type_expr) [ RPAR PARAMS COMMA ]
##
## The known suffix of the stack is as follows:
## EIdent
##

Ill-formed function type.
At this point, a colon ':' is expected, followed by the type of the
parameter.

interactive_expr: Bytes As ES6FUN LPAR PARAMS ZWSP
##
## Ends in an error in state: 156.
##
## par(fun_type_params) -> LPAR fun_type_params PARAMS . RPAR [ ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR fun_type_params PARAMS
##

Ill-formed function type.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Bytes As ES6FUN LPAR Ident COLON Ident XOR
##
## Ends in an error in state: 158.
##
## nsepseq(fun_type_param,COMMA) -> fun_type_param . [ RPAR PARAMS ]
## nsepseq(fun_type_param,COMMA) -> fun_type_param . COMMA nsepseq(fun_type_param,COMMA) [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_type_param,COMMA)) -> fun_type_param . COMMA [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_type_param,COMMA)) -> fun_type_param . COMMA nseq(__anonymous_0(fun_type_param,COMMA)) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## fun_type_param
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 228, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 147, spurious reduction of production fun_type_param -> Ident type_annotation(type_expr)
##

Ill-formed function type.
At this point, if the parameter type is complete, one of the following
is expected:
  * a comma ',' followed by another parameter type;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: Bytes As ES6FUN LPAR Ident COLON Ident COMMA ZWSP
##
## Ends in an error in state: 159.
##
## nsepseq(fun_type_param,COMMA) -> fun_type_param COMMA . nsepseq(fun_type_param,COMMA) [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_type_param,COMMA)) -> fun_type_param COMMA . [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_type_param,COMMA)) -> fun_type_param COMMA . nseq(__anonymous_0(fun_type_param,COMMA)) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## fun_type_param COMMA
##

Ill-formed function type.
At this point, one of the following is expected:
  * another parameter as a variable;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: Bytes As ES6FUN LPAR RPAR ZWSP
##
## Ends in an error in state: 162.
##
## fun_type -> ES6FUN par(fun_type_params) . ARROW type_expr [ While When WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN par(fun_type_params)
##

Ill-formed function type.
At this point, an arrow '=>' is expected, followed by the return type.

interactive_expr: Bytes As ES6FUN LPAR RPAR ARROW ZWSP
##
## Ends in an error in state: 163.
##
## fun_type -> ES6FUN par(fun_type_params) ARROW . type_expr [ While When WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN par(fun_type_params) ARROW
##

Ill-formed function type.
At this point, the return type is expected.

interactive_expr: Bytes As Ident LT ZWSP
##
## Ends in an error in state: 169.
##
## chevrons(nsep_or_term(type_ctor_arg,COMMA)) -> LT . nsep_or_term(type_ctor_arg,COMMA) gt [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LT
##

Ill-formed generic type instantiation.
At this point, a type is expected.

interactive_expr: Bytes As Ident LT Ident XOR
##
## Ends in an error in state: 172.
##
## nsepseq(type_ctor_arg,COMMA) -> type_ctor_arg . [ GT ]
## nsepseq(type_ctor_arg,COMMA) -> type_ctor_arg . COMMA nsepseq(type_ctor_arg,COMMA) [ GT ]
## nseq(__anonymous_0(type_ctor_arg,COMMA)) -> type_ctor_arg . COMMA [ GT ]
## nseq(__anonymous_0(type_ctor_arg,COMMA)) -> type_ctor_arg . COMMA nseq(__anonymous_0(type_ctor_arg,COMMA)) [ GT ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 171, spurious reduction of production type_ctor_arg -> type_expr
##

Ill-formed generic type instantiation.
At this point, one of the following is expected:
  * a comma ',' followed by another type;
  * a closing chevron '>' if no more arguments.

interactive_expr: Bytes As Ident LT Ident COMMA ZWSP
##
## Ends in an error in state: 173.
##
## nsepseq(type_ctor_arg,COMMA) -> type_ctor_arg COMMA . nsepseq(type_ctor_arg,COMMA) [ GT ]
## nseq(__anonymous_0(type_ctor_arg,COMMA)) -> type_ctor_arg COMMA . [ GT ]
## nseq(__anonymous_0(type_ctor_arg,COMMA)) -> type_ctor_arg COMMA . nseq(__anonymous_0(type_ctor_arg,COMMA)) [ GT ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg COMMA
##

Ill-formed generic type.
At his point, one of the following is expected:
  * a type argument as a type;
  * a closing chevron '>' if no more arguments.

interactive_expr: Bytes As LBRACE RBRACE VBAR ZWSP
##
## Ends in an error in state: 197.
##
## nsepseq(core_type,VBAR) -> core_type VBAR . nsepseq(core_type,VBAR) [ While When WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## core_type VBAR
##

Ill-formed union type.
At this point, a record type is expected.

interactive_expr: Bytes As UIdent DOT ZWSP
##
## Ends in an error in state: 190.
##
## namespace_path(__anonymous_3) -> namespace_name DOT . namespace_path(__anonymous_3) [ LT ]
## namespace_path(__anonymous_3) -> namespace_name DOT . type_ctor [ LT ]
## namespace_path(__anonymous_4) -> namespace_name DOT . namespace_path(__anonymous_4) [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
## namespace_path(__anonymous_4) -> namespace_name DOT . type_name [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## namespace_name DOT
##

Ill-formed selection of a type in a namespace.
At this point, one of the following is expected:
  * a type name;
  * another namespace name.

interactive_expr: Bytes As LPAR Ident XOR
##
## Ends in an error in state: 222.
##
## par(type_expr) -> LPAR type_expr . RPAR [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
## par(type_expr) -> LPAR type_expr . PARAMS RPAR [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
##
interactive_expr: Bytes As LPAR Ident PARAMS ZWSP
##
## Ends in an error in state: 224.
##
## par(type_expr) -> LPAR type_expr PARAMS . RPAR [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr PARAMS
##

Ill-formed parenthesised type.
At this point, if the type is complete, a closing parenthesis ')' is
expected.

contract: Switch LPAR Bytes RPAR LBRACE Case Bytes ZWSP
##
## Ends in an error in state: 299.
##
## call_expr -> lambda . arguments [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## lambda
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1149, spurious reduction of production core_expr -> literal_expr
## In state 1151, spurious reduction of production lambda -> core_expr
##

Ill-formed function call.
At this point, the arguments are expected between parentheses.

contract: Bytes LPAR ZWSP
##
## Ends in an error in state: 300.
##
## par(ioption(nsepseq(argument,COMMA))) -> LPAR . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(argument,COMMA))) -> LPAR . nsepseq(argument,COMMA) RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(argument,COMMA))) -> LPAR . PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(argument,COMMA))) -> LPAR . nsepseq(argument,COMMA) PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function call.
At this point, one of the following is expected:
  * an argument;
  * a closing parenthesis ')' otherwise.

contract: Bytes LPAR PARAMS ZWSP
##
## Ends in an error in state: 302.
##
## par(ioption(nsepseq(argument,COMMA))) -> LPAR PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR PARAMS
##
contract: Bytes LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 499.
##
## par(ioption(nsepseq(argument,COMMA))) -> LPAR nsepseq(argument,COMMA) PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(argument,COMMA) PARAMS
##

Ill-formed function call.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Bytes XOR ZWSP
##
## Ends in an error in state: 357.
##
## bin_op(disj_expr_level,XOR,conj_expr_level) -> disj_expr_level XOR . conj_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level XOR
##
interactive_expr: Bytes BIT_AND ZWSP
##
## Ends in an error in state: 361.
##
## bin_op(conj_expr_level,BIT_AND,bit_shift_level) -> conj_expr_level BIT_AND . bit_shift_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BIT_AND
##
interactive_expr: Bytes LT ZWSP
##
## Ends in an error in state: 363.
##
## bin_op(comp_expr_level,LT,add_expr_level) -> comp_expr_level LT . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##
interactive_expr: Bytes OR ZWSP
##
## Ends in an error in state: 448.
##
## bin_op(disj_expr_level,OR,conj_expr_level) -> disj_expr_level OR . conj_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level OR
##
interactive_expr: Bytes BIT_XOR ZWSP
##
## Ends in an error in state: 450.
##
## bin_op(disj_expr_level,BIT_XOR,conj_expr_level) -> disj_expr_level BIT_XOR . conj_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BIT_XOR
##
interactive_expr: Bytes PLUS ZWSP
##
## Ends in an error in state: 377.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Bytes SLASH ZWSP
##
## Ends in an error in state: 379.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Bytes REM ZWSP
##
## Ends in an error in state: 381.
##
## bin_op(mult_expr_level,REM,unary_expr_level) -> mult_expr_level REM . unary_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level REM
##
interactive_expr: Bytes MINUS ZWSP
##
## Ends in an error in state: 383.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Bytes LE ZWSP
##
## Ends in an error in state: 385.
##
## bin_op(comp_expr_level,LE,add_expr_level) -> comp_expr_level LE . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Bytes GT XOR
##
## Ends in an error in state: 392.
##
## bin_op(comp_expr_level,gt,add_expr_level) -> comp_expr_level gt . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
## gt2 -> gt . GT [ WILD Verbatim UIdent True Tez String PLUS2 Nat NOT Mutez Match MINUS2 MINUS LPAR LBRACKET Int Ident False EIdent Do ContractOf Bytes BIT_NOT ]
##
## The known suffix of the stack is as follows:
## comp_expr_level gt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 387, spurious reduction of production gt -> GT
##
interactive_expr: Bytes GT ZWSP EQ ZWSP
##
## Ends in an error in state: 395.
##
## bin_op(comp_expr_level,ge,add_expr_level) -> comp_expr_level ge . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level ge
##
interactive_expr: Bytes GT GT ZWSP
##
## Ends in an error in state: 390.
##
## bin_op(comp_expr_level,gt2,add_expr_level) -> comp_expr_level gt2 . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level gt2
##
interactive_expr: Bytes NE ZWSP
##
## Ends in an error in state: 408.
##
## bin_op(add_expr_level,NE,eq_expr_level) -> add_expr_level NE . eq_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level NE
##
interactive_expr: Bytes EQ2 ZWSP
##
## Ends in an error in state: 410.
##
## bin_op(add_expr_level,EQ2,eq_expr_level) -> add_expr_level EQ2 . eq_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level EQ2
##
interactive_expr: Bytes BIT_SL ZWSP
##
## Ends in an error in state: 398.
##
## bin_op(bit_shift_level,BIT_SL,comp_expr_level) -> bit_shift_level BIT_SL . comp_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## bit_shift_level BIT_SL
##
interactive_expr: Bytes AND ZWSP
##
## Ends in an error in state: 413.
##
## bin_op(conj_expr_level,AND,bit_shift_level) -> conj_expr_level AND . bit_shift_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## conj_expr_level AND
##
interactive_expr: Bytes VBAR ZWSP
##
## Ends in an error in state: 418.
##
## bin_op(disj_expr_level,VBAR,conj_expr_level) -> disj_expr_level VBAR . conj_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level VBAR
##
interactive_expr: Bytes TIMES ZWSP
##
## Ends in an error in state: 329.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##
interactive_expr: MINUS ZWSP
##
## Ends in an error in state: 41.
##
## minus_expr -> MINUS . app_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##
interactive_expr: NOT ZWSP
##
## Ends in an error in state: 32.
##
## not_expr -> NOT . app_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## NOT
##
interactive_expr: BIT_NOT ZWSP
##
## Ends in an error in state: 277.
##
## neg_expr -> BIT_NOT . app_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## BIT_NOT
##

Ill-formed expression.
At this point, an expression is expected.

interactive_expr: Bytes As ZWSP
##
## Ends in an error in state: 446.
##
## typed_expr -> app_expr_level As . type_expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## app_expr_level As
##
interactive_expr: LBRACE RBRACE As ZWSP
##
## Ends in an error in state: 310.
##
## typed_object_expr -> untyped_object_expr As . type_expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## untyped_object_expr As
##

Ill-formed typed expression.
At this point, a type is expected.

contract: Bytes LPAR Bytes WILD
##
## Ends in an error in state: 502.
##
## nsepseq(argument,COMMA) -> argument . [ RPAR PARAMS ]
## nsepseq(argument,COMMA) -> argument . COMMA nsepseq(argument,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## argument
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 501, spurious reduction of production argument -> expr
##

Ill-formed function call.
At this point, one of the following is expected:
   * a comma ',' followed by another argument;
   * a closing parenthesis ')' if no more arguments.

contract: Bytes LPAR Bytes COMMA ZWSP
##
## Ends in an error in state: 503.
##
## nsepseq(argument,COMMA) -> argument COMMA . nsepseq(argument,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## argument COMMA
##

Ill-formed function call.
At this point, another argument is expected.

contract: Switch LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 523.
##
## par(switch_subject) -> LPAR switch_subject PARAMS . RPAR [ LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAR switch_subject PARAMS
##

Ill-formed switch.
At this point, a closing parenthesis ')' is expected.

contract: Switch LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 526.
##
## switch_stmt -> Switch par(switch_subject) . braces(cases) [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Switch par(switch_subject)
##

Ill-formed switch.
At this point, an opening brace '{' is expected, followed by cases.

contract: Switch LPAR Bytes RPAR LBRACE ZWSP
##
## Ends in an error in state: 527.
##
## braces(cases) -> LBRACE . cases RBRACE [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed switch.
At this point, one of the following is expected:
  * the keyword 'case' introducing a new case;
  * the keyword 'default' introducing the default case.

contract: Switch LPAR Bytes RPAR LBRACE Default ZWSP
##
## Ends in an error in state: 528.
##
## switch_default -> Default . COLON [ RBRACE ]
## switch_default -> Default . COLON statements [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default
##

Ill-formed default switch case
At this point, a colon ':' is expected.

contract: Const Bytes EQ Bytes COMMA ZWSP
##
## Ends in an error in state: 662.
##
## nsepseq(val_binding,COMMA) -> val_binding COMMA . nsepseq(val_binding,COMMA) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## val_binding COMMA
##

Ill-formed value declaration.
At this point, a pattern is expected, e.g. a variable.

contract: Switch LPAR Bytes RPAR LBRACE Default COLON ZWSP
##
## Ends in an error in state: 529.
##
## switch_default -> Default COLON . [ RBRACE ]
## switch_default -> Default COLON . statements [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default COLON
##

Ill-formed default switch case
At this point, one of the following is expected:
  * a statement;
  * a closing brace '}' if no more cases.

contract: If LPAR Bytes RPAR While LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 720.
##
## while_stmt(catenable_stmt) -> While par(while_cond) . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(closed_non_if_stmt) -> While par(while_cond) . closed_non_if_stmt [ SEMI_ELSE Else ]
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_ending_with_expr) -> While par(while_cond) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##
contract: Return While LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 992.
##
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_not_ending_with_expr) -> While par(while_cond) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> While par(while_cond) . stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##
contract: Return If LPAR Bytes RPAR While LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 998.
##
## while_stmt(__anonymous_5) -> While par(while_cond) . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(closed_non_if_stmt) -> While par(while_cond) . closed_non_if_stmt [ SEMI_ELSE Else ]
## while_stmt(export(type_decl)) -> While par(while_cond) . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_not_ending_with_expr) -> While par(while_cond) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##
contract: While LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 1244.
##
## while_stmt(catenable_stmt) -> While par(while_cond) . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_ending_with_expr) -> While par(while_cond) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##
contract: Return While LPAR Bytes RPAR While LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 994.
##
## while_stmt(__anonymous_5) -> While par(while_cond) . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(export(type_decl)) -> While par(while_cond) . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_not_ending_with_expr) -> While par(while_cond) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##

Ill-formed while-loop.
At this point, the body is expected as a statement.

interactive_expr: LBRACE ELLIPSIS Bytes COMMA ZWSP
##
## Ends in an error in state: 1174.
##
## update_expr -> ELLIPSIS expr property_sep . updates [ RBRACE ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS expr property_sep
##

Ill-formed record update.
At this point, record assignments are expected.

contract: LBRACKET Bytes COMMA ZWSP
##
## Ends in an error in state: 1202.
##
## nsepseq(element(expr),COMMA) -> element(expr) COMMA . nsepseq(element(expr),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(expr),COMMA)) -> element(expr) COMMA . [ RBRACKET ]
## nseq(__anonymous_0(element(expr),COMMA)) -> element(expr) COMMA . nseq(__anonymous_0(element(expr),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(expr) COMMA
##

Ill-formed array.
At this point, one of the following is expected:
  * another element;
  * a closing bracket ']' if no more elements.

contract: Match LPAR Bytes RPAR LBRACE When LPAR Bytes RPAR COLON Bytes WILD
##
## Ends in an error in state: 1224.
##
## match_clause -> When par(when_pattern) COLON expr . [ When RBRACE Default ]
## match_clause -> When par(when_pattern) COLON expr . SEMI [ When RBRACE Default ]
##
## The known suffix of the stack is as follows:
## When par(when_pattern) COLON expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
##

Ill-formed pattern matching.
At this point, if the clause is complete, one of the following is
expected:
  * the keyword 'when' to introduce a new clause;
  * the keyword 'default' to introduce the default clause;
  * a closing brace '}' if no more clauses.

contract: Match LPAR Bytes RPAR LBRACE When LPAR UIdent COLON Ident XOR
##
## Ends in an error in state: 1215.
##
## par(when_pattern) -> LPAR when_pattern . RPAR [ COLON ]
## par(when_pattern) -> LPAR when_pattern . PARAMS RPAR [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR when_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 228, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 1221, spurious reduction of production typed_pattern -> pattern type_annotation(type_expr)
## In state 1219, spurious reduction of production when_pattern -> typed_pattern
##

Ill-formed pattern matching.
At this point, a closing parenthesis ')' is expected.

contract: LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 1208.
##
## par(expr) -> LPAR expr PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR expr PARAMS
##

Ill-formed parenthesised expression.
At this point, if the expression is complete, a closing parenthesis
')' is expected.

contract: UIdent DOT UIdent ZWSP
##
## Ends in an error in state: 288.
##
## namespace_path(selected_expr) -> namespace_name . DOT namespace_path(selected_expr) [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## namespace_path(selected_expr) -> namespace_name . DOT selected_expr [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## namespace_name
##
contract: Const UIdent DOT UIdent ZWSP
##
## Ends in an error in state: 612.
##
## namespace_path(qualifiable_pattern) -> namespace_name . DOT namespace_path(qualifiable_pattern) [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
## namespace_path(qualifiable_pattern) -> namespace_name . DOT qualifiable_pattern [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## namespace_name
##

Ill-formed selection in nested namespaces.
At this point, the selection operator '.' is expected.


contract: Const UIdent DOT ZWSP
##
## Ends in an error in state: 613.
##
## namespace_path(qualifiable_pattern) -> namespace_name DOT . namespace_path(qualifiable_pattern) [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
## namespace_path(qualifiable_pattern) -> namespace_name DOT . qualifiable_pattern [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## namespace_name DOT
##

Ill-formed selection in a nested namespace.
At this point, one of the following is expected:
  * another namespace name;
  * a record pattern;
  * a variable.

contract: Namespace UIdent LBRACE For LPAR SEMI SEMI ZWSP
##
## Ends in an error in state: 743.
##
## range_for -> SEMI SEMI . [ RPAR PARAMS ]
## range_for -> SEMI SEMI . afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## SEMI SEMI
##
contract: Namespace UIdent LBRACE For LPAR Ident MINUS2 SEMI SEMI ZWSP
##
## Ends in an error in state: 782.
##
## range_for -> initialiser SEMI SEMI . [ RPAR PARAMS ]
## range_for -> initialiser SEMI SEMI . afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser SEMI SEMI
##
contract: For LPAR SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 752.
##
## range_for -> SEMI condition SEMI . [ RPAR PARAMS ]
## range_for -> SEMI condition SEMI . afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## SEMI condition SEMI
##
contract: For LPAR Ident MINUS2 SEMI Bytes SEMI ZWSP
##
## Ends in an error in state: 785.
##
## range_for -> initialiser SEMI condition SEMI . [ RPAR PARAMS ]
## range_for -> initialiser SEMI condition SEMI . afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser SEMI condition SEMI
##

Ill-formed for-loop.
At this point, one of the following is expected:
  * an afterthought, e.g. incrementing a variable;
  * a closing parenthesis ')' if none.

contract: Namespace UIdent LBRACE For LPAR Let ZWSP
##
## Ends in an error in state: 754.
##
## range_of -> Let . pattern Of expr [ RPAR PARAMS ]
## value_decl -> Let . bindings [ SEMI ]
##
## The known suffix of the stack is as follows:
## Let
##
contract: Namespace UIdent LBRACE For LPAR Const ZWSP
##
## Ends in an error in state: 758.
##
## range_of -> Const . pattern Of expr [ RPAR PARAMS ]
## value_decl -> Const . bindings [ SEMI ]
##
## The known suffix of the stack is as follows:
## Const
##

Ill-formed for-loop.
At this point, a pattern is expected, e.g. a variable.

contract: For LPAR Const EIdent ZWSP
##
## Ends in an error in state: 759.
##
## range_of -> Const pattern . Of expr [ RPAR PARAMS ]
## val_binding -> pattern . EQ expr [ SEMI COMMA ]
## val_binding -> pattern . binding_type EQ expr [ SEMI COMMA ]
##
## The known suffix of the stack is as follows:
## Const pattern
##
contract: For LPAR Let WILD ZWSP
##
## Ends in an error in state: 755.
##
## range_of -> Let pattern . Of expr [ RPAR PARAMS ]
## val_binding -> pattern . EQ expr [ SEMI COMMA ]
## val_binding -> pattern . binding_type EQ expr [ SEMI COMMA ]
##
## The known suffix of the stack is as follows:
## Let pattern
##

Ill-formed for-loop.
At this point, one of the following is expected:
  * the keyword 'of' if defining a for-of loop;
  * the assignment operator '=' to define the initialiser;
  * a colon ':' followed by the type of the initialiser.

contract: For LPAR Let WILD Of ZWSP
##
## Ends in an error in state: 756.
##
## range_of -> Let pattern Of . expr [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## Let pattern Of
##
contract: For LPAR Const WILD Of ZWSP
##
## Ends in an error in state: 760.
##
## range_of -> Const pattern Of . expr [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## Const pattern Of
##

Ill-formed for-loop.
At this point, the range is expected as an expression.

contract: Namespace UIdent LBRACE For LPAR SEMI SEMI PARAMS ZWSP
##
## Ends in an error in state: 774.
##
## par(range_for) -> LPAR range_for PARAMS . RPAR [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR range_for PARAMS
##

Ill-formed for-loop.
At this point, a closing parenthesis ')' is expected.

contract: Namespace UIdent LBRACE For LPAR Ident MINUS2 BIT_AND
##
## Ends in an error in state: 780.
##
## range_for -> initialiser . SEMI SEMI [ RPAR PARAMS ]
## range_for -> initialiser . SEMI SEMI afterthought [ RPAR PARAMS ]
## range_for -> initialiser . SEMI condition SEMI [ RPAR PARAMS ]
## range_for -> initialiser . SEMI condition SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser
##

Ill-formed for-loop.
At this point, a semicolon ';' is expected.

contract: Namespace UIdent LBRACE For LPAR Ident MINUS2 SEMI ZWSP
##
## Ends in an error in state: 781.
##
## range_for -> initialiser SEMI . SEMI [ RPAR PARAMS ]
## range_for -> initialiser SEMI . SEMI afterthought [ RPAR PARAMS ]
## range_for -> initialiser SEMI . condition SEMI [ RPAR PARAMS ]
## range_for -> initialiser SEMI . condition SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser SEMI
##

Ill-formed for-loop.
At this point, one of the following is expected:
  * a semicolon ';',
  * the invariant as a boolean expression.

contract: Const ZWSP
##
## Ends in an error in state: 881.
##
## value_decl -> Const . bindings [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Const
##

Ill-formed value declaration.
At this point, a pattern is expected, e.g. a variable.

contract: Namespace UIdent LBRACE For ZWSP
##
## Ends in an error in state: 893.
##
## empty_for_stmt -> For . par(range_for) [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(catenable_stmt) -> For . par(range_of) catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For . par(range_of) statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_ending_with_expr) -> For . par(range_of) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## full_for_stmt(catenable_stmt) -> For . par(range_for) catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(statement) -> For . par(range_for) statement [ SEMI RBRACE EOF Default Case ]
## full_for_stmt(stmt_ending_with_expr) -> For . par(range_for) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##
contract: If LPAR Bytes RPAR For ZWSP
##
## Ends in an error in state: 740.
##
## empty_for_stmt -> For . par(range_for) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## for_of_stmt(catenable_stmt) -> For . par(range_of) catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(closed_non_if_stmt) -> For . par(range_of) closed_non_if_stmt [ SEMI_ELSE Else ]
## for_of_stmt(statement) -> For . par(range_of) statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_ending_with_expr) -> For . par(range_of) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## full_for_stmt(catenable_stmt) -> For . par(range_for) catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(closed_non_if_stmt) -> For . par(range_for) closed_non_if_stmt [ SEMI_ELSE Else ]
## full_for_stmt(statement) -> For . par(range_for) statement [ SEMI RBRACE EOF Default Case ]
## full_for_stmt(stmt_ending_with_expr) -> For . par(range_for) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##
contract: Return If LPAR Bytes RPAR For ZWSP
##
## Ends in an error in state: 1001.
##
## empty_for_stmt -> For . par(range_for) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## for_of_stmt(__anonymous_5) -> For . par(range_of) type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(closed_non_if_stmt) -> For . par(range_of) closed_non_if_stmt [ SEMI_ELSE Else ]
## for_of_stmt(export(type_decl)) -> For . par(range_of) export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For . par(range_of) statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_not_ending_with_expr) -> For . par(range_of) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(__anonymous_5) -> For . par(range_for) type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(closed_non_if_stmt) -> For . par(range_for) closed_non_if_stmt [ SEMI_ELSE Else ]
## full_for_stmt(export(type_decl)) -> For . par(range_for) export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(statement) -> For . par(range_for) statement [ SEMI RBRACE EOF Default Case ]
## full_for_stmt(stmt_not_ending_with_expr) -> For . par(range_for) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##
contract: Return Attr For ZWSP
##
## Ends in an error in state: 1076.
##
## for_of_stmt(statement) -> For . par(range_of) statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_not_ending_with_expr) -> For . par(range_of) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> For . par(range_of) stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## full_for_stmt(statement) -> For . par(range_for) statement [ SEMI RBRACE EOF Default Case ]
## full_for_stmt(stmt_not_ending_with_expr) -> For . par(range_for) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> For . par(range_for) stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##
contract: Return While LPAR Bytes RPAR For ZWSP
##
## Ends in an error in state: 1005.
##
## empty_for_stmt -> For . par(range_for) [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(__anonymous_5) -> For . par(range_of) type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(export(type_decl)) -> For . par(range_of) export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For . par(range_of) statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_not_ending_with_expr) -> For . par(range_of) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(__anonymous_5) -> For . par(range_for) type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(export(type_decl)) -> For . par(range_for) export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(statement) -> For . par(range_for) statement [ SEMI RBRACE EOF Default Case ]
## full_for_stmt(stmt_not_ending_with_expr) -> For . par(range_for) stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##

Ill-formed for-loop.
At this point, an opening parenthesis '(' is expected.

contract: Namespace UIdent LBRACE Return Export ZWSP
##
## Ends in an error in state: 1081.
##
## export(fun_decl) -> Export . fun_decl [ While WILD Verbatim UIdent Type True Tez Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## export(import_decl) -> Export . import_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Directive Default Continue Const Case Break Attr ]
## export(interface_decl) -> Export . interface_decl [ While WILD Verbatim UIdent Type True Tez Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## export(namespace_decl) -> Export . namespace_decl [ While WILD Verbatim UIdent Type True Tez Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
## export(type_decl) -> Export . type_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Directive Default Continue Const Case Break Attr ]
## export(value_decl) -> Export . value_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Directive Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Export
##
contract: Return If LPAR Bytes RPAR Export ZWSP
##
## Ends in an error in state: 880.
##
## export(declaration) -> Export . declaration [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## export(fun_decl) -> Export . fun_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(import_decl) -> Export . import_decl [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## export(interface_decl) -> Export . interface_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(namespace_decl) -> Export . namespace_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(type_decl) -> Export . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(value_decl) -> Export . value_decl [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## Export
##
contract: Return If LPAR Bytes RPAR If LPAR Bytes RPAR Export ZWSP
##
## Ends in an error in state: 1003.
##
## export(declaration) -> Export . declaration [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## export(fun_decl) -> Export . fun_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(interface_decl) -> Export . interface_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(namespace_decl) -> Export . namespace_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(type_decl) -> Export . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Export
##
contract: Return If LPAR Bytes RPAR Attr Export ZWSP
##
## Ends in an error in state: 1036.
##
## export(declaration) -> Export . declaration [ SEMI RBRACE EOF Default Case ]
## export(fun_decl) -> Export . fun_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(interface_decl) -> Export . interface_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## export(namespace_decl) -> Export . namespace_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Export
##

Ill-formed export declaration.
At this point, a declaration is expected.

contract: Return Attr Attr ZWSP
##
## Ends in an error in state: 1088.
##
## stmt_not_starting_with_expr_nor_block -> Attr . stmt_not_starting_with_expr_nor_block [ SEMI RBRACE EOF Default Case ]
## stmt_not_starting_with_expr_nor_block1 -> Attr . stmt_not_starting_with_expr_nor_block1 [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## stmt_not_starting_with_expr_nor_block2 -> Attr . stmt_not_starting_with_expr_nor_block2 [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##
contract: If LPAR Bytes RPAR Attr ZWSP
##
## Ends in an error in state: 892.
##
## catenable_stmt -> Attr . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## statement -> Attr . statement [ SEMI RBRACE EOF Default Case ]
## stmt_ending_with_expr -> Attr . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##
contract: Return If LPAR Bytes RPAR Attr ZWSP
##
## Ends in an error in state: 1004.
##
## statement -> Attr . statement [ SEMI RBRACE EOF Default Case ]
## stmt_not_ending_with_expr -> Attr . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated statement.
At this point, one of the following is expected:
  * another decorator;
  * a statement without a decorator.

contract: Namespace UIdent LBRACE Return For LPAR SEMI SEMI RPAR ZWSP
##
## Ends in an error in state: 1079.
##
## full_for_stmt(statement) -> For par(range_for) . statement [ SEMI RBRACE EOF Default Case ]
## full_for_stmt(stmt_not_ending_with_expr) -> For par(range_for) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## full_for_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> For par(range_for) . stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_for)
##

Ill-formed for-loop.
At this point, the body is expected as a statement.

contract: Namespace UIdent LBRACE Return BIT_AND
##
## Ends in an error in state: 1164.
##
## braces(statements) -> LBRACE statements . RBRACE [ XOR While When WILD Verbatim VBAR UIdent Type True Tez TIMES Switch String SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS2 PLUS PARAMS OR Nat Namespace NE Mutez Match MINUS2 MINUS Let LT LPAR LE LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ2 EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACE statements
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 530, spurious reduction of production empty_return_stmt -> Return
## In state 1127, spurious reduction of production return_stmt -> empty_return_stmt
## In state 906, spurious reduction of production non_if_stmt(statement) -> return_stmt
## In state 907, spurious reduction of production statement -> non_if_stmt(statement)
## In state 1121, spurious reduction of production last_or_more(statement) -> statement
## In state 1126, spurious reduction of production statements -> last_or_more(statement)
##

Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * a semicolon ';' followed by another statement;
  * a closing brace '}' if no more statements.

contract: Namespace UIdent Implements ZWSP
##
## Ends in an error in state: 536.
##
## interface -> Implements . nsepseq(interface_expr,COMMA) [ LBRACE ]
##
## The known suffix of the stack is as follows:
## Implements
##

Ill-formed interface declaration.
At this point, an interface is expected.

contract: Namespace UIdent Implements UIdent ZWSP
##
## Ends in an error in state: 578.
##
## nsepseq(interface_expr,COMMA) -> interface_expr . [ LBRACE ]
## nsepseq(interface_expr,COMMA) -> interface_expr . COMMA nsepseq(interface_expr,COMMA) [ LBRACE ]
##
## The known suffix of the stack is as follows:
## interface_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 119, spurious reduction of production namespace_selection -> namespace_name
## In state 577, spurious reduction of production interface_expr -> namespace_selection
##

Ill-formed namespace declaration.
At this point, if the interface is complete, one of the following is
expected:
  * a comma ',' followed by another interface to be implemented;
  * a closing brace '}' is no more interface.

interactive_expr: ZWSP
##
## Ends in an error in state: 1248.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.
At this point, an expression is expected.

contract: Attr Directive ZWSP
##
## Ends in an error in state: 1134.
##
## statements -> catenable_stmt . statements [ RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## catenable_stmt
##

Ill-formed statements.
At this point, a statement is expected.

contract: Const Bytes COLON Ident EQ ZWSP
##
## Ends in an error in state: 667.
##
## val_binding -> pattern binding_type EQ . expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA Break Attr ]
##
## The known suffix of the stack is as follows:
## pattern binding_type EQ
##

Ill-formed value declaration.
At this point, the right-hand side is expected as an expression.

interactive_expr: UIdent WILD
##
## Ends in an error in state: 336.
##
## ctor_app_expr -> ctor . ctor_app_expr_args [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## ctor
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 23, spurious reduction of production ctor -> UIdent
##

Ill-formed constructor application.
At this point, an opening parenthesis '(' is expected.

interactive_expr: Bytes As LBRACE Attr ZWSP
##
## Ends in an error in state: 127.
##
## property_decl -> Attr . property_decl [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated field.
At this point, one of the following is expected:
  * another decorator;
  * a field without a decorator.

interactive_expr: Bytes As Attr ZWSP
##
## Ends in an error in state: 165.
##
## attr_type -> Attr . core_type [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ]
## prefixed_union -> Attr . prefixed_union [ While When WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated type or variant.
At this point, one of the following is expected:
  * another decorator;
  * a type;
  * a variant.

interactive_expr: Bytes As VBAR ZWSP
##
## Ends in an error in state: 112.
##
## nseq(__anonymous_2) -> VBAR . core_type [ While When WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ]
## nseq(__anonymous_2) -> VBAR . core_type nseq(__anonymous_2) [ While When WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant or union type.
At this point, one of the following is expected:
  * a record type if defining a union type;
  * a variant, otherwise.

interactive_expr: Bytes As LBRACKET Ident COMMA Ident XOR
##
## Ends in an error in state: 215.
##
## nsepseq(type_element,COMMA) -> type_element . [ RBRACKET ]
## nsepseq(type_element,COMMA) -> type_element . COMMA nsepseq(type_element,COMMA) [ RBRACKET ]
## nseq(__anonymous_0(type_element,COMMA)) -> type_element . COMMA [ RBRACKET ]
## nseq(__anonymous_0(type_element,COMMA)) -> type_element . COMMA nseq(__anonymous_0(type_element,COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_element
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 141, spurious reduction of production type_name -> Ident
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 212, spurious reduction of production type_element -> type_expr
##

Ill-formed array type.
At this point, one of the following is expected:
  * a comma ',' followed by a type;
  * a closing bracket ']' if no more elements.

interactive_expr: Bytes As LBRACKET Ident COMMA Ident COMMA ZWSP
##
## Ends in an error in state: 216.
##
## nsepseq(type_element,COMMA) -> type_element COMMA . nsepseq(type_element,COMMA) [ RBRACKET ]
## nseq(__anonymous_0(type_element,COMMA)) -> type_element COMMA . [ RBRACKET ]
## nseq(__anonymous_0(type_element,COMMA)) -> type_element COMMA . nseq(__anonymous_0(type_element,COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_element COMMA
##

Ill-formed array type.
At this point, one of the following is expected:
  * a type for an element;
  * a closing bracket ']' if no more elements.

contract: Switch LPAR Bytes WILD
##
## Ends in an error in state: 521.
##
## par(switch_subject) -> LPAR switch_subject . RPAR [ LBRACE ]
## par(switch_subject) -> LPAR switch_subject . PARAMS RPAR [ LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAR switch_subject
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 525, spurious reduction of production switch_subject -> expr
##

Ill-formed switch.
At this point, if the expression is complete, a closing parenthesis
')' is expected.

contract: If LPAR Bytes WILD
##
## Ends in an error in state: 713.
##
## par(if_cond) -> LPAR if_cond . RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## par(if_cond) -> LPAR if_cond . PARAMS RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR if_cond
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 717, spurious reduction of production if_cond -> expr
##
contract: If LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 715.
##
## par(if_cond) -> LPAR if_cond PARAMS . RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR if_cond PARAMS
##

Ill-formed conditional statement.
At this point, a closing parenthesis ')' is expected.

contract: If LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 718.
##
## if_else_stmt(catenable_stmt) -> If par(if_cond) . closed_non_if_stmt Else catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(catenable_stmt) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt Else stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_stmt(catenable_stmt) -> If par(if_cond) . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_ending_with_expr) -> If par(if_cond) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##
contract: If LPAR Bytes RPAR If LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 722.
##
## if_else_stmt(catenable_stmt) -> If par(if_cond) . closed_non_if_stmt Else catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(catenable_stmt) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) . closed_non_if_stmt Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt Else stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_stmt(catenable_stmt) -> If par(if_cond) . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_ending_with_expr) -> If par(if_cond) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##
contract: Return If LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 1069.
##
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt Else stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> If par(if_cond) . closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
## if_stmt(statement) -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> If par(if_cond) . stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##
contract: Return If LPAR Bytes RPAR If LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 1000.
##
## if_else_stmt(__anonymous_5) -> If par(if_cond) . closed_non_if_stmt Else type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(__anonymous_5) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) . closed_non_if_stmt Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(export(type_decl)) -> If par(if_cond) . closed_non_if_stmt Else export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(export(type_decl)) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt Else stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(__anonymous_5) -> If par(if_cond) . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(export(type_decl)) -> If par(if_cond) . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##
contract: Return While LPAR Bytes RPAR If LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 996.
##
## if_else_stmt(__anonymous_5) -> If par(if_cond) . closed_non_if_stmt Else type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(__anonymous_5) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(export(type_decl)) -> If par(if_cond) . closed_non_if_stmt Else export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(export(type_decl)) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt Else stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(__anonymous_5) -> If par(if_cond) . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(export(type_decl)) -> If par(if_cond) . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_not_ending_with_expr) -> If par(if_cond) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##

Ill-formed conditional statement.
At this point, the statement for a true condition is expected.

contract: If LPAR Bytes RPAR While ZWSP
##
## Ends in an error in state: 719.
##
## while_stmt(catenable_stmt) -> While . par(while_cond) catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## while_stmt(closed_non_if_stmt) -> While . par(while_cond) closed_non_if_stmt [ SEMI_ELSE Else ]
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_ending_with_expr) -> While . par(while_cond) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##

Ill-formed while-loop.
At this point, the invariant is expected between parentheses.

contract: For LPAR SEMI SEMI Bytes WILD
##
## Ends in an error in state: 747.
##
## nsepseq(after(expr),COMMA) -> after(expr) . [ RPAR PARAMS ]
## nsepseq(after(expr),COMMA) -> after(expr) . COMMA nsepseq(after(expr),COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## after(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 745, spurious reduction of production after(expr) -> expr
##

Ill-formed for-loop.
At this point, one of the following is expected:
  * a comma ',' followed by another afterthought expression;
  * a closing parenthesis ')' otherwise.

contract: For LPAR SEMI SEMI Bytes COMMA ZWSP
##
## Ends in an error in state: 748.
##
## nsepseq(after(expr),COMMA) -> after(expr) COMMA . nsepseq(after(expr),COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## after(expr) COMMA
##

Ill-formed for-loop.
At this point, an expression is expected.

contract: For LPAR SEMI Bytes WILD
##
## Ends in an error in state: 751.
##
## range_for -> SEMI condition . SEMI [ RPAR PARAMS ]
## range_for -> SEMI condition . SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## SEMI condition
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 750, spurious reduction of production condition -> expr
##
contract: For LPAR Ident MINUS2 SEMI Bytes WILD
##
## Ends in an error in state: 784.
##
## range_for -> initialiser SEMI condition . SEMI [ RPAR PARAMS ]
## range_for -> initialiser SEMI condition . SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser SEMI condition
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 750, spurious reduction of production condition -> expr
##

Ill-formed for-loop.
At this point, a semicolon ';' is expected.

contract: For LPAR Const Ident Of Bytes PARAMS ZWSP
##
## Ends in an error in state: 770.
##
## par(range_of) -> LPAR range_of PARAMS . RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR range_of PARAMS
##

Ill-formed for-loop.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Bytes QMARK ZWSP
##
## Ends in an error in state: 420.
##
## ternary_expr(disj_expr_level,expr) -> disj_expr_level QMARK . expr COLON expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK
##
contract: EIdent QMARK ZWSP
##
## Ends in an error in state: 791.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . app_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . app_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . app_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . app_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . app_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . app_expr COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . app_expr COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . app_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . incr_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . incr_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . incr_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . incr_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . incr_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . incr_expr COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . incr_expr COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . incr_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . decr_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . decr_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . decr_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . decr_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . decr_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . decr_expr COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . decr_expr COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . decr_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . assign_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . assign_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . assign_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . assign_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . assign_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . assign_expr COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . assign_expr COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . assign_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . match_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . match_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . match_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . match_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . match_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . match_expr COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . match_expr COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . match_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . typed_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . typed_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . typed_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . typed_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . typed_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . typed_expr COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . typed_expr COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . typed_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . par(expr) COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . par(expr) COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . par(expr) COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . par(expr) COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . par(expr) COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . par(expr) COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . par(expr) COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK . par(expr) COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK
##

Ill-formed ternary conditional.
At this point, the expression for a true condition is expected.

contract: For LPAR Const Ident Of Bytes WILD
##
## Ends in an error in state: 768.
##
## par(range_of) -> LPAR range_of . RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## par(range_of) -> LPAR range_of . PARAMS RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR range_of
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 761, spurious reduction of production range_of -> Const pattern Of expr
##

Ill-formed for-loop.
At this point, if the range expression is complete, a closing
parenthesis ')' is expected.

interactive_expr: Bytes QMARK Bytes WILD
##
## Ends in an error in state: 421.
##
## ternary_expr(disj_expr_level,expr) -> disj_expr_level QMARK expr . COLON expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
##
contract: EIdent QMARK Bytes As EIdent XOR
##
## Ends in an error in state: 792.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr . COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr . COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK typed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 164, spurious reduction of production type_name -> EIdent
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
## In state 447, spurious reduction of production typed_expr -> app_expr_level As type_expr
##
contract: EIdent QMARK EIdent PLUS2 ZWSP
##
## Ends in an error in state: 833.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr . COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr . COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK incr_expr
##
contract: EIdent QMARK EIdent MINUS2 ZWSP
##
## Ends in an error in state: 843.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr . COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr . COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK decr_expr
##
contract: EIdent QMARK EIdent BIT_AND_EQ Bytes WILD
##
## Ends in an error in state: 853.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr . COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr . COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK assign_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 471, spurious reduction of production bin_op(left_hs,BIT_AND_EQ,expr) -> left_hs BIT_AND_EQ expr
## In state 437, spurious reduction of production assign_expr -> bin_op(left_hs,BIT_AND_EQ,expr)
##
contract: EIdent QMARK EIdent QMARK EIdent MINUS2 COLON EIdent MINUS2 BIT_AND
##
## Ends in an error in state: 803.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) . COLON typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) . COLON ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt)
##

Ill-formed ternary conditional expression.
At this point, if the expression for the true condition is complete, a
colon ':' is expected, followed by the expresion for the false
condition.

contract: If LPAR Bytes RPAR For LPAR Const Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 879.
##
## for_of_stmt(catenable_stmt) -> For par(range_of) . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(closed_non_if_stmt) -> For par(range_of) . closed_non_if_stmt [ SEMI_ELSE Else ]
## for_of_stmt(statement) -> For par(range_of) . statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_ending_with_expr) -> For par(range_of) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##
contract: For LPAR Const Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 894.
##
## for_of_stmt(catenable_stmt) -> For par(range_of) . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For par(range_of) . statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_ending_with_expr) -> For par(range_of) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##
contract: Return If LPAR Bytes RPAR For LPAR Const Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 1002.
##
## for_of_stmt(__anonymous_5) -> For par(range_of) . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(closed_non_if_stmt) -> For par(range_of) . closed_non_if_stmt [ SEMI_ELSE Else ]
## for_of_stmt(export(type_decl)) -> For par(range_of) . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For par(range_of) . statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_not_ending_with_expr) -> For par(range_of) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##
contract: Return For LPAR Const Ident Of Bytes RPAR ZWSP
##
## Ends in an error in state: 1077.
##
## for_of_stmt(statement) -> For par(range_of) . statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_not_ending_with_expr) -> For par(range_of) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> For par(range_of) . stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##
contract: Return While LPAR Bytes RPAR For LPAR Const EIdent Of Bytes RPAR ZWSP
##
## Ends in an error in state: 1006.
##
## for_of_stmt(__anonymous_5) -> For par(range_of) . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(export(type_decl)) -> For par(range_of) . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For par(range_of) . statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_not_ending_with_expr) -> For par(range_of) . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##

Ill-formed for-loop.
At this point, the body is expected as a statement.

contract: If LPAR Bytes RPAR If LPAR Bytes RPAR Break SEMI_ELSE ZWSP
##
## Ends in an error in state: 972.
##
## if_else_stmt(catenable_stmt) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##
contract: If LPAR Bytes RPAR If LPAR Bytes RPAR Break Else ZWSP
##
## Ends in an error in state: 977.
##
## if_else_stmt(catenable_stmt) -> If par(if_cond) closed_non_if_stmt Else . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt Else . closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) closed_non_if_stmt Else . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##
contract: If LPAR Bytes RPAR Break SEMI_ELSE ZWSP
##
## Ends in an error in state: 988.
##
## if_else_stmt(catenable_stmt) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##
contract: If LPAR Bytes RPAR Break Else ZWSP
##
## Ends in an error in state: 989.
##
## if_else_stmt(catenable_stmt) -> If par(if_cond) closed_non_if_stmt Else . catenable_stmt [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) closed_non_if_stmt Else . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##
contract: Return If LPAR Bytes RPAR If LPAR Bytes RPAR Return SEMI_ELSE ZWSP
##
## Ends in an error in state: 1045.
##
## if_else_stmt(__anonymous_5) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(export(type_decl)) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##
contract: Return If LPAR Bytes RPAR If LPAR Bytes RPAR Return Else ZWSP
##
## Ends in an error in state: 1049.
##
## if_else_stmt(__anonymous_5) -> If par(if_cond) closed_non_if_stmt Else . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt Else . closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(export(type_decl)) -> If par(if_cond) closed_non_if_stmt Else . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) closed_non_if_stmt Else . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##
contract: Return If LPAR Bytes RPAR Return SEMI_ELSE ZWSP
##
## Ends in an error in state: 1072.
##
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##
contract: Return If LPAR Bytes RPAR Return Else ZWSP
##
## Ends in an error in state: 1074.
##
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) closed_non_if_stmt Else . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1_bis) -> If par(if_cond) closed_non_if_stmt Else . stmt_not_starting_with_expr_nor_block1_bis [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Directive Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##
contract: Return While LPAR Bytes RPAR If LPAR Bytes RPAR Break SEMI_ELSE ZWSP
##
## Ends in an error in state: 1057.
##
## if_else_stmt(__anonymous_5) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(export(type_decl)) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##
contract: Return While LPAR Bytes RPAR If LPAR Bytes RPAR Break Else ZWSP
##
## Ends in an error in state: 1058.
##
## if_else_stmt(__anonymous_5) -> If par(if_cond) closed_non_if_stmt Else . type_decl [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(export(type_decl)) -> If par(if_cond) closed_non_if_stmt Else . export(type_decl) [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_not_ending_with_expr) -> If par(if_cond) closed_non_if_stmt Else . stmt_not_ending_with_expr [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##

Ill-formed conditional statement.
At this point, the statement for a false condition is expected.

contract: Switch LPAR Bytes RPAR LBRACE Case ZWSP
##
## Ends in an error in state: 1147.
##
## switch_case -> Case . case_expr COLON [ RBRACE Default Case ]
## switch_case -> Case . case_expr COLON statements [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## Case
##

Ill-formed switch.
At this point, a case expression is expected.

contract: Switch LPAR Bytes RPAR LBRACE Case Bytes COLON ZWSP
##
## Ends in an error in state: 1153.
##
## switch_case -> Case case_expr COLON . [ RBRACE Default Case ]
## switch_case -> Case case_expr COLON . statements [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## Case case_expr COLON
##

Ill-formed switch.
At this point, one of the following is expected:
  * the keyword 'case' to start a new case;
  * the keyword 'default' to start the default case;
  * a statement for the current case;
  * a closing brace '}' if the case is empty.

contract: Switch LPAR Bytes RPAR LBRACE Case Bytes COLON Return BIT_AND
##
## Ends in an error in state: 1157.
##
## nseq(switch_case) -> switch_case . [ RBRACE Default ]
## nseq(switch_case) -> switch_case . nseq(switch_case) [ RBRACE Default ]
##
## The known suffix of the stack is as follows:
## switch_case
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 530, spurious reduction of production empty_return_stmt -> Return
## In state 1127, spurious reduction of production return_stmt -> empty_return_stmt
## In state 906, spurious reduction of production non_if_stmt(statement) -> return_stmt
## In state 907, spurious reduction of production statement -> non_if_stmt(statement)
## In state 1121, spurious reduction of production last_or_more(statement) -> statement
## In state 1126, spurious reduction of production statements -> last_or_more(statement)
## In state 1154, spurious reduction of production switch_case -> Case case_expr COLON statements
##

Ill-formed switch.
At this point, one of the following is expected:
  * the keyword 'case' to start a new case;
  * the keyword 'default' to start the default case;
  * a closing brace '}' if no more cases.

contract: Switch LPAR Bytes RPAR LBRACE Default COLON Return BIT_AND
##
## Ends in an error in state: 1161.
##
## braces(cases) -> LBRACE cases . RBRACE [ While WILD Verbatim UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF EIdent Do Directive Default ContractOf Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE cases
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 530, spurious reduction of production empty_return_stmt -> Return
## In state 1127, spurious reduction of production return_stmt -> empty_return_stmt
## In state 906, spurious reduction of production non_if_stmt(statement) -> return_stmt
## In state 907, spurious reduction of production statement -> non_if_stmt(statement)
## In state 1121, spurious reduction of production last_or_more(statement) -> statement
## In state 1126, spurious reduction of production statements -> last_or_more(statement)
## In state 1146, spurious reduction of production switch_default -> Default COLON statements
## In state 1156, spurious reduction of production cases -> switch_default
##

Ill-formed switch.
At this point, if the case is complete, one of the following is
expected:
  * another case (starting by 'case' or 'default');
  * a closing brace '}' is no more cases.

interactive_expr: LBRACE ELLIPSIS Bytes WILD
##
## Ends in an error in state: 1173.
##
## update_expr -> ELLIPSIS expr . property_sep updates [ RBRACE ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
##

Ill-formed record update.
At this point, if the record to update is complete, a field separator
(';' or ',') is expected.

interactive_expr: LBRACE Ident COLON Bytes WILD
##
## Ends in an error in state: 1182.
##
## nsepseq(property(expr),property_sep) -> property(expr) . [ RBRACE ]
## nsepseq(property(expr),property_sep) -> property(expr) . property_sep nsepseq(property(expr),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property(expr),property_sep)) -> property(expr) . property_sep [ RBRACE ]
## nseq(__anonymous_0(property(expr),property_sep)) -> property(expr) . property_sep nseq(__anonymous_0(property(expr),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 1178, spurious reduction of production property(expr) -> property_id COLON expr
##

Ill-formed record.
At this point, one of the following is expected:
  * a field separator (';' or ',');
  * a closing brace '}' if no more fields.

contract: LBRACKET Bytes WILD
##
## Ends in an error in state: 1201.
##
## nsepseq(element(expr),COMMA) -> element(expr) . [ RBRACKET ]
## nsepseq(element(expr),COMMA) -> element(expr) . COMMA nsepseq(element(expr),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(expr),COMMA)) -> element(expr) . COMMA [ RBRACKET ]
## nseq(__anonymous_0(element(expr),COMMA)) -> element(expr) . COMMA nseq(__anonymous_0(element(expr),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 1200, spurious reduction of production element(expr) -> expr
##

Ill-formed array.
At this point, one of the following is expected:
  * a comma ',' followed by another element;
  * a closing bracket ']' otherwise.

contract: Match LPAR Bytes RPAR LBRACE Default COLON Bytes WILD
##
## Ends in an error in state: 1228.
##
## match_default -> Default COLON expr . [ RBRACE ]
## match_default -> Default COLON expr . SEMI [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default COLON expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
##

Ill-formed pattern matching.
At this point, if the default expression is complete, one of the
following is expected:
  * a closing brace '}'.
  * a semicolon ';' followed by a closing brace '}'.

contract: Match LPAR Bytes RPAR LBRACE Default COLON Bytes SEMI ZWSP
##
## Ends in an error in state: 1233.
##
## braces(match_clauses) -> LBRACE match_clauses . RBRACE [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACE match_clauses
##

Ill-formed pattern matching.
At this point, a closing brace is expected '}'.

contract: Match LPAR Bytes RPAR LBRACE When LPAR Bytes RPAR COLON Bytes SEMI ZWSP
##
## Ends in an error in state: 1235.
##
## nseq(match_clause) -> match_clause . [ RBRACE Default ]
## nseq(match_clause) -> match_clause . nseq(match_clause) [ RBRACE Default ]
##
## The known suffix of the stack is as follows:
## match_clause
##

Ill-formed pattern matching.
At this point, one of the following is expected:
  * the keyword 'when' for a normal clause;
  * the keyword 'default' for the default clause.
  * a closing brace '}' if no more clauses.

contract: LPAR Bytes WILD
##
## Ends in an error in state: 1206.
##
## par(expr) -> LPAR expr . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(expr) -> LPAR expr . PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
##

Ill-formed parenthesised expression.
At this point, if the expression is complete, a closing parenthesis
')' is expected.

contract: While LPAR Bytes WILD
##
## Ends in an error in state: 1239.
##
## par(while_cond) -> LPAR while_cond . RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
## par(while_cond) -> LPAR while_cond . PARAMS RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR while_cond
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
## In state 1243, spurious reduction of production while_cond -> expr
##
contract: While LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 1241.
##
## par(while_cond) -> LPAR while_cond PARAMS . RPAR [ While WILD Verbatim UIdent Type True Tez Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EIdent Do Directive ContractOf Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR while_cond PARAMS
##

Ill-formed while-loop.
At this point, if the condition is complete, a closing parenthesis ')'
is expected.

contract: Const Bytes EQ ZWSP
##
## Ends in an error in state: 664.
##
## val_binding -> pattern EQ . expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA Break Attr ]
##
## The known suffix of the stack is as follows:
## pattern EQ
##

Ill-formed value declaration.
At this point, the right-hand side is expected as an expression.

contract: Const UIdent LPAR ZWSP
##
## Ends in an error in state: 624.
##
## par(ioption(nsepseq(pattern,COMMA))) -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
## par(ioption(nsepseq(pattern,COMMA))) -> LPAR . nsepseq(pattern,COMMA) RPAR [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
## par(ioption(nsepseq(pattern,COMMA))) -> LPAR . PARAMS RPAR [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
## par(ioption(nsepseq(pattern,COMMA))) -> LPAR . nsepseq(pattern,COMMA) PARAMS RPAR [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern of constructor application.
At this point, one of the following is expected:
  * a pattern matching an argument;
  * a closing parenthesis ')' if the constructor is constant.

contract: Const UIdent LPAR Bytes ZWSP
##
## Ends in an error in state: 628.
##
## nsepseq(pattern,COMMA) -> pattern . [ RPAR PARAMS ]
## nsepseq(pattern,COMMA) -> pattern . COMMA nsepseq(pattern,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## pattern
##

Ill-formed pattern of constructor application.
At this point, one of the following is expected:
  * a comma ',' followed by a pattern matching an argument;
  * a closing parenthesis ')' if the constructor is constant.

contract: Const UIdent LPAR Bytes COMMA ZWSP
##
## Ends in an error in state: 629.
##
## nsepseq(pattern,COMMA) -> pattern COMMA . nsepseq(pattern,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## pattern COMMA
##

Ill-formed pattern of constructor application.
At this point, a pattern matching an argument is expected.

contract: Const UIdent LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 635.
##
## par(ioption(nsepseq(pattern,COMMA))) -> LPAR nsepseq(pattern,COMMA) PARAMS . RPAR [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(pattern,COMMA) PARAMS
##
contract: Const UIdent LPAR PARAMS ZWSP
##
## Ends in an error in state: 626.
##
## par(ioption(nsepseq(pattern,COMMA))) -> LPAR PARAMS . RPAR [ SEMI RPAR RBRACKET RBRACE PARAMS Of EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAR PARAMS
##

Ill-formed pattern of constructor application.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Bytes As LBRACKET ZWSP
##
## Ends in an error in state: 125.
##
## brackets(type_elements) -> LBRACKET . type_elements RBRACKET [ While When WILD Verbatim VBAR UIdent Type True Tez Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident GT Function For False Export Else EQ EOF EIdent Do Directive Default ContractOf Continue Const Case COMMA COLON Bytes Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed variant type or array type.
At this point, one of the following is expected:
  * a string denoting a constructor;
  * a type denoting an element of an array type.

contract: UIdent LPAR ZWSP
##
## Ends in an error in state: 337.
##
## par(ioption(nsepseq(expr,COMMA))) -> LPAR . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(expr,COMMA))) -> LPAR . nsepseq(expr,COMMA) RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(expr,COMMA))) -> LPAR . PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(expr,COMMA))) -> LPAR . nsepseq(expr,COMMA) PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed constructor application.
At this point, one of the following is expected:
  * an argument;
  * a closing parenthesis ')' otherwise.

contract: UIdent LPAR PARAMS ZWSP
##
## Ends in an error in state: 339.
##
## par(ioption(nsepseq(expr,COMMA))) -> LPAR PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR PARAMS
##
contract: UIdent LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 346.
##
## par(ioption(nsepseq(expr,COMMA))) -> LPAR nsepseq(expr,COMMA) PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(expr,COMMA) PARAMS
##

Ill-formed constructor application.
At this point, a closing parenthesis ')' is expected.

contract: UIdent LPAR Bytes While
##
## Ends in an error in state: 472.
##
## nsepseq(expr,COMMA) -> expr . [ RPAR PARAMS ]
## nsepseq(expr,COMMA) -> expr . COMMA nsepseq(expr,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
## In state 445, spurious reduction of production unary_expr_level -> app_expr_level
## In state 312, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 328, spurious reduction of production add_expr_level -> mult_expr_level
## In state 407, spurious reduction of production eq_expr_level -> add_expr_level
## In state 355, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 362, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 415, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 424, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 356, spurious reduction of production non_object_expr -> disj_expr_level
## In state 348, spurious reduction of production no_attr_expr -> non_object_expr
## In state 349, spurious reduction of production expr -> no_attr_expr
##

Ill-formed constructor application.
At this point, if the argument is complete, one of the following is
expected:
  * a comma ',' followed by another argument;
  * a closing parenthesis ')' otherwise.

contract: UIdent LPAR Bytes COMMA ZWSP
##
## Ends in an error in state: 473.
##
## nsepseq(expr,COMMA) -> expr COMMA . nsepseq(expr,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Ill-formed constructor application.
At this point, an argument is expected.

contract: Do ZWSP
##
## Ends in an error in state: 267.
##
## do_expr -> Do . braces(statements) [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Directive Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## Do
##

Ill-formed do-expression.
At this point, a block of statements is expected to start with an
opening brace '{'.

contract: Interface UIdent Extends UIdent COMMA ZWSP
##
## Ends in an error in state: 579.
##
## nsepseq(interface_expr,COMMA) -> interface_expr COMMA . nsepseq(interface_expr,COMMA) [ LBRACE ]
##
## The known suffix of the stack is as follows:
## interface_expr COMMA
##

Ill-formed interface declaration.
At this point, an interface expression is expected.

contract: Interface UIdent Extends ZWSP
##
## Ends in an error in state: 675.
##
## extends -> Extends . nsepseq(interface_expr,COMMA) [ LBRACE ]
##
## The known suffix of the stack is as follows:
## Extends
##

Ill-formed interface declaration.
At this point, an interface is expected.

contract: EIdent ZWSP
##
## Ends in an error in state: 350.
##
## bin_op(left_hs,BIT_AND_EQ,expr) -> left_hs . BIT_AND_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,BIT_OR_EQ,expr) -> left_hs . BIT_OR_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,BIT_SL_EQ,expr) -> left_hs . BIT_SL_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,BIT_SR_EQ,expr) -> left_hs . BIT_SR_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,BIT_XOR_EQ,expr) -> left_hs . BIT_XOR_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,DIV_EQ,expr) -> left_hs . DIV_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,EQ,expr) -> left_hs . EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,MINUS_EQ,expr) -> left_hs . MINUS_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,MULT_EQ,expr) -> left_hs . MULT_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,PLUS_EQ,expr) -> left_hs . PLUS_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
## bin_op(left_hs,REM_EQ,expr) -> left_hs . REM_EQ expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## left_hs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production var_path -> EIdent
## In state 763, spurious reduction of production left_hs -> var_path
##

Ill-formed arithmetic expression.
At this point, if the expression is complete, an assignment symbol is
expected, e.g. '=', '+=', '&=' etc.

contract: EIdent QMARK Bytes As EIdent COLON ZWSP
##
## Ends in an error in state: 793.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr COLON . typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr COLON . ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK typed_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK typed_expr COLON
##
interactive_expr: Bytes QMARK Bytes COLON ZWSP
##
## Ends in an error in state: 422.
##
## ternary_expr(disj_expr_level,expr) -> disj_expr_level QMARK expr COLON . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK expr COLON
##
contract: EIdent QMARK Match LPAR Bytes RPAR LBRACE Default COLON Bytes RBRACE COLON ZWSP
##
## Ends in an error in state: 824.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK match_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK match_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK match_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK match_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK match_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK match_expr COLON . typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK match_expr COLON . ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK match_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK match_expr COLON
##
contract: EIdent QMARK LPAR Bytes RPAR COLON ZWSP
##
## Ends in an error in state: 814.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK par(expr) COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK par(expr) COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK par(expr) COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK par(expr) COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK par(expr) COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK par(expr) COLON . typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK par(expr) COLON . ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK par(expr) COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK par(expr) COLON
##
contract: EIdent QMARK EIdent PLUS2 COLON ZWSP
##
## Ends in an error in state: 834.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr COLON . typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr COLON . ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK incr_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK incr_expr COLON
##
contract: EIdent QMARK EIdent MINUS2 COLON ZWSP
##
## Ends in an error in state: 844.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr COLON . typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr COLON . ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK decr_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK decr_expr COLON
##
contract: EIdent QMARK EIdent BIT_AND_EQ Bytes COLON ZWSP
##
## Ends in an error in state: 854.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr COLON . typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr COLON . ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK assign_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK assign_expr COLON
##
contract: EIdent QMARK EIdent QMARK EIdent MINUS2 COLON EIdent MINUS2 COLON ZWSP
##
## Ends in an error in state: 804.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON . typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON . ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK ternary_expr(expr_stmt_cond,pre_expr_stmt) COLON
##
contract: EIdent QMARK Bytes LPAR RPAR COLON ZWSP
##
## Ends in an error in state: 864.
##
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK app_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK app_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK app_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK app_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK app_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK app_expr COLON . typed_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK app_expr COLON . ternary_expr(expr_stmt_cond,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
## ternary_expr(expr_stmt_cond,pre_expr_stmt) -> expr_stmt_cond QMARK app_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## expr_stmt_cond QMARK app_expr COLON
##

Ill-formed ternary conditional.
At this point, the expression for a false condition is expected.

contract: Bytes ZWSP
##
## Ends in an error in state: 801.
##
## typed_expr -> app_expr_level . As type_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## app_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 358, spurious reduction of production app_expr_level -> core_expr
##

Ill-formed typed expression.
At this point, if the expression is complete, the keyword 'as' is
expected, followed by a type.

contract: Return If LPAR Bytes RPAR Directive BIT_AND
##
## Ends in an error in state: 1129.
##
## stmts_not_starting_with_expr_nor_block -> stmt_not_starting_with_expr_nor_block1 . stmts_not_starting_with_expr [ RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## stmt_not_starting_with_expr_nor_block1
##

Ill-formed statement.
At this point, a statement other than an expresswion is expected.

interactive_type_expr: ZWSP
##
## Ends in an error in state: 1252.
##
## interactive_type_expr' -> . interactive_type_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed type expression.
At this point, a type expression is expected.

interactive_type_expr: UIdent ARROW
##
## Ends in an error in state: 1253.
##
## interactive_type_expr -> type_expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 113, spurious reduction of production type_name -> UIdent
## In state 166, spurious reduction of production core_type -> type_name
## In state 196, spurious reduction of production nsepseq(core_type,VBAR) -> core_type
## In state 186, spurious reduction of production union_type_level -> nsepseq(core_type,VBAR)
## In state 170, spurious reduction of production type_expr -> union_type_level
##

Ill-formed type expression.
At this point, if the type expression is complete, the end of the
input is expected.

interactive_expr: LBRACE ELLIPSIS Bytes COMMA RBRACE As ZWSP
##
## Ends in an error in state: 307.
##
## typed_update_expr -> untyped_update_expr As . type_expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Directive Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## untyped_update_expr As
##

Ill-formed typed expression.
At this point, a type is expected.

contract: Switch LPAR Bytes RPAR LBRACE Case UIdent LPAR RPAR ZWSP
##
## Ends in an error in state: 1155.
##
## path(app_expr) -> app_expr . nseq(selection) [ LPAR COLON ]
##
## The known suffix of the stack is as follows:
## app_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1150, spurious reduction of production app_expr -> ctor_app_expr
##

Ill-formed selection in a namespace.
At this point, a namespace name is expected.
