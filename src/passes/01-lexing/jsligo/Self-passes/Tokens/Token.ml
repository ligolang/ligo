(* Token specification for JsLIGO *)

(* Vendor dependencies *)

module Region    = Simple_utils.Region
module Markup    = LexerLib.Markup
module Directive = Preprocessor.Directive

(* Utility modules and types *)

module SMap = Map.Make (String)
module Wrap = Lexing_shared.Wrap
module Attr = Lexing_shared.Attr

let sprintf = Printf.sprintf

let wrap = Wrap.wrap

module T =
  struct
    (* A lexeme is the concrete syntax of a token *)

    type lexeme = string

    (* Definition of tokens generated by "menhir --only-tokens"

       It contains [token] and ['a terminal] types. The first one we
       redefine manually here (by type [t]) but the second one we need
       to satisfy Menhir's Inspection API.  *)

    include Menhir_js_tokens.MenhirToken

    (* TOKENS *)

    type t =
      (* Preprocessing directives *)

      Directive of Directive.t

      (* Comments *)

    | BlockCom of lexeme Wrap.t
    | LineCom  of lexeme Wrap.t

      (* Literals *)

    | String   of lexeme Wrap.t
    | Verbatim of lexeme Wrap.t
    | Bytes    of (lexeme * Hex.t) Wrap.t
    | Int      of (lexeme * Z.t) Wrap.t
    | Nat      of (lexeme * Z.t) Wrap.t
    | Mutez    of (lexeme * Int64.t) Wrap.t
    | Ident    of lexeme Wrap.t              (* foo  *)
    | UIdent   of lexeme Wrap.t              (* Foo  *)
    | EIdent   of lexeme Wrap.t              (* @foo *)
 (* | Lang     of lexeme Region.reg *)
    | Attr     of Attr.t Wrap.t

    (* Symbols *)

    | SHARP      of lexeme Wrap.t  (* #    *)
    | MINUS      of lexeme Wrap.t  (* -    *)
    | PLUS       of lexeme Wrap.t  (* +    *)
    | SLASH      of lexeme Wrap.t  (* /    *)
    | TIMES      of lexeme Wrap.t  (* *    *)
    | REM        of lexeme Wrap.t  (* %    *)
    | QMARK      of lexeme Wrap.t  (* ?    *)
    | PLUS2      of lexeme Wrap.t  (* ++   *)
    | MINUS2     of lexeme Wrap.t  (* --   *)
    | LPAR       of lexeme Wrap.t  (* (    *)
    | RPAR       of lexeme Wrap.t  (* )    *)
    | LBRACKET   of lexeme Wrap.t  (* [    *)
    | RBRACKET   of lexeme Wrap.t  (* ]    *)
    | LBRACE     of lexeme Wrap.t  (* {    *)
    | RBRACE     of lexeme Wrap.t  (* }    *)
    | COMMA      of lexeme Wrap.t  (* ,    *)
    | SEMI       of lexeme Wrap.t  (* ;    *)
    | COLON      of lexeme Wrap.t  (* :    *)
    | DOT        of lexeme Wrap.t  (* .    *)
    | ELLIPSIS   of lexeme Wrap.t  (* ...  *)
    | OR         of lexeme Wrap.t  (* ||   *)
    | AND        of lexeme Wrap.t  (* &&   *)
    | NOT        of lexeme Wrap.t  (* !    *)
    | XOR        of lexeme Wrap.t  (* ^^   *)
    | BIT_AND    of lexeme Wrap.t  (* &    *)
    | BIT_NOT    of lexeme Wrap.t  (* ~    *)
    | BIT_XOR    of lexeme Wrap.t  (* ^    *)
    | BIT_SL     of lexeme Wrap.t  (* <<   *)
    | EQ         of lexeme Wrap.t  (* =    *)
    | EQ2        of lexeme Wrap.t  (* ==   *)
    | NE         of lexeme Wrap.t  (* !=   *)
    | LT         of lexeme Wrap.t  (* <    *)
    | GT         of lexeme Wrap.t  (* >    *)
    | LE         of lexeme Wrap.t  (* <=   *)
    | PLUS_EQ    of lexeme Wrap.t  (* +=   *)
    | MINUS_EQ   of lexeme Wrap.t  (* -=   *)
    | MULT_EQ    of lexeme Wrap.t  (* *=   *)
    | REM_EQ     of lexeme Wrap.t  (* %=   *)
    | DIV_EQ     of lexeme Wrap.t  (* /=   *)
    | BIT_SL_EQ  of lexeme Wrap.t  (* <<=  *)
    | BIT_SR_EQ  of lexeme Wrap.t  (* >>=  *)
    | BIT_AND_EQ of lexeme Wrap.t  (* &=   *)
    | BIT_OR_EQ  of lexeme Wrap.t  (* |=   *)
    | BIT_XOR_EQ of lexeme Wrap.t  (* ^=   *)
    | VBAR       of lexeme Wrap.t  (* |    *)
    | ARROW      of lexeme Wrap.t  (* =>   *)
    | WILD       of lexeme Wrap.t  (* _    *)

    (* JavaScript Keywords *)

    | Break    of lexeme Wrap.t  (* break    *)
    | Case     of lexeme Wrap.t  (* case     *)
 (* | Class    of lexeme Wrap.t  (* class    *) *)
    | Const    of lexeme Wrap.t  (* const    *)
    | Continue of lexeme Wrap.t  (* continue *)
    | Default  of lexeme Wrap.t  (* default  *)
    | Else     of lexeme Wrap.t  (* else     *)
    | Export   of lexeme Wrap.t  (* export   *)
    | False    of lexeme Wrap.t  (* false    *)
    | For      of lexeme Wrap.t  (* for      *)
    | From     of lexeme Wrap.t  (* from     *)
    | If       of lexeme Wrap.t  (* if       *)
    | Import   of lexeme Wrap.t  (* import   *)
    | Let      of lexeme Wrap.t  (* let      *)
    | Of       of lexeme Wrap.t  (* of       *)
    | Return   of lexeme Wrap.t  (* return   *)
    | Switch   of lexeme Wrap.t  (* switch   *)
(*  | This     of lexeme Wrap.t  (* this     *) *)
    | True     of lexeme Wrap.t  (* true     *)
(*  | Void     of lexeme Wrap.t  (* void     *) *)
    | While    of lexeme Wrap.t  (* while    *)
 (* | With     of lexeme Wrap.t  (* with     *) *)

    (* TypeScript keywords *)

    | As         of lexeme Wrap.t  (* as         *)
    | Extends    of lexeme Wrap.t  (* extends    *)
    | Function   of lexeme Wrap.t  (* function   *)
    | Implements of lexeme Wrap.t  (* implements *)
    | Interface  of lexeme Wrap.t  (* interface  *)
    | Namespace  of lexeme Wrap.t  (* namespace  *)
    | Type       of lexeme Wrap.t  (* type       *)

    (* JsLIGO-specific keywords *)

    | ContractOf  of lexeme Wrap.t  (* contract_of  *)
    | Do          of lexeme Wrap.t  (* do           *)
    | Match       of lexeme Wrap.t  (* match        *)
    | ParameterOf of lexeme Wrap.t  (* parameter_of *)
    | When        of lexeme Wrap.t  (* when         *)

    (* Virtual tokens *)

    | ZWSP      of lexeme Wrap.t  (* Zero-Width SPace *)
    | PARAMS    of lexeme Wrap.t  (* Mark function's parameters *)
    | ES6FUN    of lexeme Wrap.t  (* Mark candidate lambda *)
    | SEMI_ELSE of (lexeme Wrap.t * lexeme Wrap.t) (* ; else *)

    (* End-Of-File *)

    | EOF of lexeme Wrap.t


    type token = t

    (* FROM TOKENS TO LEXEMES *)

    let to_lexeme = function
      (* Directives *)

      Directive d -> [(Directive.to_lexeme d).Region.value]

      (* Comments *)

    | LineCom  t -> [sprintf "// %s" t#payload]
    | BlockCom t -> [sprintf "/* %s */" t#payload]

      (* Literals *)

    | String   t -> [sprintf "%S" t#payload]  (* Escaped *)
    | Verbatim t -> [String.escaped t#payload]
    | Bytes    t -> [fst t#payload]
    | Int      t
    | Nat      t -> [fst t#payload]
    | Mutez    t -> [fst t#payload]
    | Ident    t
    | UIdent   t
    | EIdent   t -> [t#payload]
    | Attr     t -> [Attr.to_lexeme t#payload]
 (* | Lang  lang -> "[%" ^ Region.(lang.value.value) *)

    (* Symbols *)

    | SHARP      t
    | MINUS      t
    | PLUS       t
    | SLASH      t
    | TIMES      t
    | REM        t
    | QMARK      t
    | PLUS2      t
    | MINUS2     t
    | LPAR       t
    | RPAR       t
    | LBRACE     t
    | RBRACE     t
    | LBRACKET   t
    | RBRACKET   t
    | COMMA      t
    | SEMI       t
    | COLON      t
    | DOT        t
    | ELLIPSIS   t
    | OR         t
    | AND        t
    | NOT        t
    | XOR        t
    | BIT_AND    t
    | BIT_NOT    t
    | BIT_XOR    t
    | BIT_SL     t
    | EQ         t
    | EQ2        t
    | NE         t
    | LT         t
    | GT         t
    | LE         t
    | PLUS_EQ    t
    | MINUS_EQ   t
    | MULT_EQ    t
    | REM_EQ     t
    | DIV_EQ     t
    | BIT_SL_EQ  t
    | BIT_SR_EQ  t
    | BIT_AND_EQ t
    | BIT_OR_EQ  t
    | BIT_XOR_EQ t
    | VBAR       t
    | ARROW      t
    | WILD       t

    (* JavaScript Keywords *)

    | Break    t
    | Case     t
 (* | Class    t *)
    | Const    t
    | Continue t
    | Default  t
    | Else     t
    | Export   t
    | False    t
    | For      t
    | From     t
    | If       t
    | Import   t
    | Let      t
    | Of       t
    | Return   t
    | Switch   t
(*  | This     t *)
    | True     t
(*  | Void     t *)
    | While    t
 (* | With     t *)

    (* TypeScript keywords *)

    | As         t
    | Extends    t
    | Function   t
    | Implements t
    | Interface  t
    | Namespace  t
    | Type       t

    (* JsLIGO-specific keywords *)

    | ContractOf  t
    | Do          t
    | Match       t
    | ParameterOf t
    | When        t -> [t#payload]

    (* Virtual tokens *)

    | ZWSP _
    | PARAMS _
    | ES6FUN _ -> [""]
    | SEMI_ELSE (l1,l2) -> [l1#payload; l2#payload]

    (* End-Of-File *)

    | EOF _ -> [""]


    (* KEYWORDS *)

    (* JavaScript Keywords *)

     let wrap_break    = wrap "break"
     let wrap_case     = wrap "case"
  (* let wrap_class    = wrap "class"   *)
     let wrap_const    = wrap "const"
     let wrap_continue = wrap "continue"
     let wrap_default  = wrap "default"
     let wrap_else     = wrap "else"
     let wrap_export   = wrap "export"
     let wrap_false    = wrap "false"
     let wrap_for      = wrap "for"
     let wrap_from     = wrap "from"
     let wrap_function = wrap "function"
     let wrap_if       = wrap "if"
     let wrap_import   = wrap "import"
     let wrap_let      = wrap "let"
     let wrap_of       = wrap "of"
     let wrap_return   = wrap "return"
     let wrap_switch   = wrap "switch"
  (* let wrap_this     = wrap "this"    *)
     let wrap_true     = wrap "true"
  (* let wrap_void     = wrap "void"    *)
     let wrap_while    = wrap "while"
  (* let wrap_with     = wrap "with"    *)

     let mk_Break    region = Break    (wrap_break    region)
     let mk_Case     region = Case     (wrap_case     region)
  (* let mk_Class    region = Class    (wrap_class    region) *)
     let mk_Const    region = Const    (wrap_const    region)
     let mk_Continue region = Continue (wrap_continue region)
     let mk_Default  region = Default  (wrap_default  region)
     let mk_Else     region = Else     (wrap_else     region)
     let mk_Export   region = Export   (wrap_export   region)
     let mk_False    region = False    (wrap_false    region)
     let mk_For      region = For      (wrap_for      region)
     let mk_From     region = From     (wrap_from     region)
     let mk_If       region = If       (wrap_if       region)
     let mk_Import   region = Import   (wrap_import   region)
     let mk_Let      region = Let      (wrap_let      region)
     let mk_Of       region = Of       (wrap_of       region)
     let mk_Return   region = Return   (wrap_return   region)
     let mk_Switch   region = Switch   (wrap_switch   region)
  (* let mk_This     region = This     (wrap_this     region) *)
     let mk_True     region = True     (wrap_true     region)
  (* let mk_Void     region = Void     (wrap_void     region) *)
     let mk_While    region = While    (wrap_while    region)
  (* let mk_With     region = With     (wrap_with     region) *)

     (* TypeScript keywords *)

     let wrap_as         = wrap "as"
     let wrap_extends    = wrap "extends"
     let wrap_implements = wrap "implements"
     let wrap_interface  = wrap "interface"
     let wrap_namespace  = wrap "namespace"
     let wrap_type       = wrap "type"

     let mk_As         region = As         (wrap_as         region)
     let mk_Extends    region = Extends    (wrap_extends    region)
     let mk_Function   region = Function   (wrap_function   region)
     let mk_Implements region = Implements (wrap_implements region)
     let mk_Interface  region = Interface  (wrap_interface  region)
     let mk_Namespace  region = Namespace  (wrap_namespace  region)
     let mk_Type       region = Type       (wrap_type       region)

     (* JsLIGO-specific keywords *)

     let wrap_contract_of  = wrap "contract_of"
     let wrap_do           = wrap "do"
     let wrap_match        = wrap "match"
     let wrap_parameter_of = wrap "parameter_of"
     let wrap_when         = wrap "when"

     let mk_ContractOf  region = ContractOf  (wrap_contract_of  region)
     let mk_Do          region = Do          (wrap_do           region)
     let mk_Match       region = Match       (wrap_match        region)
     let mk_ParameterOf region = ParameterOf (wrap_parameter_of region)
     let mk_When        region = When        (wrap_when         region)

    (* All keywords as smart constructors *)

     let keywords = [
       mk_Break;
       mk_Case;
  (*   mk_Class; *)
       mk_Const;
       mk_Continue;
       mk_Default;
       mk_Else;
       mk_Export;
       mk_False;
       mk_For;
       mk_From;
       mk_If;
       mk_Import;
       mk_Let;
       mk_Of;
       mk_Return;
       mk_Switch;
  (*   mk_This;   *)
       mk_True;
  (*   mk_Void;   *)
       mk_While;
  (*   mk_With;   *)

       mk_As;
       mk_Extends;
       mk_Function;
       mk_Implements;
       mk_Interface;
       mk_Namespace;
       mk_Type;

       mk_ContractOf;
       mk_Do;
       mk_Match;
       mk_ParameterOf;
       mk_When
     ]

    (* All keywords *)

    let keywords =
      let add map (key, data) =
        match SMap.add ~key ~data map with
          `Ok map -> map
        | `Duplicate -> map in
      let apply map mk_kwd =
        let lexemes = to_lexeme (mk_kwd Region.ghost) in
        List.fold_left ~f:(fun map lex -> add map (lex, mk_kwd))
                       ~init:map lexemes
      in List.fold_left ~f:apply ~init:SMap.empty keywords

    (* Ghost keywords *)

    (* JavaScript Keywords *)

    let ghost_break    = wrap_break    Region.ghost
    let ghost_case     = wrap_case     Region.ghost
 (* let ghost_class    = wrap_class    Region.ghost *)
    let ghost_const    = wrap_const    Region.ghost
    let ghost_continue = wrap_continue Region.ghost
    let ghost_default  = wrap_default  Region.ghost
    let ghost_else     = wrap_else     Region.ghost
    let ghost_export   = wrap_export   Region.ghost
    let ghost_false    = wrap_false    Region.ghost
    let ghost_for      = wrap_for      Region.ghost
    let ghost_from     = wrap_from     Region.ghost
    let ghost_if       = wrap_if       Region.ghost
    let ghost_import   = wrap_import   Region.ghost
    let ghost_let      = wrap_let      Region.ghost
    let ghost_of       = wrap_of       Region.ghost
    let ghost_return   = wrap_return   Region.ghost
    let ghost_switch   = wrap_switch   Region.ghost
 (* let ghost_this     = wrap_this     Region.ghost *)
    let ghost_true     = wrap_true     Region.ghost
 (* let ghost_void     = wrap_void     Region.ghost *)
    let ghost_while    = wrap_while    Region.ghost
 (* let ghost_with     = wrap_with     Region.ghost *)

    let ghost_Break    = Break   ghost_break
    let ghost_Case     = Case    ghost_case
 (* let ghost_Class    = Class   ghost_class    *)
    let ghost_Const    = Const   ghost_const
    let ghost_Default  = Default ghost_default
    let ghost_Else     = Else    ghost_else
    let ghost_Export   = Export  ghost_export
    let ghost_False    = False   ghost_false
    let ghost_For      = For     ghost_for
    let ghost_From     = From    ghost_from
    let ghost_If       = If      ghost_if
    let ghost_Import   = Import  ghost_import
    let ghost_Let      = Let     ghost_let
    let ghost_Of       = Of      ghost_of
    let ghost_Return   = Return  ghost_return
    let ghost_Switch   = Switch  ghost_switch
 (* let ghost_This     = This    ghost_this     *)
    let ghost_True     = True    ghost_true
 (* let ghost_Void     = Void    ghost_void     *)
    let ghost_While    = While   ghost_while
 (* let ghost_With     = With    ghost_with     *)

    (* TypeScript keywords *)

    let ghost_as         = wrap_as         Region.ghost
    let ghost_implements = wrap_implements Region.ghost
    let ghost_interface  = wrap_interface  Region.ghost
    let ghost_function   = wrap_function   Region.ghost
    let ghost_namespace  = wrap_namespace  Region.ghost
    let ghost_type       = wrap_type       Region.ghost

    let ghost_As         = As         ghost_as
    let ghost_Function   = Function   ghost_function
    let ghost_Implements = Implements ghost_implements
    let ghost_Interface  = Interface  ghost_interface
    let ghost_Namespace  = Namespace  ghost_namespace
    let ghost_Type       = Type       ghost_type

    (* JsLIGO-specific keywords *)

    let ghost_contract_of  = wrap_contract_of  Region.ghost
    let ghost_do           = wrap_do           Region.ghost
    let ghost_match        = wrap_match        Region.ghost
    let ghost_parameter_of = wrap_parameter_of Region.ghost
    let ghost_when         = wrap_when         Region.ghost

    let ghost_ContractOf   = ContractOf  ghost_contract_of
    let ghost_Do           = Do          ghost_do
    let ghost_Match        = Match       ghost_match
    let ghost_ParameterOf  = ParameterOf ghost_parameter_of
    let ghost_When         = When        ghost_when

    (* SYMBOLS *)

    let wrap_sharp      = wrap "#"
    let wrap_minus      = wrap "-"
    let wrap_plus       = wrap "+"
    let wrap_slash      = wrap "/"
    let wrap_times      = wrap "*"
    let wrap_rem        = wrap "%"
    let wrap_qmark      = wrap "?"
    let wrap_plus2      = wrap "++"
    let wrap_minus2     = wrap "--"
    let wrap_lpar       = wrap "("
    let wrap_rpar       = wrap ")"
    let wrap_lbracket   = wrap "["
    let wrap_rbracket   = wrap "]"
    let wrap_lbrace     = wrap "{"
    let wrap_rbrace     = wrap "}"
    let wrap_comma      = wrap ","
    let wrap_semi       = wrap ";"
    let wrap_colon      = wrap ":"
    let wrap_dot        = wrap "."
    let wrap_ellipsis   = wrap "..."
    let wrap_or         = wrap "||"
    let wrap_and        = wrap "&&"
    let wrap_not        = wrap "!"
    let wrap_xor        = wrap "^^"
    let wrap_bit_and    = wrap "&"
    let wrap_bit_not    = wrap "~"
    let wrap_bit_xor    = wrap "^"
    let wrap_bit_sl     = wrap "<<"
    let wrap_eq         = wrap "="
    let wrap_eq2        = wrap "=="
    let wrap_ne         = wrap "!="
    let wrap_lt         = wrap "<"
    let wrap_gt         = wrap ">"
    let wrap_le         = wrap "<="
    let wrap_ge         = wrap ">="
    let wrap_plus_eq    = wrap "+="
    let wrap_minus_eq   = wrap "-="
    let wrap_mult_eq    = wrap "*="
    let wrap_rem_eq     = wrap "%="
    let wrap_div_eq     = wrap "/="
    let wrap_bit_sl_eq  = wrap "<<="
    let wrap_bit_sr_eq  = wrap ">>="
    let wrap_bit_and_eq = wrap "&="
    let wrap_bit_or_eq  = wrap "|="
    let wrap_bit_xor_eq = wrap "^="
    let wrap_vbar       = wrap "|"
    let wrap_arrow      = wrap "=>"
    let wrap_wild       = wrap "_"
    let wrap_incr       = wrap "++"
    let wrap_decr       = wrap "--"

    (* Smart constructors *)

    let mk_SHARP      region = SHARP      (wrap_sharp      region)
    let mk_MINUS      region = MINUS      (wrap_minus      region)
    let mk_PLUS       region = PLUS       (wrap_plus       region)
    let mk_SLASH      region = SLASH      (wrap_slash      region)
    let mk_TIMES      region = TIMES      (wrap_times      region)
    let mk_REM        region = REM        (wrap_rem        region)
    let mk_QMARK      region = QMARK      (wrap_qmark      region)
    let mk_PLUS2      region = PLUS2      (wrap_plus2      region)
    let mk_MINUS2     region = MINUS2     (wrap_minus2     region)
    let mk_LPAR       region = LPAR       (wrap_lpar       region)
    let mk_RPAR       region = RPAR       (wrap_rpar       region)
    let mk_LBRACKET   region = LBRACKET   (wrap_lbracket   region)
    let mk_RBRACKET   region = RBRACKET   (wrap_rbracket   region)
    let mk_LBRACE     region = LBRACE     (wrap_lbrace     region)
    let mk_RBRACE     region = RBRACE     (wrap_rbrace     region)
    let mk_COMMA      region = COMMA      (wrap_comma      region)
    let mk_SEMI       region = SEMI       (wrap_semi       region)
    let mk_COLON      region = COLON      (wrap_colon      region)
    let mk_DOT        region = DOT        (wrap_dot        region)
    let mk_ELLIPSIS   region = ELLIPSIS   (wrap_ellipsis   region)
    let mk_OR         region = OR         (wrap_or         region)
    let mk_AND        region = AND        (wrap_and        region)
    let mk_NOT        region = NOT        (wrap_not        region)
    let mk_XOR        region = XOR        (wrap_xor        region)
    let mk_BIT_AND    region = BIT_AND    (wrap_bit_and    region)
    let mk_BIT_NOT    region = BIT_NOT    (wrap_bit_not    region)
    let mk_BIT_XOR    region = BIT_XOR    (wrap_bit_xor    region)
    let mk_BIT_SL     region = BIT_SL     (wrap_bit_sl     region)
    let mk_EQ         region = EQ         (wrap_eq         region)
    let mk_EQ2        region = EQ2        (wrap_eq2        region)
    let mk_NE         region = NE         (wrap_ne         region)
    let mk_LT         region = LT         (wrap_lt         region)
    let mk_GT         region = GT         (wrap_gt         region)
    let mk_LE         region = LE         (wrap_le         region)
    let mk_PLUS_EQ    region = PLUS_EQ    (wrap_plus_eq    region)
    let mk_MINUS_EQ   region = MINUS_EQ   (wrap_minus_eq   region)
    let mk_MULT_EQ    region = MULT_EQ    (wrap_mult_eq    region)
    let mk_REM_EQ     region = REM_EQ     (wrap_rem_eq     region)
    let mk_DIV_EQ     region = DIV_EQ     (wrap_div_eq     region)
    let mk_BIT_SL_EQ  region = BIT_SL_EQ  (wrap_bit_sl_eq  region)
    let mk_BIT_SR_EQ  region = BIT_SR_EQ  (wrap_bit_sr_eq  region)
    let mk_BIT_AND_EQ region = BIT_AND_EQ (wrap_bit_and_eq region)
    let mk_BIT_OR_EQ  region = BIT_OR_EQ  (wrap_bit_or_eq  region)
    let mk_BIT_XOR_EQ region = BIT_XOR_EQ (wrap_bit_xor_eq region)
    let mk_VBAR       region = VBAR       (wrap_vbar       region)
    let mk_ARROW      region = ARROW      (wrap_arrow      region)
    let mk_WILD       region = WILD       (wrap_wild       region)

    (* All symbol smart constructors *)

    let symbols = [
      mk_SHARP;
      mk_MINUS;
      mk_PLUS;
      mk_SLASH;
      mk_TIMES;
      mk_REM;
      mk_QMARK;
      mk_PLUS2;
      mk_MINUS2;
      mk_LPAR;
      mk_RPAR;
      mk_LBRACKET;
      mk_RBRACKET;
      mk_LBRACE;
      mk_RBRACE;
      mk_COMMA;
      mk_SEMI;
      mk_COLON;
      mk_DOT;
      mk_ELLIPSIS;
      mk_OR;
      mk_AND;
      mk_NOT;
      mk_XOR;
      mk_BIT_AND;
      mk_BIT_NOT;
      mk_BIT_XOR;
      mk_BIT_SL;
      mk_EQ;
      mk_EQ2;
      mk_NE;
      mk_LT;
      mk_GT;
      mk_LE;
      mk_PLUS_EQ;
      mk_MINUS_EQ;
      mk_MULT_EQ;
      mk_REM_EQ;
      mk_DIV_EQ;
      mk_BIT_SL_EQ;
      mk_BIT_SR_EQ;
      mk_BIT_AND_EQ;
      mk_BIT_OR_EQ;
      mk_BIT_XOR_EQ;
      mk_VBAR;
      mk_ARROW;
      mk_WILD
    ]

    (* All symbols *)

    let symbols =
      let add map (key, data) =
        match SMap.add ~key ~data map with
          `Ok map -> map
        | `Duplicate -> map in
      let apply map mk_sym =
        let lexemes = to_lexeme (mk_sym Region.ghost) in
        List.fold_left ~f:(fun map lex -> add map (lex, mk_sym))
                       ~init:map lexemes
      in List.fold_left ~f:apply ~init:SMap.empty symbols

    (* Ghost symbols *)

    let ghost_sharp      = wrap_sharp      Region.ghost
    let ghost_minus      = wrap_minus      Region.ghost
    let ghost_plus       = wrap_plus       Region.ghost
    let ghost_slash      = wrap_slash      Region.ghost
    let ghost_times      = wrap_times      Region.ghost
    let ghost_rem        = wrap_rem        Region.ghost
    let ghost_qmark      = wrap_qmark      Region.ghost
    let ghost_plus2      = wrap_plus2      Region.ghost
    let ghost_minus2     = wrap_minus2     Region.ghost
    let ghost_lpar       = wrap_lpar       Region.ghost
    let ghost_rpar       = wrap_rpar       Region.ghost
    let ghost_lbracket   = wrap_lbracket   Region.ghost
    let ghost_rbracket   = wrap_rbracket   Region.ghost
    let ghost_lbrace     = wrap_lbrace     Region.ghost
    let ghost_rbrace     = wrap_rbrace     Region.ghost
    let ghost_comma      = wrap_comma      Region.ghost
    let ghost_semi       = wrap_semi       Region.ghost
    let ghost_colon      = wrap_colon      Region.ghost
    let ghost_dot        = wrap_dot        Region.ghost
    let ghost_ellipsis   = wrap_ellipsis   Region.ghost
    let ghost_or         = wrap_or         Region.ghost
    let ghost_and        = wrap_and        Region.ghost
    let ghost_not        = wrap_not        Region.ghost
    let ghost_xor        = wrap_xor        Region.ghost
    let ghost_bit_and    = wrap_bit_and    Region.ghost
    let ghost_bit_not    = wrap_bit_not    Region.ghost
    let ghost_bit_xor    = wrap_bit_xor    Region.ghost
    let ghost_bit_sl     = wrap_bit_sl     Region.ghost
    let ghost_eq         = wrap_eq         Region.ghost
    let ghost_eq2        = wrap_eq2        Region.ghost
    let ghost_ne         = wrap_ne         Region.ghost
    let ghost_lt         = wrap_lt         Region.ghost
    let ghost_gt         = wrap_gt         Region.ghost
    let ghost_le         = wrap_le         Region.ghost
    let ghost_ge         = wrap_ge         Region.ghost
    let ghost_plus_eq    = wrap_plus_eq    Region.ghost
    let ghost_minus_eq   = wrap_minus_eq   Region.ghost
    let ghost_mult_eq    = wrap_mult_eq    Region.ghost
    let ghost_rem_eq     = wrap_rem_eq     Region.ghost
    let ghost_div_eq     = wrap_div_eq     Region.ghost
    let ghost_bit_sl_eq  = wrap_bit_sl_eq  Region.ghost
    let ghost_bit_sr_eq  = wrap_bit_sr_eq  Region.ghost
    let ghost_bit_and_eq = wrap_bit_and_eq Region.ghost
    let ghost_bit_or_eq  = wrap_bit_or_eq  Region.ghost
    let ghost_bit_xor_eq = wrap_bit_xor_eq Region.ghost
    let ghost_vbar       = wrap_vbar       Region.ghost
    let ghost_arrow      = wrap_arrow      Region.ghost
    let ghost_wild       = wrap_wild       Region.ghost
    let ghost_incr       = wrap_incr       Region.ghost
    let ghost_decr       = wrap_decr       Region.ghost

    let ghost_SHARP      = SHARP      ghost_sharp
    let ghost_MINUS      = MINUS      ghost_minus
    let ghost_PLUS       = PLUS       ghost_plus
    let ghost_SLASH      = SLASH      ghost_slash
    let ghost_TIMES      = TIMES      ghost_times
    let ghost_REM        = REM        ghost_rem
    let ghost_QMARK      = QMARK      ghost_qmark
    let ghost_PLUS2      = PLUS2      ghost_plus2
    let ghost_MINUS2     = MINUS2     ghost_minus2
    let ghost_LPAR       = LPAR       ghost_lpar
    let ghost_RPAR       = RPAR       ghost_rpar
    let ghost_LBRACKET   = LBRACKET   ghost_lbracket
    let ghost_RBRACKET   = RBRACKET   ghost_rbracket
    let ghost_LBRACE     = LBRACE     ghost_lbrace
    let ghost_RBRACE     = RBRACE     ghost_rbrace
    let ghost_COMMA      = COMMA      ghost_comma
    let ghost_SEMI       = SEMI       ghost_semi
    let ghost_COLON      = COLON      ghost_colon
    let ghost_DOT        = DOT        ghost_dot
    let ghost_ELLIPSIS   = ELLIPSIS   ghost_ellipsis
    let ghost_OR         = OR         ghost_or
    let ghost_AND        = AND        ghost_and
    let ghost_NOT        = NOT        ghost_not
    let ghost_XOR        = XOR        ghost_xor
    let ghost_BIT_AND    = BIT_AND    ghost_bit_and
    let ghost_BIT_NOT    = BIT_NOT    ghost_bit_not
    let ghost_BIT_XOR    = BIT_XOR    ghost_bit_xor
    let ghost_BIT_SL     = BIT_SL     ghost_bit_sl
    let ghost_EQ         = EQ         ghost_eq
    let ghost_EQ2        = EQ2        ghost_eq2
    let ghost_NE         = NE         ghost_ne
    let ghost_LT         = LT         ghost_lt
    let ghost_GT         = GT         ghost_gt
    let ghost_LE         = LE         ghost_le
    let ghost_PLUS_EQ    = PLUS_EQ    ghost_plus_eq
    let ghost_MINUS_EQ   = MINUS_EQ   ghost_minus_eq
    let ghost_MULT_EQ    = MULT_EQ    ghost_mult_eq
    let ghost_REM_EQ     = REM_EQ     ghost_rem_eq
    let ghost_DIV_EQ     = DIV_EQ     ghost_div_eq
    let ghost_BIT_SL_EQ  = BIT_SL_EQ  ghost_bit_sl_eq
    let ghost_BIT_SR_EQ  = BIT_SR_EQ  ghost_bit_sr_eq
    let ghost_BIT_AND_EQ = BIT_AND_EQ ghost_bit_and_eq
    let ghost_BIT_OR_EQ  = BIT_OR_EQ  ghost_bit_or_eq
    let ghost_BIT_XOR_EQ = BIT_XOR_EQ ghost_bit_xor_eq
    let ghost_VBAR       = VBAR       ghost_vbar
    let ghost_ARROW      = ARROW      ghost_arrow
    let ghost_WILD       = WILD       ghost_wild


    (* OTHER GHOST TOKENS *)

    (* IMPORTANT: These values cannot be exported in Token.mli *)

    let wrap_string   s = wrap s
    let wrap_verbatim s = wrap s
    let wrap_bytes    b = wrap ("0x" ^ Hex.show b, b)
    let wrap_int      z = wrap (Z.to_string z, z)
    let wrap_nat      z = wrap (Z.to_string z ^ "n", z)
    let wrap_mutez    m = wrap (Int64.to_string m ^ "mutez", m)
    let wrap_ident    i = wrap i
    let wrap_uident   i = wrap i
    let wrap_eident   i = wrap i

    let wrap_attr key value region = wrap (key, value) region

(*  let wrap_lang lang region =
      let start = region#start#shift_bytes (String.length "[%") in
      let lang_reg = Region.make ~start ~stop:region#stop in
      Region.{region; value = {value=lang; region=lang_reg}} *)

    let ghost_string   s = wrap_string   s   Region.ghost
    let ghost_verbatim s = wrap_verbatim s   Region.ghost
    let ghost_bytes    b = wrap_bytes    b   Region.ghost
    let ghost_int      z = wrap_int      z   Region.ghost
    let ghost_nat      z = wrap_nat      z   Region.ghost
    let ghost_mutez    m = wrap_mutez    m   Region.ghost
    let ghost_ident    i = wrap_ident    i   Region.ghost
    let ghost_uident   i = wrap_uident   i   Region.ghost
    let ghost_eident   i = wrap_eident   i   Region.ghost
    let ghost_attr   k v = wrap_attr     k v Region.ghost
(*  let ghost_lang     l = wrap_lang     l   Region.ghost *)

    let ghost_String   s = String   (ghost_string s)
    let ghost_Verbatim s = Verbatim (ghost_verbatim s)
    let ghost_Bytes    b = Bytes    (ghost_bytes b)
    let ghost_Int      z = Int      (ghost_int z)
    let ghost_Nat      z = Nat      (ghost_nat z)
    let ghost_Mutez    m = Mutez    (ghost_mutez m)
    let ghost_Ident    i = Ident    (ghost_ident i)
    let ghost_UIdent   i = UIdent   (ghost_uident i)
    let ghost_EIdent   i = EIdent   (ghost_eident i)
    let ghost_Attr   k v = Attr     (ghost_attr k v)
(*  let ghost_Lang     l = Lang     (ghost_lang l) *)

    (* COMMENTS *)

    let wrap_block_com  c    = wrap c
    let ghost_block_com c    = wrap_block_com c Region.ghost
    let mk_BlockCom c region = BlockCom (wrap_block_com c region)
    let ghost_BlockCom c     = mk_BlockCom c Region.ghost

    let wrap_line_com c     = wrap c
    let ghost_line_com c    = wrap_line_com c Region.ghost
    let mk_LineCom c region = LineCom (wrap_line_com c region)
    let ghost_LineCom c     = mk_LineCom c Region.ghost

    (* VIRTUAL TOKENS *)

    let wrap_zwsp      = wrap ""
    let ghost_zwsp     = wrap_zwsp Region.ghost
    let mk_ZWSP region = ZWSP (wrap_zwsp region)
    let ghost_ZWSP     = mk_ZWSP Region.ghost

    let wrap_params      = wrap ""
    let ghost_params     = wrap_params Region.ghost
    let mk_PARAMS region = PARAMS (wrap_params region)
    let ghost_PARAMS     = mk_PARAMS Region.ghost

    let wrap_es6fun      = wrap ""
    let ghost_es6fun     = wrap_es6fun Region.ghost
    let mk_ES6FUN region = ES6FUN (wrap_es6fun region)
    let ghost_ES6FUN     = mk_ES6FUN Region.ghost

    let wrap_semi_else r1 r2 = wrap_semi r1, wrap_else r2
    let ghost_semi_else      = ghost_semi, ghost_else
    let ghost_SEMI_ELSE      = SEMI_ELSE ghost_semi_else

    (* END-OF-FILE TOKEN *)

    let wrap_eof      = wrap ""
    let ghost_eof     = wrap_eof Region.ghost
    let mk_EOF region = EOF (wrap_eof region)
    let ghost_EOF     = mk_EOF Region.ghost

    (* FROM TOKEN STRINGS TO LEXEMES *)

    let concrete = function
      (* Literals *)

      "Ident"    -> "x"
    | "UIdent"   -> "X"
    | "EIdent"   -> "@x"
    | "Int"      -> "1"
    | "Nat"      -> "1n"
    | "Mutez"    -> "1mutez"
    | "String"   -> "\"a string\""
    | "Verbatim" -> "{|verbatim|}"
    | "Bytes"    -> "0xAA"
    | "Attr"     -> "[@attr]"
 (* | "Lang"     -> "[%Michelson" *)

    (* Symbols *)

    | "SHARP"      -> ghost_sharp#payload
    | "MINUS"      -> ghost_minus#payload
    | "PLUS"       -> ghost_plus#payload
    | "SLASH"      -> ghost_slash#payload
    | "TIMES"      -> ghost_times#payload
    | "REM"        -> ghost_rem#payload
    | "QMARK"      -> ghost_qmark#payload
    | "PLUS2"      -> ghost_plus2#payload
    | "MINUS2"     -> ghost_minus2#payload
    | "LPAR"       -> ghost_lpar#payload
    | "RPAR"       -> ghost_rpar#payload
    | "LBRACE"     -> ghost_lbrace#payload
    | "RBRACE"     -> ghost_rbrace#payload
    | "LBRACKET"   -> ghost_lbracket#payload
    | "RBRACKET"   -> ghost_rbracket#payload
    | "COMMA"      -> ghost_comma#payload
    | "SEMI"       -> ghost_semi#payload
    | "COLON"      -> ghost_colon#payload
    | "DOT"        -> ghost_dot#payload
    | "ELLIPSIS"   -> ghost_ellipsis#payload
    | "OR"         -> ghost_or#payload
    | "AND"        -> ghost_and#payload
    | "NOT"        -> ghost_not#payload
    | "XOR"        -> ghost_xor#payload
    | "BIT_AND"    -> ghost_bit_and#payload
    | "BIT_NOT"    -> ghost_bit_not#payload
    | "BIT_XOR"    -> ghost_bit_xor#payload
    | "BIT_SL"     -> ghost_bit_sl#payload
    | "EQ"         -> ghost_eq#payload
    | "EQ2"        -> ghost_eq2#payload
    | "NE"         -> ghost_ne#payload
    | "LT"         -> ghost_lt#payload
    | "GT"         -> ghost_gt#payload
    | "LE"         -> ghost_le#payload
    | "PLUS_EQ"    -> ghost_plus_eq#payload
    | "MINUS_EQ"   -> ghost_minus_eq#payload
    | "MULT_EQ"    -> ghost_mult_eq#payload
    | "REM_EQ"     -> ghost_rem_eq#payload
    | "DIV_EQ"     -> ghost_div_eq#payload
    | "BIT_SL_EQ"  -> ghost_bit_sl_eq#payload
    | "BIT_SR_EQ"  -> ghost_bit_sr_eq#payload
    | "BIT_AND_EQ" -> ghost_bit_and_eq#payload
    | "BIT_OR_EQ"  -> ghost_bit_or_eq#payload
    | "BIT_XOR_EQ" -> ghost_bit_xor_eq#payload
    | "VBAR"       -> ghost_vbar#payload
    | "ARROW"      -> ghost_arrow#payload
    | "WILD"       -> ghost_wild#payload

    (* JavaScript Keywords *)

    | "Break"    -> ghost_break#payload
    | "Case"     -> ghost_case#payload
 (* | "Class"    -> ghost_class#payload *)
    | "Const"    -> ghost_const#payload
    | "Continue" -> ghost_continue#payload
    | "Default"  -> ghost_default#payload
    | "Else"     -> ghost_else#payload
    | "Export"   -> ghost_export#payload
    | "False"    -> ghost_false#payload
    | "For"      -> ghost_for#payload
    | "From"     -> ghost_from#payload
    | "If"       -> ghost_if#payload
    | "Import"   -> ghost_import#payload
    | "Let"      -> ghost_let#payload
    | "Of"       -> ghost_of#payload
    | "Return"   -> ghost_return#payload
    | "Switch"   -> ghost_switch#payload
 (* | "This"     -> ghost_this#payload *)
    | "True"     -> ghost_true#payload
 (* | "Void"     -> ghost_void#payload *)
    | "While"    -> ghost_while#payload
 (* | "With"     -> ghost_with#payload *)

    (* TypeScript keywords *)

    | "As"         -> ghost_as#payload
    | "Function"   -> ghost_function#payload
    | "Implements" -> ghost_implements#payload
    | "Interface"  -> ghost_interface#payload
    | "Namespace"  -> ghost_namespace#payload
    | "Type"       -> ghost_type#payload

    (* JsLIGO-specific keywords *)

    | "ContractOf"  -> ghost_contract_of#payload
    | "Do"          -> ghost_do#payload
    | "Match"       -> ghost_match#payload
    | "ParameterOf" -> ghost_parameter_of#payload
    | "When"        -> ghost_when#payload

    (* Virtual tokens *)

    | "ZWSP"
    | "PARAMS"
    | "ES6FUN" -> ""
    | "SEMI_ELSE" -> (fst ghost_semi_else)#payload ^ " "
                     ^ (snd ghost_semi_else)#payload

    (* End-Of-File *)

    | "EOF" -> ""

    (* This case should not happen! *)

    | _  -> "\\Unknown" (* Backslash meant to trigger an error *)


    (* FROM TOKENS TO TOKEN STRINGS AND REGIONS *)

    let comments (w : _ Wrap.t) =
      if Caml.(w#comments = [] && w#line_comment = None) then ""
      else " + comment(s)"

    let proj_token = function
      (* Preprocessing directives *)

      Directive d -> Directive.project d

      (* Comments *)

    | LineCom t ->
        t#region, sprintf "LineCom %S" t#payload
    | BlockCom t ->
        t#region, sprintf "BlockCom %S" t#payload

      (* Literals *)

    | String t ->
        t#region, sprintf "String %S%s" t#payload (comments t)
    | Verbatim t ->
        t#region, sprintf "Verbatim %S%s" t#payload (comments t)
    | Bytes t ->
        let s, b = t#payload in
        t#region,
        sprintf "Bytes (%S, \"0x%s\")%s" s (Hex.show b) (comments t)
    | Int t ->
        let s, n = t#payload in
        t#region, sprintf "Int (%S, %s)%s"
                          s (Z.to_string n) (comments t)
    | Nat t ->
        let s, n = t#payload in
        t#region, sprintf "Nat (%S, %s)" s (Z.to_string n)
    | Mutez t ->
        let s, n = t#payload in
        t#region, sprintf "Mutez (%S, %s)" s (Int64.to_string n)
    | Ident t ->
        t#region, sprintf "Ident %S%s" t#payload (comments t)
    | UIdent t ->
        t#region, sprintf "UIdent %S%s" t#payload (comments t)
    | EIdent t ->
        t#region, sprintf "EIdent %S%s" t#payload (comments t)
    | Attr t ->
        t#region, sprintf "Attr %s%s"
                          (Attr.to_string t#payload) (comments t)
 (* | Lang {value = {value = payload; _}; region; _} ->
        region, sprintf "Lang %S" payload *)

    (* Symbols *)

    | SHARP      t -> t#region, sprintf "SHARP%s" (comments t)
    | MINUS      t -> t#region, sprintf "MINUS%s" (comments t)
    | PLUS       t -> t#region, sprintf "PLUS%s" (comments t)
    | SLASH      t -> t#region, sprintf "SLASH%s" (comments t)
    | TIMES      t -> t#region, sprintf "TIMES%s" (comments t)
    | REM        t -> t#region, sprintf "REM%s" (comments t)
    | QMARK      t -> t#region, sprintf "QMARK%s" (comments t)
    | PLUS2      t -> t#region, sprintf "PLUS2%s" (comments t)
    | MINUS2     t -> t#region, sprintf "MINUS2%s" (comments t)
    | LPAR       t -> t#region, sprintf "LPAR%s" (comments t)
    | RPAR       t -> t#region, sprintf "RPAR%s" (comments t)
    | LBRACE     t -> t#region, sprintf "LBRACE%s" (comments t)
    | RBRACE     t -> t#region, sprintf "RBRACE%s" (comments t)
    | LBRACKET   t -> t#region, sprintf "LBRACKET%s" (comments t)
    | RBRACKET   t -> t#region, sprintf "RBRACKET%s" (comments t)
    | COMMA      t -> t#region, sprintf "COMMA%s" (comments t)
    | SEMI       t -> t#region, sprintf "SEMI%s" (comments t)
    | COLON      t -> t#region, sprintf "COLON%s" (comments t)
    | DOT        t -> t#region, sprintf "DOT%s" (comments t)
    | ELLIPSIS   t -> t#region, sprintf "ELLIPSIS%s" (comments t)
    | OR         t -> t#region, sprintf "OR%s" (comments t)
    | AND        t -> t#region, sprintf "AND%s" (comments t)
    | NOT        t -> t#region, sprintf "NOT%s" (comments t)
    | XOR        t -> t#region, sprintf "XOR%s" (comments t)
    | BIT_AND    t -> t#region, sprintf "BIT_AND%s" (comments t)
    | BIT_NOT    t -> t#region, sprintf "BIT_NOT%s" (comments t)
    | BIT_XOR    t -> t#region, sprintf "BIT_XOR%s" (comments t)
    | BIT_SL     t -> t#region, sprintf "BIT_SL%s" (comments t)
    | EQ         t -> t#region, sprintf "EQ%s" (comments t)
    | EQ2        t -> t#region, sprintf "EQ2%s" (comments t)
    | NE         t -> t#region, sprintf "NE%s" (comments t)
    | LT         t -> t#region, sprintf "LT%s" (comments t)
    | GT         t -> t#region, sprintf "GT%s" (comments t)
    | LE         t -> t#region, sprintf "LE%s" (comments t)
    | PLUS_EQ    t -> t#region, sprintf "PLUS_EQ%s" (comments t)
    | MINUS_EQ   t -> t#region, sprintf "MINUS_EQ%s" (comments t)
    | MULT_EQ    t -> t#region, sprintf "MULT_EQ%s" (comments t)
    | REM_EQ     t -> t#region, sprintf "REM_EQ%s" (comments t)
    | DIV_EQ     t -> t#region, sprintf "DIV_EQ%s" (comments t)
    | BIT_SL_EQ  t -> t#region, sprintf "BIT_SL_EQ%s" (comments t)
    | BIT_SR_EQ  t -> t#region, sprintf "BIT_SR_EQ%s" (comments t)
    | BIT_AND_EQ t -> t#region, sprintf "BIT_AND_EQ%s" (comments t)
    | BIT_OR_EQ  t -> t#region, sprintf "BIT_OR_EQ%s" (comments t)
    | BIT_XOR_EQ t -> t#region, sprintf "BIT_XOR_EQ%s" (comments t)
    | VBAR       t -> t#region, sprintf "VBAR%s" (comments t)
    | ARROW      t -> t#region, sprintf "ARROW%s" (comments t)
    | WILD       t -> t#region, sprintf "WILD%s" (comments t)

    (* JavaScript Keywords *)

 (* | Break    t -> t#region, sprintf "Break%s" (comments t) *)
    | Case     t -> t#region, sprintf "Case%s" (comments t)
 (* | Class    t -> t#region, sprintf "Class%s (comments t)" *)
    | Const    t -> t#region, sprintf "Const%s" (comments t)
    | Continue t -> t#region, sprintf "Continue%s" (comments t)
    | Default  t -> t#region, sprintf "Default%s" (comments t)
    | Else     t -> t#region, sprintf "Else%s" (comments t)
    | Export   t -> t#region, sprintf "Export%s" (comments t)
    | False    t -> t#region, sprintf "False%s" (comments t)
    | For      t -> t#region, sprintf "For%s" (comments t)
    | If       t -> t#region, sprintf "If%s" (comments t)
    | Import   t -> t#region, sprintf "Import%s" (comments t)
    | Let      t -> t#region, sprintf "Let%s" (comments t)
    | Of       t -> t#region, sprintf "Of%s" (comments t)
    | Return   t -> t#region, sprintf "Return%s" (comments t)
    | Break    t -> t#region, sprintf "Break%s" (comments t)
    | Switch   t -> t#region, sprintf "Switch%s" (comments t)
 (* | This     t -> t#region, sprintf "This%s" (comments t) *)
    | True     t -> t#region, sprintf "True%s" (comments t)
 (* | Void     t -> t#region, sprintf "Void%s" (comments t) *)
    | While    t -> t#region, sprintf "While%s" (comments t)
    | From     t -> t#region, sprintf "From%s" (comments t)
 (* | With     t -> t#region, sprintf "With%s" (comments t) *)

    (* TypeScript keywords *)

    | As          t -> t#region, sprintf "As%s" (comments t)
    | Extends     t -> t#region, sprintf "Extends%s" (comments t)
    | Function    t -> t#region, sprintf "Function%s" (comments t)
    | Implements  t -> t#region, sprintf "Implements%s" (comments t)
    | Interface   t -> t#region, sprintf "Interface%s" (comments t)
    | Namespace   t -> t#region, sprintf "Namespace%s" (comments t)
    | Type        t -> t#region, sprintf "Type%s" (comments t)

    (* JsLIGO-specific keywords *)

    | ContractOf  t -> t#region, sprintf "ContractOf%s" (comments t)
    | Do          t -> t#region, sprintf "Do%s" (comments t)
    | Match       t -> t#region, sprintf "Match%s" (comments t)
    | ParameterOf t -> t#region, sprintf "ParameterOf%s" (comments t)
    | When        t -> t#region, sprintf "When%s" (comments t)

    (* Virtual tokens *)

    | ZWSP      t -> t#region, sprintf "ZWSP%s" (comments t)
    | PARAMS    t -> t#region, sprintf "PARAMS%s" (comments t)
    | ES6FUN    t -> t#region, sprintf "ES6FUN%s" (comments t)
    | SEMI_ELSE (t1, t2) ->
        let region   = Region.cover t1#region t2#region
        and comments =
          if Caml.(t1#comments = []) && Caml.(t2#comments = []) then ""
          else " + comments"
        in region, sprintf "SEMI_ELSE%s" comments

    (* End-Of-File *)

    | EOF t -> t#region, sprintf "EOF%s" (comments t)


    (* CONVERSIONS *)

    let to_string ~offsets mode token =
      let region, val_str = proj_token token in
      let reg_str = region#compact ~offsets mode
      in sprintf "%s: %s" reg_str val_str

    let to_region token = proj_token token |> fst

    (* SMART CONSTRUCTORS *)

    (* Keywords *)

    type kwd_err = Invalid_keyword

    let mk_kwd ident region =
      match SMap.find keywords ident with
        Some mk_kwd -> Ok (mk_kwd region)
      |        None -> Error Invalid_keyword

    (* Directives *)

    let mk_directive dir = Directive dir

    (* Strings *)

    let mk_string lexeme region = String (wrap lexeme region)

    (* Verbatim strings *)

    let mk_verbatim lexeme region = Verbatim (wrap lexeme region)

    (* Bytes *)

    let mk_bytes lexeme bytes region =
      Bytes (wrap ("0x" ^ lexeme, `Hex bytes) region)

    (* Integers *)

    let mk_int lexeme z region = Int (wrap (lexeme, z) region)

    (* Natural numbers *)

    type nat_err = Wrong_nat_syntax of string (* Not CameLIGO *)

    let mk_nat nat z region = Ok (Nat (wrap (nat ^ "n", z) region))

(*  let mk_nat _nat _z _region =
      Error (Wrong_nat_syntax "Example: \"12334 as nat\".") *)

    (* Mutez *)

    type mutez_err = Wrong_mutez_syntax of string

    let mk_mutez nat ~suffix int64 region =
      Ok (Mutez (wrap (nat ^ suffix, int64) region))

(*  let mk_mutez _nat ~suffix:_ _int64 _region =
      Error (Wrong_mutez_syntax "Example: \"1234 as mutez\".") *)

    (* End-Of-File *)

    let mk_eof region = EOF (wrap "" region)

    (* Symbols *)

    type sym_err = Invalid_symbol of string

    let mk_sym lexeme region =
      match SMap.find symbols lexeme with
        Some mk_sym -> Ok (mk_sym region)
      |        None -> Error (Invalid_symbol lexeme)

    (* Identifiers *)

    let mk_ident value region =
      match SMap.find keywords value with
        Some mk_kwd -> mk_kwd region
      |        None -> Ident (wrap value region)

    (* Escaped identifiers *)

    let mk_eident value region = EIdent (wrap value region)

    (* Constructors/Namespaces *)

    let mk_uident value region = UIdent (wrap value region)

    (* Attributes *)

    let mk_attr ~key ?value region = Attr (wrap (key, value) region)

    (* Code injection *)

    type lang_err = Wrong_lang_syntax of string

    let mk_lang _lang _region =
      Error (Wrong_lang_syntax
               "Example: \"(Michelson `{UNPAIR; ADD}` \
                         as ((n: [nat, nat]) => nat))\".")

    (* PREDICATES *)

    let is_int    = function Int    _ -> true | _ -> false
    let is_string = function String _ -> true | _ -> false
    let is_bytes  = function Bytes  _ -> true | _ -> false
    let is_eof    = function EOF    _ -> true | _ -> false

    let hex_digits = ["A"; "B"; "C"; "D"; "E"; "F";
                      "a"; "b"; "c"; "d"; "e"; "f"]

    let is_hex = function
      UIdent t | Ident t ->
        List.mem hex_digits t#payload ~equal:String.equal
    | _ -> false

    let is_sym = function
      SHARP _
    | MINUS _
    | PLUS _
    | SLASH _
    | TIMES _
    | REM _
    | QMARK _
    | PLUS2 _
    | MINUS2 _
    | LPAR _
    | RPAR _
    | LBRACKET _
    | RBRACKET _
    | LBRACE _
    | RBRACE _
    | COMMA _
    | SEMI _
    | COLON _
    | DOT _
    | ELLIPSIS _
    | OR _
    | AND _
    | NOT _
    | XOR _
    | BIT_AND _
    | BIT_NOT _
    | BIT_XOR _
    | BIT_SL _
    | EQ _
    | EQ2 _
    | NE _
    | LT _
    | GT _
    | LE _
    | PLUS_EQ _
    | MINUS_EQ _
    | MULT_EQ _
    | DIV_EQ _
    | REM_EQ _
    | BIT_SL_EQ _
    | BIT_SR_EQ _
    | BIT_AND_EQ _
    | BIT_OR_EQ _
    | BIT_XOR_EQ _
    | VBAR _
    | ARROW _
    | WILD _ -> true
    | _ -> false

    (* Verbatim strings *)

    let verbatim_delimiters = ("`", "`")
  end

include T

module type S = module type of T
