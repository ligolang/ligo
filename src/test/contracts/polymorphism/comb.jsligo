type dup<a> = [a, a];

const diag = <T>(x : T) => [x, x];

const _rev = <T>([xs, acc] : [list<T>, list<T>]) : list<T> =>
  match(xs) {
    when([]): acc;
    when([z,...zs]): _rev([zs, list([z,...acc])])
  };

const rev = <T>(xs : list<T>) : list<T> => _rev([xs, (list([]) as list<T>)]);


const _zip = <T,U>([xs, ys, acc] : [list<T>, list<U>, list<[T, U]>]) : list<[T, U]> =>
  match(xs) {
    when([]):
       match(ys) {
         when([]): acc;
         when([_y, ..._ys]): (failwith ("oops") as list<[T, U]>)
       };
    when([z, ...zs]):
        match(ys) {
          when([]): (failwith ("oops") as list<[T, U]>);
          when([w, ...ws]): _zip([zs, ws, list([[z, w], ...acc])])
        };
  };

const zip = <T,U>(xs : list<T>) => ((ys : list<U>) : list<[T, U]> => rev (_zip ([xs, ys, (list([]) as list<[T, U]>)])));

const self_zip = <T>(lst : list<T>) : list<[T, T]> => {
  let [xs, ys] = diag(lst);
  return (zip(xs))(ys)
};

const v : list<[string, string]> = self_zip (list(["a","b"]));
const w : list<[int, nat]> = (zip (list([1,2,3])))(list([(4 as nat),(5 as nat),(6 as nat)]));
