type tokens = big_map<address, nat>;

type allowances = big_map<[address, address], nat>;

/* (sender,account) -> value */
type storage = {
  tokens: tokens,
  allowances: allowances,
  total_amount: nat,
};

type transfer = {
  address_from: address,
  address_to: address,
  value: nat,
};

type approve = { spender: address, value: nat, };

type getAllowance = {
  owner: address,
  spender: address,
  callback: contract<nat>,
};

type getBalance = {
  owner: address,
  callback: contract<nat>,
};

type getTotalSupply = { callback: contract<nat>, };

type action =
  | ["Transfer", transfer]
  | ["Approve", approve]
  | ["GetAllowance", getAllowance]
  | ["GetBalance", getBalance]
  | ["GetTotalSupply", getTotalSupply];

let transfer = ([p, s]: [transfer, storage]): [
  list<operation>,
  storage
] => {
  let new_allowances = 0;
  if (Tezos.get_sender() == p.address_from) {
    new_allowances = s.allowances;
  } else {
    let opt =
      Big_map.find_opt(
        [Tezos.get_sender(), p.address_from],
        s.allowances
      );
    let authorized_value: nat =
      match(opt) {
        when (Some(value)):
          value
        when (None()):
          (0 as nat)
      };
    if (authorized_value < p.value) {
      (failwith("Not Enough Allowance") as allowances);
    } else {
      new_allowances
      = Big_map.update(
          [Tezos.get_sender(), p.address_from],
          (Some(abs(authorized_value - p.value))),
          s.allowances
        );
    };
  };
  let opt = Big_map.find_opt(p.address_from, s.tokens);
  let sender_balance: nat =
    match(opt) {
      when (Some(value)):
        value
      when (None()):
        (0 as nat)
    };
  if (sender_balance < p.value) {
    (
      failwith("Not Enough Balance") as
        [list<operation>, storage]
    );
  } else {
    let new_tokens =
      Big_map.update(
        p.address_from,
        (Some(abs(sender_balance - p.value))),
        s.tokens
      );
    let opt = Big_map.find_opt(p.address_to, s.tokens);
    let receiver_balance: nat =
      match(opt) {
        when (Some(value)):
          value
        when (None()):
          (0 as nat)
      };
    let new_tokens2 =
      Big_map.update(
        p.address_to,
        (Some(receiver_balance + p.value)),
        new_tokens
      );
    return [
      (list([]) as list<operation>),
      {
        ...s,
        tokens: new_tokens2,
        allowances: new_allowances
      }
    ];
  };
};

const main20 = ([action, store]: [parameter, storage]): return_ =>
  match(action) {
    when (Action_A(n)):
      entry_A([n, store])
    when (Action_B(s)):
      entry_B([s, store])
  };

const main21 = ([action, store]: [parameter, storage]): return_ =>
  match(action) {
    when (Action_A(n)):
      entry_A([n, store])
    when (Action_B(s)):
      entry_B([s, store])
  };

